diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
new file mode 100644
index 0000000..86a3913
--- /dev/null
+++ b/.github/CODE_OF_CONDUCT.md
@@ -0,0 +1,74 @@
+# Contributor Covenant Code of Conduct
+
+## Our Pledge
+
+In the interest of fostering an open and welcoming environment, we as
+contributors and maintainers pledge to making participation in our project and
+our community a harassment-free experience for everyone, regardless of age, body
+size, disability, ethnicity, gender identity and expression, level of experience,
+education, socio-economic status, nationality, personal appearance, race,
+religion, or sexual identity and orientation.
+
+## Our Standards
+
+Examples of behavior that contributes to creating a positive environment
+include:
+
+* Using welcoming and inclusive language
+* Being respectful of differing viewpoints and experiences
+* Gracefully accepting constructive criticism
+* Focusing on what is best for the community
+* Showing empathy towards other community members
+
+Examples of unacceptable behavior by participants include:
+
+* The use of sexualized language or imagery and unwelcome sexual attention or
+  advances
+* Trolling, insulting/derogatory comments, and personal or political attacks
+* Public or private harassment
+* Publishing others' private information, such as a physical or electronic
+  address, without explicit permission
+* Other conduct which could reasonably be considered inappropriate in a
+  professional setting
+
+## Our Responsibilities
+
+Project maintainers are responsible for clarifying the standards of acceptable
+behavior and are expected to take appropriate and fair corrective action in
+response to any instances of unacceptable behavior.
+
+Project maintainers have the right and responsibility to remove, edit, or
+reject comments, commits, code, wiki edits, issues, and other contributions
+that are not aligned to this Code of Conduct, or to ban temporarily or
+permanently any contributor for other behaviors that they deem inappropriate,
+threatening, offensive, or harmful.
+
+## Scope
+
+This Code of Conduct applies both within project spaces and in public spaces
+when an individual is representing the project or its community. Examples of
+representing a project or community include using an official project e-mail
+address, posting via an official social media account, or acting as an appointed
+representative at an online or offline event. Representation of a project may be
+further defined and clarified by project maintainers.
+
+## Enforcement
+
+Instances of abusive, harassing, or otherwise unacceptable behavior may be
+reported by contacting the project team at {{ email }}. All
+complaints will be reviewed and investigated and will result in a response that
+is deemed necessary and appropriate to the circumstances. The project team is
+obligated to maintain confidentiality with regard to the reporter of an incident.
+Further details of specific enforcement policies may be posted separately.
+
+Project maintainers who do not follow or enforce the Code of Conduct in good
+faith may face temporary or permanent repercussions as determined by other
+members of the project's leadership.
+
+## Attribution
+
+This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
+available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html
+
+[homepage]: https://www.contributor-covenant.org
+
diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
new file mode 100644
index 0000000..84d08ab
--- /dev/null
+++ b/.github/CONTRIBUTING.md
@@ -0,0 +1,179 @@
+# CONTRIBUTING
+
+## AstroNvim install for contributors
+
+If you wish to contribute to AstroNvim, you should:
+
+1. [create a fork on GitHub](https://docs.github.com/en/get-started/quickstart/fork-a-repo)
+2. clone your fork to your machine
+
+- For ssh:
+  ```shell
+  $ git clone git@github.com:<YOUR GITHUB USERNAME>/AstroNvim.git ~/.config/nvim
+  ```
+- For https:
+  ```shell
+  $ git clone https://github.com/<YOUR GITHUB USERNAME>/AstroNvim.git ~/.config/nvim
+  ```
+
+3. [add a new remote repo to track](https://www.atlassian.com/git/tutorials/git-forks-and-upstreams)
+   - this means you can push/pull as normal to your own repo, but also easily track & update from the AstroNvim repo
+   - for ssh:
+     ```shell
+     $ git remote add upstream git@github.com:AstroNvim/AstroNvim.git
+     ```
+   - for https:
+     ```shell
+     $ git remote add upstream https://github.com/AstroNvim/AstroNvim.git
+     ```
+4. any time you create a branch to do some work, use
+   ```shell
+   $ git fetch upstream && git checkout -b dev-myFEAT upstream/main
+   ```
+5. only use the **--rebase** flag to update your dev branch
+   - this means that there are no `Merge AstroNvim/main into devBranch` commits, which are to be avoided
+   ```shell
+   $ git pull upstream --rebase
+   ```
+
+## Things to know before contributing
+
+- Development happens on the `nightly` branch, so please make sure of a couple things
+
+  - all branches are rebased on the `nightly` branch to get the latest updates.
+
+  - all pull requests are made to merge into `nightly`
+
+- When making a PR (pull request), please be very descriptive about what you've done!
+
+- Commit messages must follow [Conventional Commits Specification](https://www.conventionalcommits.org/en/v1.0.0/)
+
+  - PR titles and commit messages should be formatted with 'fix', 'feat', 'docs', 'refactor', or 'chore'. ex: `feat: add new plugin`
+
+  - If your contribution mostly pertains to a single module in AstroNvim, please include that in the title. ex: If you have modified something in the `lua/configs/lsp` folder for the lsp configuration use something like `fix(lsp): typo in lsp mappings`
+
+  - If your contribution contains any sort of breaking change include a `!` at the end of the change type. ex: `feat!: move status bar from lualine to feline`
+
+- PRs should follow the pull request formats where applicable
+
+- We are open to all PRs, but if a PR is denied for any reason please don't be discouraged! We'll still be open to discussions. If you have any questions before opening the PR feel free to join the [discord server](https://discord.astronvim.com).
+
+- AstroNvim aims to provide the best user experience when it comes to being able to support confident updating for users, for this reason please avoid opening PRs with breaking changes. Avoiding breaking changes is not always going to be possible, so if you think it is completely necessary we are open to discussion.
+
+## How to remove, squash, or edit commits from your PR
+
+> You may have been directed here to remove a commit such as a merge commit: `Merge AstroNvim/main into devBranch` from your PR
+
+> As these commands edit your git history, you may need to **force push** with `git push origin --force-with-lease`
+
+1. Run the following:
+
+```
+$ git rebase -i HEAD~<NUMBER OF COMMITS TO GO BACK>
+```
+
+  <details><summary>Example</summary>
+  <p>
+  
+  ```shell
+  $ git rebase -i HEAD~4
+  ```
+  
+  ```shell
+  pick 28b2dcb feat: statusline add lsp status
+  pick dad9a39 fix: typo
+  pick 68f72f1 add clickable btn for exiting nvim
+  pick b281b53 avoid using q! for quitting vim
+  
+  # Rebase 52b655b..b281b53 onto 52b655b (4 commands)
+  #
+  # Commands:
+  # p, pick <commit> = use commit
+  # r, reword <commit> = use commit, but edit the commit message
+  # e, edit <commit> = use commit, but stop for amending
+  # s, squash <commit> = use commit, but meld into previous commit
+  # f, fixup <commit> = like "squash", but discard this commit's log message
+  # x, exec <command> = run command (the rest of the line) using shell
+  # b, break = stop here (continue rebase later with 'git rebase --continue')
+  # d, drop <commit> = remove commit
+  # l, label <label> = label current HEAD with a name
+  # t, reset <label> = reset HEAD to a label
+  # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
+  # .       create a merge commit using the original merge commit's
+  # .       message (or the oneline, if no original merge commit was
+  # .       specified). Use -c <commit> to reword the commit message.
+  #
+  # These lines can be re-ordered; they are executed from top to bottom.
+  #
+  # If you remove a line here THAT COMMIT WILL BE LOST.
+  #
+  # However, if you remove everything, the rebase will be aborted.
+  #
+  # Note that empty commits are commented out
+  ```
+  
+  </p>
+  </details>
+
+2. Change the `pick` commands to whatever you wish, you may wish to `s` `squash`, `d` `drop` or `e` `edit` a commit. Then save & quit this git file to run it.
+
+  <details><summary>Example</summary>
+  <p>
+  
+  ```shell {3,4}
+  pick 28b2dcb feat: statusline add lsp status
+  squash dad9a39 fix: typo
+  edit 68f72f1 add clickable btn for exiting nvim
+  d b281b53 avoid using q! for quitting vim
+  
+  # Rebase 52b655b..b281b53 onto 52b655b (4 commands)
+  #
+  # Commands:
+  # p, pick <commit> = use commit
+  # r, reword <commit> = use commit, but edit the commit message
+  # e, edit <commit> = use commit, but stop for amending
+  # s, squash <commit> = use commit, but meld into previous commit
+  # f, fixup <commit> = like "squash", but discard this commit's log message
+  # x, exec <command> = run command (the rest of the line) using shell
+  # b, break = stop here (continue rebase later with 'git rebase --continue')
+  # d, drop <commit> = remove commit
+  # l, label <label> = label current HEAD with a name
+  # t, reset <label> = reset HEAD to a label
+  # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
+  # .       create a merge commit using the original merge commit's
+  # .       message (or the oneline, if no original merge commit was
+  # .       specified). Use -c <commit> to reword the commit message.
+  #
+  # These lines can be re-ordered; they are executed from top to bottom.
+  #
+  # If you remove a line here THAT COMMIT WILL BE LOST.
+  #
+  # However, if you remove everything, the rebase will be aborted.
+  #
+  # Note that empty commits are commented out
+  ```
+  
+  </p>
+  </details>
+
+3. If you picked `drop` you are done. If you picked `squash` then you will be brought to a screen to update the commit message for the new aggregated commit, please make sure the new commit message follows the Conventional Commit specification. If you picked `edit` then edit your files, then run:
+
+```shell
+$ git add <files>
+```
+
+4. Continue rebasing until all edits are finished. Run the following command to continue through the rebase if there are more changes:
+
+```shell
+$ git rebase --continue
+```
+
+5. Push the changes with `--force-with-lease`:
+
+```shell
+$ git push origin --force-with-lease
+```
+
+## Help
+
+For help with contributing and anything else AstroNvim related join the [discord](https://discord.astronvim.com)
diff --git a/.github/ISSUE_TEMPLATE/bug_report.yaml b/.github/ISSUE_TEMPLATE/bug_report.yaml
new file mode 100644
index 0000000..5a6e95c
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/bug_report.yaml
@@ -0,0 +1,78 @@
+name: Bug report
+description: Create a report to help us improve
+labels: [bug]
+
+body:
+  - type: checkboxes
+    id: terms
+    attributes:
+      label: Checklist
+      description: Have you completed the following steps and are still able to replicate the issue?
+      options:
+        - label: "Using a stable version of Neovim (i.e. not neovim nightly)"
+          required: true
+        - label: "`:AstroUpdate`"
+          required: true
+        - label: Restarted AstroNvim
+          required: true
+  - type: input
+    id: system-version
+    attributes:
+      label: "Operating system/version"
+      placeholder: "macOS 11.5"
+    validations:
+      required: true
+  - type: input
+    id: terminal
+    attributes:
+      label: "Terminal/GUI"
+      placeholder: "kitty"
+    validations:
+      required: true
+  - type: textarea
+    id: health
+    attributes:
+      label: AstroNvim Health
+      description: Output of `:checkhealth astronvim`
+      placeholder: |
+        ## AstroNvim
+        - INFO: AstroNvim Version: nightly (v2.11.8-181-g11d5990)
+        - INFO: Neovim Version: v0.8.3
+        - OK: Using stable Neovim >= 0.8.0
+    validations:
+      required: true
+  - type: textarea
+    id: description
+    attributes:
+      label: Describe the bug
+      placeholder: A clear and concise description of what the bug is.
+    validations:
+      required: true
+  - type: textarea
+    id: reproduce
+    attributes:
+      label: Steps to Reproduce
+      placeholder: |
+        1. Go to '...'
+        2. Click on '....'
+        3. Scroll down to '....'
+        4. See error
+    validations:
+      required: true
+  - type: textarea
+    id: expected
+    attributes:
+      label: Expected behavior
+      placeholder: A clear and concise description of what you expected to happen
+    validations:
+      required: true
+  - type: textarea
+    id: screenshots
+    attributes:
+      label: Screenshots
+      description: If applicable, add screenshots or recording ([Asciinema](asciinema.org)) to help explain your problem.
+  - type: textarea
+    id: additional-context
+    attributes:
+      label: Additional Context
+      placeholder: Add any additional context about the problem here.
diff --git a/.github/ISSUE_TEMPLATE/bug_report.yml b/.github/ISSUE_TEMPLATE/bug_report.yml
deleted file mode 100644
index 77391b9..0000000
--- a/.github/ISSUE_TEMPLATE/bug_report.yml
+++ /dev/null
@@ -1,114 +0,0 @@
-name: Bug report
-description: Create a report to help us improve
-labels: [bug]
-
-body:
-  - type: checkboxes
-    id: terms
-    attributes:
-      label: Checklist
-      description: Have you checked if someone has reported this issue before?
-      options:
-        - label: I have searched through the AstroNvim docs
-          required: true
-        - label: I have searched through the existing issues of AstroNvim
-          required: true
-        - label: I have searched the existing issues of plugins related to this issue
-          required: true
-        - label: I have run `:Lazy update` and are on the latest version of AstroNvim
-          required: true
-        - label: I can replicate the bug with the minimal `repro.lua` provided below
-          required: true
-  - type: input
-    id: neovim-version
-    attributes:
-      label: "Neovim version (nvim -v)"
-      placeholder: "0.9.5 release"
-    validations:
-      required: true
-  - type: input
-    id: system-version
-    attributes:
-      label: "Operating system/version"
-      placeholder: "macOS 11.5"
-    validations:
-      required: true
-  - type: input
-    id: terminal
-    attributes:
-      label: "Terminal/GUI"
-      placeholder: "kitty"
-    validations:
-      required: true
-  - type: textarea
-    id: description
-    attributes:
-      label: Describe the bug
-      placeholder: A clear and concise description of what the bug is.
-    validations:
-      required: true
-  - type: textarea
-    id: reproduce
-    attributes:
-      label: Steps to Reproduce
-      placeholder: |
-        1. Go to '...'
-        2. Click on '....'
-        3. Scroll down to '....'
-        4. See error
-    validations:
-      required: true
-  - type: textarea
-    id: expected
-    attributes:
-      label: Expected behavior
-      placeholder: A clear and concise description of what you expected to happen
-    validations:
-      required: true
-  - type: textarea
-    id: screenshots
-    attributes:
-      label: Screenshots
-      description: If applicable, add screenshots or recording ([Asciinema](asciinema.org)) to help explain your problem.
-  - type: textarea
-    id: additional-context
-    attributes:
-      label: Additional Context
-      placeholder: Add any additional context about the problem here.
-  - type: textarea
-    attributes:
-      label: Repro
-      description: Minimal `init.lua` to reproduce this issue. Save as `repro.lua` and run with `nvim -u repro.lua`
-      value: |
-        -- save as repro.lua
-        -- run with nvim -u repro.lua
-        -- DO NOT change the paths
-        local root = vim.fn.fnamemodify("./.repro", ":p")
-
-        -- set stdpaths to use .repro
-        for _, name in ipairs({ "config", "data", "state", "runtime", "cache" }) do
-          vim.env[("XDG_%s_HOME"):format(name:upper())] = root .. "/" .. name
-        end
-
-        -- bootstrap lazy
-        local lazypath = root .. "/plugins/lazy.nvim"
-        if not vim.loop.fs_stat(lazypath) then
-          -- stylua: ignore
-          vim.fn.system({ "git", "clone", "--filter=blob:none", "https://github.com/folke/lazy.nvim.git", "--branch=stable", lazypath })
-        end
-        vim.opt.rtp:prepend(vim.env.LAZY or lazypath)
-
-        -- install plugins
-        local plugins = {
-          { "AstroNvim/AstroNvim", import = "astronvim.plugins" },
-
-          -- add any other plugins/customizations here
-        }
-        require("lazy").setup(plugins, {
-          root = root .. "/plugins",
-        })
-
-        -- add anything else here (autocommands, vim.filetype, etc.)
-      render: Lua
-    validations:
-      required: false
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
new file mode 100644
index 0000000..ec51e75
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/config.yml
@@ -0,0 +1,8 @@
+blank_issues_enabled: false
+contact_links:
+  - name: r/AstroNvim (Reddit)
+    url: https://www.reddit.com/r/AstroNvim
+    about: Ask questions about AstroNvim on the official Subreddit
+  - name: Discord Chat
+    url: https://discord.astronvim.com
+    about: Ask questions and have discussions about AstroNvim on Discord
diff --git a/.github/ISSUE_TEMPLATE/feature_request.yaml b/.github/ISSUE_TEMPLATE/feature_request.yaml
new file mode 100644
index 0000000..e28e766
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/feature_request.yaml
@@ -0,0 +1,22 @@
+name: Feature request
+description: Suggest an idea for this project
+labels: [enhancement]
+
+body:
+  - type: textarea
+    id: problem
+    attributes:
+      label: Is your feature related to a problem?
+      placeholder: A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
+  - type: textarea
+    id: solution
+    attributes:
+      label: Describe the new feature
+      placeholder: A clear and concise description of what the new feature is.
+    validations:
+      required: true
+  - type: textarea
+    id: additional-context
+    attributes:
+      label: Additional context
+      placeholder: Add any other context or screenshots about the feature request here.
diff --git a/.github/PULL_REQUEST_TEMPLATE/chore.md b/.github/PULL_REQUEST_TEMPLATE/chore.md
new file mode 100644
index 0000000..60c219a
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE/chore.md
@@ -0,0 +1,7 @@
+Fixes Issue # (If it doesn't fix an issue then delete this line)
+
+Description:
+Describe the refactor or cleanup that was completed
+
+Other:
+Anything else relevant goes here
diff --git a/.github/PULL_REQUEST_TEMPLATE/feature.md b/.github/PULL_REQUEST_TEMPLATE/feature.md
new file mode 100644
index 0000000..b2ff3d5
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE/feature.md
@@ -0,0 +1,10 @@
+Fixes Issue # (If it doesn't fix an issue then delete this line)
+
+Features Added:
+- Plugin Name (Add links if possible too)
+
+Reasoning:
+List why the feature is needed
+
+Other:
+Anything else relevant goes here
diff --git a/.github/PULL_REQUEST_TEMPLATE/fix.md b/.github/PULL_REQUEST_TEMPLATE/fix.md
new file mode 100644
index 0000000..a173370
--- /dev/null
+++ b/.github/PULL_REQUEST_TEMPLATE/fix.md
@@ -0,0 +1,7 @@
+Fixes Issue # (If it doesn't fix an issue then delete this line)
+
+Bugs Fixed:
+- A bullet for each bug fixed and a description
+
+Other:
+Anything else relevant goes here
diff --git a/README.md b/.github/README.md
similarity index 59%
rename from README.md
rename to .github/README.md
index 93d4ea6..d6703e2 100644
--- a/README.md
+++ b/.github/README.md
@@ -5,9 +5,9 @@
 <h1 align="center">AstroNvim</h1>
 
 <h4 align="center">
-  <a href="https://docs.astronvim.com/#-installation">Install</a>
+  <a href="https://docs.astronvim.com/#%EF%B8%8F-installation">Install</a>
   ·
-  <a href="https://docs.astronvim.com/#-configuration">Configure</a>
+  <a href="https://docs.astronvim.com/#%EF%B8%8F-configuration">Configure</a>
   ·
   <a href="https://github.com/AstroNvim/astrocommunity">Community Plugins</a>
   ·
@@ -17,16 +17,29 @@
 </h4>
 
 <p align="center">
-    <a href="https://github.com/AstroNvim/AstroNvim/pulse"><img src="https://img.shields.io/github/last-commit/AstroNvim/AstroNvim?style=for-the-badge&logo=github&color=7dc4e4&logoColor=D9E0EE&labelColor=302D41"></a>
-    <a href="https://github.com/AstroNvim/AstroNvim/releases/latest"><img src="https://img.shields.io/github/v/release/AstroNvim/AstroNvim?style=for-the-badge&logo=gitbook&color=8bd5ca&logoColor=D9E0EE&labelColor=302D41"></a>
-    <a href="https://github.com/AstroNvim/AstroNvim/stargazers"><img src="https://img.shields.io/github/stars/AstroNvim/AstroNvim?style=for-the-badge&logo=apachespark&color=eed49f&logoColor=D9E0EE&labelColor=302D41"></a>
-     <img src="https://img.shields.io/endpoint?url=https://waka.mehalter.com/api/compat/shields/v1/mehalter/interval:any/label:AstroNvim&style=for-the-badge&label=wakatime&logo=wakatime&color=a6da95&logoColor=D9E0EE&labelColor=302D41">
+    <a href="https://github.com/AstroNvim/AstroNvim/pulse">
+      <img src="https://img.shields.io/github/last-commit/AstroNvim/AstroNvim?style=for-the-badge&logo=github&color=7dc4e4&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <a href="https://github.com/AstroNvim/AstroNvim/releases/latest">
+      <img src="https://img.shields.io/github/v/release/AstroNvim/AstroNvim?style=for-the-badge&logo=gitbook&color=8bd5ca&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <a href="https://github.com/AstroNvim/AstroNvim/stargazers">
+      <img src="https://img.shields.io/github/stars/AstroNvim/AstroNvim?style=for-the-badge&logo=apachespark&color=eed49f&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <img src="https://img.shields.io/endpoint?url=https://waka.mehalter.com/api/compat/shields/v1/mehalter/interval:any/label:AstroNvim&style=for-the-badge&label=wakatime&logo=wakatime&color=a6da95&logoColor=D9E0EE&labelColor=302D41"/>
     <br>
-    <a href="https://www.twitter.com/AstroNvim"><img src="https://img.shields.io/badge/@AstroNvim-e05d44?style=for-the-badge&logo=twitter&color=fab387&logoColor=D9E0EE&labelColor=302D41"></a>
-    <a href="https://hachyderm.io/@AstroNvim"><img src="https://img.shields.io/badge/@AstroNvim-e05d44?domain=https%3A%2F%2Fhachyderm.io&style=for-the-badge&logo=mastodon&color=eebebe&logoColor=D9E0EE&labelColor=302D41"></a>
-    <a href="https://www.reddit.com/r/AstroNvim/"><img src="https://img.shields.io/badge/%2Fr%2FAstroNvim-e05d44?style=for-the-badge&logo=reddit&color=ee99a0&logoColor=D9E0EE&labelColor=302D41"></a>
-    <br>
-    <a href=https://discord.astronvim.com><img src="https://img.shields.io/discord/939594913560031363?style=for-the-badge&logo=discord&color=cba6f7&logoColor=D9E0EE&labelColor=302D41"></a>
+    <a href="https://www.twitter.com/AstroNvim">
+      <img src="https://img.shields.io/twitter/follow/AstroNvim?style=for-the-badge&logo=twitter&color=fab387&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <a href="https://hachyderm.io/@AstroNvim">
+      <img src="https://img.shields.io/mastodon/follow/110685512385862046?domain=https%3A%2F%2Fhachyderm.io&style=for-the-badge&logo=mastodon&color=eebebe&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <a href="https://www.reddit.com/r/AstroNvim/">
+      <img src="https://img.shields.io/reddit/subreddit-subscribers/AstroNvim?style=for-the-badge&logo=reddit&color=ee99a0&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
+    <a href="https://discord.astronvim.com">
+      <img src="https://img.shields.io/discord/939594913560031363?style=for-the-badge&logo=discord&color=cba6f7&logoColor=D9E0EE&labelColor=302D41"/>
+    </a>
 </p>
 
 <p align="center">
@@ -47,14 +60,14 @@ AstroNvim is an aesthetically pleasing and feature-rich neovim config that is ex
 - Terminal with [Toggleterm](https://github.com/akinsho/toggleterm.nvim)
 - Fuzzy finding with [Telescope](https://github.com/nvim-telescope/telescope.nvim)
 - Syntax highlighting with [Treesitter](https://github.com/nvim-treesitter/nvim-treesitter)
-- Formatting and Linting with [None-ls](https://github.com/nvimtools/none-ls.nvim)
+- Formatting and Linting with [Null-ls](https://github.com/jose-elias-alvarez/null-ls.nvim)
 - Language Server Protocol with [Native LSP](https://github.com/neovim/nvim-lspconfig)
 - Debug Adapter Protocol with [nvim-dap](https://github.com/mfussenegger/nvim-dap)
 
 ## ⚡ Requirements
 
 - [Nerd Fonts](https://www.nerdfonts.com/font-downloads) (_Optional with manual intervention:_ See [Documentation on customizing icons](https://docs.astronvim.com/Recipes/icons)) <sup>[[1]](#1)</sup>
-- [Neovim 0.9.1+ (_Not_ including nightly)](https://github.com/neovim/neovim/releases/tag/stable)
+- [Neovim 0.8+ (_Not_ including nightly)](https://github.com/neovim/neovim/releases/tag/stable)
 - [Tree-sitter CLI](https://github.com/tree-sitter/tree-sitter/blob/master/cli/README.md) (_Note:_ This is only necessary if you want to use `auto_install` feature with Treesitter)
 - A clipboard tool is necessary for the integration with the system clipboard (see [`:help clipboard-tool`](https://neovim.io/doc/user/provider.html#clipboard-tool) for supported solutions)
 - Terminal with true color support (for the default theme, otherwise it is dependent on the theme you are using) <sup>[[2]](#2)</sup>
@@ -66,16 +79,12 @@ AstroNvim is an aesthetically pleasing and feature-rich neovim config that is ex
   - [Python](https://www.python.org/) - python repl toggle terminal (`<leader>tp`)
   - [Node](https://nodejs.org/en/) - node repl toggle terminal (`<leader>tn`)
 
-> [!NOTE]
 > <sup id="1">[1]</sup> All downloadable Nerd Fonts contain icons which are used by AstroNvim. Install the Nerd Font of your choice to your system and in your terminal emulator settings, set its font face to that Nerd Font. If you are using AstroNvim on a remote system via SSH, you do not need to install the font on the remote system.
 
-> [!NOTE]
-> <sup id="2">[2]</sup> Note when using default theme: For MacOS, the default terminal does not have true color support. You will need to use [iTerm2](https://iterm2.com/), [Kitty](https://sw.kovidgoyal.net/kitty/), [WezTerm](https://wezfurlong.org/wezterm/), or another [terminal emulator](https://github.com/termstandard/colors?tab=readme-ov-file#truecolor-support-in-output-devices) that has true color support.
+> <sup id="2">[2]</sup> Note when using default theme: For MacOS, the default terminal does not have true color support. You will need to use [iTerm2](https://iterm2.com/), [Kitty](https://sw.kovidgoyal.net/kitty/), [WezTerm](https://wezfurlong.org/wezterm/), or another [terminal emulator](https://gist.github.com/XVilka/8346728#terminal-emulators) that has true color support.
 
 ## 🛠️ Installation
 
-AstroNvim is provided as a plugin that can be installed with the [`lazy.nvim`](https://github.com/folke/lazy.nvim) plugin manager and then used to import all of the plugin configurations that AstroNvim provides. To quickly get started it is recommended to start with the official [AstroNvim Template](https://github.com/AstroNvim/template) which provides a great starting point for a new AstroNvim based configuration.
-
 ### Linux/Mac OS (Unix)
 
 #### Make a backup of your current nvim and shared folder
@@ -83,15 +92,12 @@ AstroNvim is provided as a plugin that can be installed with the [`lazy.nvim`](h
 ```shell
 mv ~/.config/nvim ~/.config/nvim.bak
 mv ~/.local/share/nvim ~/.local/share/nvim.bak
-mv ~/.local/state/nvim ~/.local/state/nvim.bak
-mv ~/.cache/nvim ~/.cache/nvim.bak
 ```
 
-#### Clone the template repository
+#### Clone the repository
 
 ```shell
-git clone --depth 1 https://github.com/AstroNvim/template ~/.config/nvim
-rm -rf ~/.config/nvim/.git
+git clone --depth 1 https://github.com/AstroNvim/AstroNvim ~/.config/nvim
 nvim
 ```
 
@@ -107,26 +113,10 @@ Rename-Item -Path $env:LOCALAPPDATA\nvim-data -NewName $env:LOCALAPPDATA\nvim-da
 #### Clone the repository
 
 ```pwsh
-git clone --depth 1 https://github.com/AstroNvim/template $env:LOCALAPPDATA\nvim
-Remove-Item $env:LOCALAPPDATA\nvim\.git -Recurse -Force
+git clone --depth 1 https://github.com/AstroNvim/AstroNvim $env:LOCALAPPDATA\nvim
 nvim
 ```
 
-#### Minimal `~/.config/nvim/init.lua`
-
-Some user's might not want to use an entire template or do any customization. Here is a minimal `~/.config/nvim/init.lua` file that simply set's up a base AstroNvim installation:
-
-```lua
-local lazypath = vim.fn.stdpath "data" .. "/lazy/lazy.nvim"
-if not (vim.uv or vim.loop).fs_stat(lazypath) then
-  -- stylua: ignore
-  vim.fn.system({ "git", "clone", "--filter=blob:none", "https://github.com/folke/lazy.nvim.git", "--branch=stable", lazypath })
-end
-vim.opt.rtp:prepend(lazypath)
-
-require("lazy").setup { "AstroNvim/AstroNvim", version = "^4", import = "astronvim.plugins" }
-```
-
 ## 📦 Basic Setup
 
 #### Install LSP
@@ -154,17 +144,24 @@ Run `:Lazy clean` to remove any disabled or unused plugins
 
 Run `:Lazy sync` to update and clean plugins
 
+#### Update AstroNvim
+
+Run `:AstroUpdate` to get the latest updates from the repository<br>
+
 #### Update AstroNvim Packages
 
-Run `:AstroUpdate` (`<leader>pa`) to update both Neovim plugins and Mason packages
+Run `:AstroUpdatePackages` (`<leader>pa`) to update both Neovim plugins and Mason packages
 
 ## 🗒️ Links
 
-- [AstroNvim Website](https://astronvim.com)
-- [AstroNvim Documentation](https://docs.astronvim.com)
-- [Setup](https://docs.astronvim.com/#-setup) is given for basic editor setup after installation
-- [Default Mappings](https://docs.astronvim.com/mappings) more about the default key bindings
-- [Customizing Plugins](https://docs.astronvim.com/configuration/customizing_plugins/) more about configuring and adding plugins
+[AstroNvim Website](https://astronvim.com)
+[AstroNvim Documentation](https://docs.astronvim.com)
+[Core AstroNvim LUA API Documentation](https://api.astronvim.com)
+
+- [Basic Usage](https://docs.astronvim.com/basic-usage/walkthrough) is given for basic usage
+- [Default Mappings](https://docs.astronvim.com/basic-usage/mappings) more about the default key bindings
+- [Default Plugin Configuration](https://docs.astronvim.com/configuration/plugin_defaults) more about the provided plugin defaults
+- [Advanced Configuration](https://docs.astronvim.com/configuration/config_options) more about advanced configuration
 
 ### 📹 Videos
 
@@ -176,13 +173,13 @@ There have been some great review videos released by members of the community! H
 
 ## 🚀 Contributing
 
-If you plan to contribute, please check the [contribution guidelines](https://github.com/AstroNvim/.github/blob/main/CONTRIBUTING.md) first.
+If you plan to contribute, please check the [contribution guidelines](CONTRIBUTING.md) first.
 
 ## ⭐ Credits
 
 Sincere appreciation to the following repositories, plugin authors and the entire neovim community out there that made the development of AstroNvim possible.
 
-- [Plugins](https://docs.astronvim.com/reference/default_plugins/)
+- [Plugins](https://docs.astronvim.com/acknowledgements#plugins-used-in-astronvim)
 - [NvChad](https://github.com/NvChad/NvChad)
 - [LunarVim](https://github.com/LunarVim)
 - [CosmicVim](https://github.com/CosmicNvim/CosmicNvim)
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
deleted file mode 100644
index 5d4ea67..0000000
--- a/.github/workflows/ci.yml
+++ /dev/null
@@ -1,21 +0,0 @@
-name: AstroNvim
-on:
-  push:
-    branches: [main]
-  pull_request:
-  pull_request_target:
-    types: [opened, edited, synchronize]
-
-jobs:
-  CI:
-    uses: AstroNvim/.github/.github/workflows/plugin_ci.yml@main
-    if: ${{ github.event_name != 'pull_request_target' }}
-    secrets: inherit
-    with:
-      plugin_name: ${{ github.event.repository.name }}
-      is_production: ${{ github.event_name == 'push' }}
-      docs: false
-  PR:
-    uses: AstroNvim/.github/.github/workflows/validate_pr.yml@main
-    if: ${{ github.event_name == 'pull_request_target' }}
-    secrets: inherit
diff --git a/.github/workflows/conventional_commit.yml b/.github/workflows/conventional_commit.yml
new file mode 100644
index 0000000..9778b01
--- /dev/null
+++ b/.github/workflows/conventional_commit.yml
@@ -0,0 +1,13 @@
+name: Conventional Commits
+
+on:
+  pull_request:
+    branches: [main]
+
+jobs:
+  build:
+    name: Conventional Commits
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: webiny/action-conventional-commits@v1.1.0
diff --git a/.github/workflows/docs.yml b/.github/workflows/docs.yml
new file mode 100644
index 0000000..93a9528
--- /dev/null
+++ b/.github/workflows/docs.yml
@@ -0,0 +1,34 @@
+name: Documentation
+
+on:
+  push:
+    branches: ["main"]
+  pull_request:
+
+jobs:
+  docs:
+    runs-on: ubuntu-latest
+
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v3
+      - name: Setup Lua
+        uses: leafo/gh-actions-lua@v10
+        with:
+          luaVersion: 5.4
+      - name: Install LDoc
+        uses: leafo/gh-actions-luarocks@v4
+      - name: Setup dependencies
+        run: luarocks install ldoc
+      - name: Build Docs
+        run: |
+          ldoc .
+      - name: Deploy
+        uses: nwtgck/actions-netlify@v2.0
+        env:
+          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_TOKEN }}
+          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
+        with:
+          github-token: ${{ secrets.GITHUB_TOKEN }}
+          publish-dir: docs
+          production-deploy: ${{ github.ref == 'refs/heads/main' }}
diff --git a/.github/workflows/luacheck.yml b/.github/workflows/luacheck.yml
new file mode 100644
index 0000000..87111d6
--- /dev/null
+++ b/.github/workflows/luacheck.yml
@@ -0,0 +1,13 @@
+name: Lua Linting
+
+on:
+  push:
+    branches: ["main"]
+  pull_request:
+
+jobs:
+  lint:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: lunarmodules/luacheck@v1
diff --git a/.github/workflows/spell.yml b/.github/workflows/spell.yml
new file mode 100644
index 0000000..45ef258
--- /dev/null
+++ b/.github/workflows/spell.yml
@@ -0,0 +1,14 @@
+name: Spell Check
+
+on:
+  pull_request:
+
+jobs:
+  typos-check:
+    name: Spell Check with Typos
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Actions Repository
+        uses: actions/checkout@v3
+      - name: Check spelling
+        uses: crate-ci/typos@master
diff --git a/.github/workflows/stale.yml b/.github/workflows/stale.yml
index ac2bac4..391c6e7 100644
--- a/.github/workflows/stale.yml
+++ b/.github/workflows/stale.yml
@@ -5,5 +5,22 @@ on:
 
 jobs:
   stale:
-    uses: AstroNvim/.github/.github/workflows/stale.yml@main
-    secrets: inherit
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/stale@v8
+        with:
+          # default stale time
+          days-before-stale: 30
+          days-before-close: 5
+          # never stale pull requests
+          days-before-pr-stale: -1
+          days-before-pr-close: -1
+          # exclude issues with certain labels
+          exempt-issue-labels: pinned,wip,security,notice
+          # never stale issues attached to a milestone
+          exempt-all-milestones: true
+          # write message on stale issues
+          stale-issue-message: >
+            This issue has been automatically marked as stale because it has not had
+            recent activity. It will be closed in 5 days if no further activity occurs.
+            Thank you for your contributions.
diff --git a/.github/workflows/style.yml b/.github/workflows/style.yml
new file mode 100644
index 0000000..f666542
--- /dev/null
+++ b/.github/workflows/style.yml
@@ -0,0 +1,18 @@
+name: Style Check
+
+on:
+  push:
+    branches: ["main"]
+  pull_request:
+
+jobs:
+  style:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+      - uses: JohnnyMorganz/stylua-action@v3
+        with:
+          token: ${{ secrets.GITHUB_TOKEN }}
+          version: latest
+          # CLI arguments
+          args: --check .
diff --git a/.github/workflows/updater.yml b/.github/workflows/updater.yml
new file mode 100644
index 0000000..8bb5ab2
--- /dev/null
+++ b/.github/workflows/updater.yml
@@ -0,0 +1,35 @@
+name: Updater Comment
+
+on:
+  pull_request_target:
+    paths: ["**.lua"]
+    types: ["opened"]
+
+jobs:
+  updater-comment:
+    name: Comment updater settings
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/github-script@v6
+        with:
+          script: |
+            const src = context.payload.pull_request.head
+            const user = src.user.login
+            const tab = "  "
+            let settings = tab + "updater = {\n" + tab + tab + `channel = "nightly",\n`
+            if (src.ref != "nightly") {
+              settings += tab + tab + `branch = "${src.ref}",\n`
+            }
+            if (user != "AstroNvim") {
+              settings += tab + tab + `remote = "${user}",\n`
+              settings += tab + tab + `remotes = {\n`
+              settings += tab + tab + tab + `["${user}"] = "${user}/${src.repo.name}",\n`
+              settings += tab + tab + `},\n`
+            }
+            settings += tab + "},"
+            github.rest.issues.createComment({
+              issue_number: context.issue.number,
+              owner: context.repo.owner,
+              repo: context.repo.repo,
+              body: "Use the following `updater` settings in your `user/init.lua` file, restart, and run `:AstroUpdate` to test this pull request:\n```\n" + settings + "\n```",
+            })
diff --git a/.gitignore b/.gitignore
index def9862..ede40eb 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,6 +1,16 @@
 # Project gitignore
 .luarc.json
+after
 coc-settings.json
+colors
+docs
+ftplugin
+ginit.vim
+lua/user
+neoconf.json
+plugin
+queries
+spell
 
 # Global gitignore
 # ----------------
diff --git a/.luacheckrc b/.luacheckrc
new file mode 100644
index 0000000..d1113eb
--- /dev/null
+++ b/.luacheckrc
@@ -0,0 +1,18 @@
+-- Global objects
+globals = {
+  "astronvim",
+  "astronvim_installation",
+  "vim",
+  "bit",
+}
+
+-- Rerun tests only if their modification time changed
+cache = true
+
+-- Don't report unused self arguments of methods
+self = false
+
+ignore = {
+  "631", -- max_line_length
+  "212/_.*", -- unused argument, for vars with "_" prefix
+}
diff --git a/.styluaignore b/.styluaignore
index 23e3165..52ccbc0 100644
--- a/.styluaignore
+++ b/.styluaignore
@@ -1 +1 @@
-lua/astronvim/lazy_snapshot.lua
+lua/lazy_snapshot.lua
diff --git a/.typos.toml b/.typos.toml
index eee6ad3..f9de14e 100644
--- a/.typos.toml
+++ b/.typos.toml
@@ -2,5 +2,5 @@
 [default.extend-words]
 enew = "enew"
 fo = "fo"
-ba = "ba"
-afe = "afe"
+[files]
+extend-exclude = ["LICENSE"]
diff --git a/CHANGELOG.md b/CHANGELOG.md
deleted file mode 100644
index 97bdb0f..0000000
--- a/CHANGELOG.md
+++ /dev/null
@@ -1,356 +0,0 @@
-# Changelog
-
-## [4.4.4](https://github.com/AstroNvim/AstroNvim/compare/v4.4.3...v4.4.4) (2024-05-02)
-
-
-### Bug Fixes
-
-* **comment:** make `&lt;Leader&gt;/` dot-repeatable ([e2edcc7](https://github.com/AstroNvim/AstroNvim/commit/e2edcc7e197d577912d29305f67d7c995ae47353)), closes [#2410](https://github.com/AstroNvim/AstroNvim/issues/2410)
-* make `git` optional in the path for execution ([b10119d](https://github.com/AstroNvim/AstroNvim/commit/b10119d295e369fabf46d2648b0ab969cbc5c0bc))
-
-## [4.4.3](https://github.com/AstroNvim/AstroNvim/compare/v4.4.2...v4.4.3) (2024-05-01)
-
-
-### Bug Fixes
-
-* **health:** check for ripgrep (`rg`) executable ([2f43843](https://github.com/AstroNvim/AstroNvim/commit/2f438432d6de5e9bdb9c806af24964393640059e))
-* **telescope:** only map Telescope's `live_grep` picker if `rg` is available ([25a7ebf](https://github.com/AstroNvim/AstroNvim/commit/25a7ebf5383becedfdd4dfe4f94f70367a20e68f))
-
-## [4.4.2](https://github.com/AstroNvim/AstroNvim/compare/v4.4.1...v4.4.2) (2024-05-01)
-
-
-### Bug Fixes
-
-* **treesitter:** guarantee mason loads before treesitter ([cfd992f](https://github.com/AstroNvim/AstroNvim/commit/cfd992f5661016e658475e946dec12f56870f125))
-
-## [4.4.1](https://github.com/AstroNvim/AstroNvim/compare/v4.4.0...v4.4.1) (2024-04-30)
-
-
-### Bug Fixes
-
-* **cmp:** update `vim.snippet` to use updated `active` API ([#2560](https://github.com/AstroNvim/AstroNvim/issues/2560)) ([b505f4f](https://github.com/AstroNvim/AstroNvim/commit/b505f4ff41f851fa4a008586995f79408daf72bc))
-* **smart-splits:** disable aggressive lazy loading for multiplexer setup ([242f728](https://github.com/AstroNvim/AstroNvim/commit/242f728ab5431d9b7142e4efe0894b5960fb6569))
-* **vim-illuminate:** add missing `large_file_cutoff` default ([782fcb0](https://github.com/AstroNvim/AstroNvim/commit/782fcb069ba7879e1ad2b43db2351dad3f9a7ea0))
-
-## [4.4.0](https://github.com/AstroNvim/AstroNvim/compare/v4.3.0...v4.4.0) (2024-04-29)
-
-
-### Features
-
-* **mappings:** backport new default neovim diagnostic and LSP mappings ([91191e6](https://github.com/AstroNvim/AstroNvim/commit/91191e60e26d0a5f9b1fbe46cd18ce6c4873c476))
-
-
-### Bug Fixes
-
-* clear up language in update notification for AstroNvim ([8ca570a](https://github.com/AstroNvim/AstroNvim/commit/8ca570aa99e47f50274c1d804900efb54f19be1c))
-* **mappings:** fix incorrectly normalized mappings ([cc66460](https://github.com/AstroNvim/AstroNvim/commit/cc66460b62dfd2929622f3b39a03d1d489f6585f))
-
-## [4.3.0](https://github.com/AstroNvim/AstroNvim/compare/v4.2.1...v4.3.0) (2024-04-26)
-
-
-### Features
-
-* **alpha:** show the actual leader key on the dashboard ([3dabdd0](https://github.com/AstroNvim/AstroNvim/commit/3dabdd06a92f3f7af61e34bd2477005ceafc7598))
-
-
-### Bug Fixes
-
-* **autocmds:** typo in terminal_settings description ([#2552](https://github.com/AstroNvim/AstroNvim/issues/2552)) ([4b4abca](https://github.com/AstroNvim/AstroNvim/commit/4b4abca875443a3d305d1fcfa854bc3f45bc59c1))
-
-## [4.2.1](https://github.com/AstroNvim/AstroNvim/compare/v4.2.0...v4.2.1) (2024-04-23)
-
-
-### Bug Fixes
-
-* **nvim-dap-ui:** temporarily pin `nvim-dap-ui` to commit until next release ([a6fb183](https://github.com/AstroNvim/AstroNvim/commit/a6fb183eeaf08000f2961bc05009592ff986975c))
-
-## [4.2.0](https://github.com/AstroNvim/AstroNvim/compare/v4.1.12...v4.2.0) (2024-04-18)
-
-
-### Features
-
-* add notification to recommend running `:Lazy update` again after AstroNvim updates ([3c81105](https://github.com/AstroNvim/AstroNvim/commit/3c811058edc4094a276e637e1763ca14a6135acc))
-
-## [4.1.12](https://github.com/AstroNvim/AstroNvim/compare/v4.1.11...v4.1.12) (2024-04-18)
-
-
-### Bug Fixes
-
-* **autocmds:** add missing `HighlightURL` default highlight group ([93b10eb](https://github.com/AstroNvim/AstroNvim/commit/93b10ebb1bbf878369625139031f5581c7d3e587))
-
-
-### Performance Improvements
-
-* optimize url highlighting auto command and disable for large buffers ([848ac6b](https://github.com/AstroNvim/AstroNvim/commit/848ac6b798196893239c680a9d0b6b50c21345f6))
-
-## [4.1.11](https://github.com/AstroNvim/AstroNvim/compare/v4.1.10...v4.1.11) (2024-04-16)
-
-
-### Performance Improvements
-
-* **astrolsp:** improve lazy loading of AstroLSP ([35b8928](https://github.com/AstroNvim/AstroNvim/commit/35b892836116dd489bf41de4b965052364dabfdb))
-
-## [4.1.10](https://github.com/AstroNvim/AstroNvim/compare/v4.1.9...v4.1.10) (2024-04-11)
-
-
-### Bug Fixes
-
-* **comment:** add missing `Comment.nvim` mappings for lazy loading ([9d5b0eb](https://github.com/AstroNvim/AstroNvim/commit/9d5b0eb59548e8a5667d3e04d0ca1d9bb487fac9))
-
-## [4.1.9](https://github.com/AstroNvim/AstroNvim/compare/v4.1.8...v4.1.9) (2024-04-10)
-
-
-### Bug Fixes
-
-* **autocmds:** check if buffer is valid before checking for file ([40f7c42](https://github.com/AstroNvim/AstroNvim/commit/40f7c42b9589cd3fe45168b3875200c3e2e93ed8))
-
-## [4.1.8](https://github.com/AstroNvim/AstroNvim/compare/v4.1.7...v4.1.8) (2024-04-06)
-
-
-### Bug Fixes
-
-* **mappings:** clear up language of `&lt;Leader&gt;q` and `<Leader>Q` mappings ([e09e62e](https://github.com/AstroNvim/AstroNvim/commit/e09e62e5338e2b2b074c5a041b18a773c0eb55e3))
-* **snapshot:** require AstroCore v1.1.1 for important bug fix ([4e0f63c](https://github.com/AstroNvim/AstroNvim/commit/4e0f63ce6efb6f1c1175afd8f77faf861b6f3317))
-
-## [4.1.7](https://github.com/AstroNvim/AstroNvim/compare/v4.1.6...v4.1.7) (2024-04-05)
-
-
-### Bug Fixes
-
-* make sure `FileType` event is fired at the correct time after `AstroFile` ([eceb0a8](https://github.com/AstroNvim/AstroNvim/commit/eceb0a803bbaf146b0a7a33885b4d7cf410a345d))
-
-## [4.1.6](https://github.com/AstroNvim/AstroNvim/compare/v4.1.5...v4.1.6) (2024-04-04)
-
-
-### Bug Fixes
-
-* **autocmds:** when triggering `AstroFile` events, only forward events for valid buffers ([3bf88e0](https://github.com/AstroNvim/AstroNvim/commit/3bf88e035e302a15504e1074018cb11e51fc1076))
-
-## [4.1.5](https://github.com/AstroNvim/AstroNvim/compare/v4.1.4...v4.1.5) (2024-04-03)
-
-
-### Bug Fixes
-
-* **telescope:** load treesitter with telescope ([7462fb1](https://github.com/AstroNvim/AstroNvim/commit/7462fb100799ac8c9ec1968df2d97baf766d6853))
-
-## [4.1.4](https://github.com/AstroNvim/AstroNvim/compare/v4.1.3...v4.1.4) (2024-04-03)
-
-
-### Bug Fixes
-
-* **autocmds:** fully retrigger original autocmd event after `AstroFile` ([112e209](https://github.com/AstroNvim/AstroNvim/commit/112e209d75bb728ecff416811c52a495531675d0))
-
-## [4.1.3](https://github.com/AstroNvim/AstroNvim/compare/v4.1.2...v4.1.3) (2024-04-02)
-
-
-### Bug Fixes
-
-* **cmp:** guarantee all sources have a group index ([568da53](https://github.com/AstroNvim/AstroNvim/commit/568da5323cb17652d6eb7536a7668e83398260e9))
-* **resession:** enable AstroCore resession extension for single tab restore ([0c9f87b](https://github.com/AstroNvim/AstroNvim/commit/0c9f87bff8232d3efbebdb3d8725ac65887dc28a))
-
-## [4.1.2](https://github.com/AstroNvim/AstroNvim/compare/v4.1.1...v4.1.2) (2024-04-02)
-
-
-### Bug Fixes
-
-* **lspkind:** improve `cmp` and `lspkind` integration and loading order ([e1a5eca](https://github.com/AstroNvim/AstroNvim/commit/e1a5ecac5fc4dd2a157e466b5edbad49fca461aa))
-
-## [4.1.1](https://github.com/AstroNvim/AstroNvim/compare/v4.1.0...v4.1.1) (2024-04-01)
-
-
-### Bug Fixes
-
-* **plugins:** explicitly mark all dependencies as `lazy = true` ([dbd3d13](https://github.com/AstroNvim/AstroNvim/commit/dbd3d1320459913bb6cadb3c932ccc986ccb57df))
-
-## [4.1.0](https://github.com/AstroNvim/AstroNvim/compare/v4.0.0...v4.1.0) (2024-04-01)
-
-
-### Features
-
-* **dap:** enable dap on windows by default ([8d8f18d](https://github.com/AstroNvim/AstroNvim/commit/8d8f18d127b70e10a4e92fecb96a9d0eff75d49e))
-
-
-### Bug Fixes
-
-* **colorizer:** attach colorizer immediately after lazy loading ([f56a332](https://github.com/AstroNvim/AstroNvim/commit/f56a33276d8446cd562cc140ff0aa6673ae6e3b0))
-
-## [4.0.0](https://github.com/AstroNvim/AstroNvim/compare/v3.45.3...v4.0.0) (2024-04-01)
-
-
-### ⚠ BREAKING CHANGES
-
-* **mappings:** change `gT` to `gy` for type definition to avoid conflict with core mapping
-* move `signs` and `diagnostics` configuration to AstroCore
-* **mappings:** change some UI/UX mappings to make more sense
-* **options:** move vim options to AstroCore `opts`
-* **ui:** unify capital/lowercase meaning for global/buffer
-* remove `mini.indentscope` and just use `indent-blankline.nvim`
-* **treesitter:** change loop text object from `l` to `o`
-* **astrolsp:** configure signs separately from diagnostics
-* remove `schemastore` from default plugins
-* **mappings:** make `<Leader>uc` and `<Leader>uC` toggle buffer/global cmp and move colorizer toggle to `<Leader>uz`
-* **plugins:** move from `null-ls` to maintained fork `none-ls`
-* **ui:** use mini.indentscope for highlighting current context ([#2253](https://github.com/AstroNvim/AstroNvim/issues/2253))
-* **neo-tree:** remove `o` binding, conflicts with new "Order by" keymaps
-* **mason:** rename `MasonUpdate` and `MasonUpdateAll` to `AstroMasonUpdate` and `AstroMasonUpdateAll`
-* move configuration defaults to `opts` tables
-* move updater, git, and mason utilities to `astrocore`
-* move buffer to `astrocore` and icons to `astroui`
-* move resession extension to AstroCore
-* make resession the default session manager
-* move status API to AstroUI
-* move colorscheme to AstroUI and polish to AstroCore
-* move astronvim.user_terminals to AstroCore
-* remove deprecated plugin configs and unnecessary LSPLoaded icon
-* move UI/UX utils to `astrocore`
-* move astronvim specific options to AstroCore options
-* move Heirline `setup_colors` function to AstroUI
-* move plugins and lazy_snapshot into `astronvim` module
-* move to a model of just providing plugins
-* remove updater mappings and commands
-* **astrolsp:** `setup_handlers` renamed to `handlers`
-* drop support for Neovim v0.8
-* **plugins:** use `on_load` and remove some unnecessary `config` functions
-* modularize config with AstroCore, AstroUI, and AstroLSP
-
-### Features
-
-* `large_buf` can be set to `false` to disable ([73d521e](https://github.com/AstroNvim/AstroNvim/commit/73d521e112f70f1d74e161531c66ea76327af4c6))
-* add `&lt;Leader&gt;SF` to search all previous directory sessions ([ab9455a](https://github.com/AstroNvim/AstroNvim/commit/ab9455a99a664999ea83da8fe509bf01fc1da492))
-* add `AstroLargeBuf` autocmd user event and update `max_file` usage to `large_buf` ([efaf0e5](https://github.com/AstroNvim/AstroNvim/commit/efaf0e5393793f70d6c8f5bda9ef58a2ab7f51bd))
-* add `AstroUpdate` to update Lazy and Mason ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* add `init.lua` to warn user if they try to use AstroNvim as a direct Neovim configuration ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* add `vim.g.astronvim_options` as an optional function for setting up options ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* add configuration of plugin pinning ([9d1376d](https://github.com/AstroNvim/AstroNvim/commit/9d1376d5eddf44fabd0eb92153201939cfc938ed))
-* add Neovim version detection on startup ([ad934f0](https://github.com/AstroNvim/AstroNvim/commit/ad934f0c996c93c9019cae82693c82ff27534271))
-* **alpha:** use built in `button` function from Alpha ([1ad1e1e](https://github.com/AstroNvim/AstroNvim/commit/1ad1e1e0dc4b27a3c498130c0956a937245a5ef7))
-* **astrocore:** disable rooter `autochdir` by default ([be5ee14](https://github.com/AstroNvim/AstroNvim/commit/be5ee1451e289b9b97f09528a0a0f8f86ce28044))
-* **astrocore:** enable built-in project rooting by default ([9a8b7d1](https://github.com/AstroNvim/AstroNvim/commit/9a8b7d1675be66547e4ca4bdd19bd88d1d04be38))
-* **astrocore:** increase the default size for large files ([e0b826d](https://github.com/AstroNvim/AstroNvim/commit/e0b826d4e854ea2ce59e927ccfe207e65cdc40f5))
-* **astrolsp:** configure `vim.lsp.handlers` in configuration ([ab008dd](https://github.com/AstroNvim/AstroNvim/commit/ab008ddb438432982b67c9f2da74f65d580b0984))
-* **astrolsp:** don't add formatting mappings when formatting is disabled ([26147a6](https://github.com/AstroNvim/AstroNvim/commit/26147a631e6c80370181c0617a4bc41ea4de8fbe))
-* **astrolsp:** move lsp autocommands to AstroLSP `opts` ([8fe55d0](https://github.com/AstroNvim/AstroNvim/commit/8fe55d042e2d017f26e14b04f53e228b3ed45f29))
-* **astrolsp:** move lsp user commands to AstroLSP `opts` ([2c19d9e](https://github.com/AstroNvim/AstroNvim/commit/2c19d9e600b52c62a6e05cad85a63e7f85c952b7))
-* **cmp:** add buffer local cmp completion control ([815ee79](https://github.com/AstroNvim/AstroNvim/commit/815ee79ba4537e6073936d791ca7895c9d34ef12))
-* **cmp:** allow `LuaSnip` to be disabled ([7958c12](https://github.com/AstroNvim/AstroNvim/commit/7958c12def1cc7a0e3fdba8e55983d2922df5f64))
-* **cmp:** fallback to `vim.snippet` if available and no other snippet engine configured ([424f46b](https://github.com/AstroNvim/AstroNvim/commit/424f46b49ebd752997cb965e88f96f404172bde0))
-* **cmp:** set `group_index` for lsp and buffer `cmp` sources ([bfb01ee](https://github.com/AstroNvim/AstroNvim/commit/bfb01ee8017a6c38d9cd0df258b0e67cb295d457))
-* **config:** add ability to configure `mapleader` and `icons_enabled` in AstroNvim `opts` ([27adb26](https://github.com/AstroNvim/AstroNvim/commit/27adb26c3c65ce82489370f930de93237a671b48))
-* **config:** move `maplocalleader` to AstroNvim `opts` to be set up before Lazy ([668691d](https://github.com/AstroNvim/AstroNvim/commit/668691d4bfa298ff38fdf2789412b9d6e0d2a6c3))
-* **dev:** add dev utility to generate snapshot for stable releases ([5081890](https://github.com/AstroNvim/AstroNvim/commit/5081890702919d5046382c9af4d38e24e9db4c1a))
-* **gitsigns:** use new preview hunk inline ([463be1a](https://github.com/AstroNvim/AstroNvim/commit/463be1a2630cbc2dcd63532d8add755107dbb1ca))
-* **heirline:** add virtual environment component ([7761b63](https://github.com/AstroNvim/AstroNvim/commit/7761b6376394e465ab6fea30886f92d96b932869))
-* **indent-blankline:** migrate to indent blankline v3 ([c2e15ee](https://github.com/AstroNvim/AstroNvim/commit/c2e15ee549871237072c50d2fcb358aa36ab67ae))
-* **lazy:** use `$LAZY` environment directory for lazy dir if available ([1e93c9c](https://github.com/AstroNvim/AstroNvim/commit/1e93c9cd8145acbc4c9588feb60906510b98c44a))
-* make resession the default session manager ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **mappings:** make `&lt;Leader&gt;uc` and `<Leader>uC` toggle buffer/global cmp and move colorizer toggle to `<Leader>uz` ([cfa1962](https://github.com/AstroNvim/AstroNvim/commit/cfa1962709b75bca9ee521535a490eae99eefa78))
-* move to modular plugin for configuring LSP options ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move to modular plugin for configuring mappings and autocmds ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **neo-tree:** add shift+enter to system open files ([7a20dc7](https://github.com/AstroNvim/AstroNvim/commit/7a20dc79a4305a30b33744a398881e702be6b5a3))
-* **nvim-lspconfig:** add lazy loading on `nvim-lspconfig` commands ([495a17a](https://github.com/AstroNvim/AstroNvim/commit/495a17a4691dfdcfc11d3153e98c325ca0cfde1c))
-* **nvim-treesitter:** disable all treesitter modules for large buffers ([a92f05d](https://github.com/AstroNvim/AstroNvim/commit/a92f05d3a101db4406f9ef72a41b6888a17347a8))
-* **options:** enable confirm by default ([d8055ac](https://github.com/AstroNvim/AstroNvim/commit/d8055ac78087d401f6f1cbfabd080f8d2e638b33))
-* **options:** use the histogram algorithm for diff calculations ([f1cfd02](https://github.com/AstroNvim/AstroNvim/commit/f1cfd02c5164906dfcd555315daf1cbbdb54bc46))
-* **plugins:** add `todo-comments.nvim` to the base installation ([4d690ca](https://github.com/AstroNvim/AstroNvim/commit/4d690caa269b5a85aca839e154f39c82dd1a3134))
-* **plugins:** move from `null-ls` to maintained fork `none-ls` ([b4687e3](https://github.com/AstroNvim/AstroNvim/commit/b4687e3f61804bba70899401f1ada567a061fa61))
-* **plugins:** move to `vim-illuminate` to reference highlighting ([1749d5a](https://github.com/AstroNvim/AstroNvim/commit/1749d5ac3be624fb67c58c7b06f92245bafe7736))
-* **plugins:** use `on_load` and remove some unnecessary `config` functions ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* remove `mini.indentscope` and just use `indent-blankline.nvim` ([0e23d5b](https://github.com/AstroNvim/AstroNvim/commit/0e23d5b90b8f281835c67ccfe402287c99d5f0ab))
-* **resession:** add `&lt;Leader&gt;SD` for deleting a directory session ([e4c586c](https://github.com/AstroNvim/AstroNvim/commit/e4c586cba5ca73286b838c87e13deedf61ed2f39))
-* **resession:** add `&lt;Leader&gt;SS` to save current directory session ([76018e9](https://github.com/AstroNvim/AstroNvim/commit/76018e90c5cd082869e98210466b9b7737e23e1b))
-* **treesitter:** change loop text object from `l` to `o` ([2ed7eb3](https://github.com/AstroNvim/AstroNvim/commit/2ed7eb37385468a89eb00a167954cc727829cbf7))
-* **treesitter:** enable `auto_install` if user has the `tree-sitter` CLI ([ca0db4e](https://github.com/AstroNvim/AstroNvim/commit/ca0db4e8db4d812dbd75a61215078db2853bd529))
-* **ui:** use mini.indentscope for highlighting current context ([#2253](https://github.com/AstroNvim/AstroNvim/issues/2253)) ([c2e15ee](https://github.com/AstroNvim/AstroNvim/commit/c2e15ee549871237072c50d2fcb358aa36ab67ae))
-
-
-### Bug Fixes
-
-* `astrocore.utils` moved to `astrocore` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **alpha:** fix alpha on fresh installation ([16e2805](https://github.com/AstroNvim/AstroNvim/commit/16e2805175cfc6dd7b67279e07f1c5d382256d46))
-* **alpha:** patch alpha button function until resolved upstream ([fb94050](https://github.com/AstroNvim/AstroNvim/commit/fb940502cfa5ce72d331317997717b97960c933d))
-* **astrocore:** `syntax` toggle renamed to `buffer_syntax` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **astrocore:** prefer version control over project files ([41c63b9](https://github.com/AstroNvim/AstroNvim/commit/41c63b9cfe759811e19bdd80198d3bf1d1d346d6))
-* **astrolsp:** `setup_handlers` renamed to `handlers` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **astrolsp:** configure signs separately from diagnostics ([10929d5](https://github.com/AstroNvim/AstroNvim/commit/10929d5a33b0e0b664e76103ed18a95635cb4b06))
-* **astrolsp:** move `signs` to new dictionary format ([96bb76f](https://github.com/AstroNvim/AstroNvim/commit/96bb76ff351d39beeb6050dd115d8c5c830a5a93))
-* **astrolsp:** update autoformat_enabled to autoformat ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **astrolsp:** update lsp mapping conditions ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **astrolsp:** which-key integration fixed ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **astroui:** add missing gitsigns handlers ([9d593be](https://github.com/AstroNvim/AstroNvim/commit/9d593beed4196d315b06036c7bcd48f350a84461))
-* **autocmds:** always fire "AstroFile" if in a vscode session ([5fb7345](https://github.com/AstroNvim/AstroNvim/commit/5fb7345e04a958d278b4ffe6395952ce4fb3dedb))
-* **autocmds:** fix large buffer detection autocmd ([2bfce12](https://github.com/AstroNvim/AstroNvim/commit/2bfce126de622a43f2844626c39c213bc1f081ba))
-* **autocmds:** silently fail if `augroup` has already been deleted ([f77ec3f](https://github.com/AstroNvim/AstroNvim/commit/f77ec3fa17f92ac76edcfbcf762a8c212e864997))
-* **autocmds:** use quotes in git command on windows ([b5ef0d2](https://github.com/AstroNvim/AstroNvim/commit/b5ef0d25693a49c829b09429f131361fc584d69a))
-* **cmp:** use `completeopt` from `vim.opt` rather than hard coding in `nvim-cmp` ([a2b3571](https://github.com/AstroNvim/AstroNvim/commit/a2b35718fbf42ebed371694fd86353c213e480a5))
-* disable cmp for large buffers ([8b81aa5](https://github.com/AstroNvim/AstroNvim/commit/8b81aa5b633ca01f9c89eab04f07a50e7f87f9be))
-* disable completion and indent guides for large buffers ([8b81aa5](https://github.com/AstroNvim/AstroNvim/commit/8b81aa5b633ca01f9c89eab04f07a50e7f87f9be))
-* fix initial startup ordering ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **heirline:** only apply sidebar padding for non full-width windows ([548a4c1](https://github.com/AstroNvim/AstroNvim/commit/548a4c1d288a1ccf5d226841c93b5d5868eab7c4))
-* **heirline:** update to new `file_info` component defaults ([cf3974f](https://github.com/AstroNvim/AstroNvim/commit/cf3974fe229188b49f3386591803eeeac5a3e4a7))
-* improve first installation path ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **indent-blankline:** improve lazy loading ([d9592cd](https://github.com/AstroNvim/AstroNvim/commit/d9592cddc9451836ebb659ff1bc527c296cf904b))
-* **init:** improve initialization sequence ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **lspconfig:** resolve lsp attaching when new filetype buffer is not focused ([4f568eb](https://github.com/AstroNvim/AstroNvim/commit/4f568eb63387b3ea5810cca076a296eab0c46414))
-* **mappings:** change `gT` to `gy` for type definition to avoid conflict with core mapping ([fe0e3d7](https://github.com/AstroNvim/AstroNvim/commit/fe0e3d708ffad29c06a3ce34e6986a0d5ac5ec52))
-* **mappings:** change some UI/UX mappings to make more sense ([77ba866](https://github.com/AstroNvim/AstroNvim/commit/77ba866cb88ba26539d9aa115d8ca53f3205a2e0))
-* **mappings:** fix incorrect mapping key casing ([a5cf6a0](https://github.com/AstroNvim/AstroNvim/commit/a5cf6a0a0603b65c8fbfcdcd0b568aee6247e760))
-* **mappings:** move diagnostic mappings to always loaded ([e575551](https://github.com/AstroNvim/AstroNvim/commit/e575551e033961cfe2e4fac3d316cb2bcaba3fe5))
-* **mason:** rename `MasonUpdate` and `MasonUpdateAll` to `AstroMasonUpdate` and `AstroMasonUpdateAll` ([9be64b9](https://github.com/AstroNvim/AstroNvim/commit/9be64b9d0f8fbd9d57209711a03460b8606abbd4))
-* **neo-tree:** add missing fold icons from AstroUI ([bea5d52](https://github.com/AstroNvim/AstroNvim/commit/bea5d528e8ed72f68bfacf5ca1eea9399e315ea2))
-* **neo-tree:** disable `foldcolumn` in neo-tree ([61e05d4](https://github.com/AstroNvim/AstroNvim/commit/61e05d4b38cdc0d6826ee01fb954e3740a2483bf))
-* **neo-tree:** fix autocmds ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **neo-tree:** improve `h` and `l` navigation edge cases for empty directories and nested files ([f7f3204](https://github.com/AstroNvim/AstroNvim/commit/f7f3204f2d88a26c096a18119f24ebf8f413210f))
-* **neo-tree:** remove `o` binding, conflicts with new "Order by" keymaps ([ba92f46](https://github.com/AstroNvim/AstroNvim/commit/ba92f464b1e6738e136fed6650935e3379963899))
-* **notify:** add icon disable support to `nvim-notify` ([fcb833c](https://github.com/AstroNvim/AstroNvim/commit/fcb833c92d3b8ec263f2413ad2af1f147a7480a1))
-* **notify:** return after closing window ([d68514c](https://github.com/AstroNvim/AstroNvim/commit/d68514c718017350bf603029e3623904a120d7e7))
-* **nvim-treesitter:** force install parsers bundled with neovim ([3bd128e](https://github.com/AstroNvim/AstroNvim/commit/3bd128e17a23a7f1df13964aa8a4e8c2d9582aef))
-* **options:** add error reporting to malformed user options ([d9eb52d](https://github.com/AstroNvim/AstroNvim/commit/d9eb52d6b6d5dd9f1e5c3fb19028c9882b455d3e))
-* **options:** don't concatenate boolean in error message ([90f3c3b](https://github.com/AstroNvim/AstroNvim/commit/90f3c3bb82505ee1a512d531d2cc7216e13fc476))
-* **options:** initialize buffer list on startup ([8ea4190](https://github.com/AstroNvim/AstroNvim/commit/8ea4190a67ee04c60868920c2fae1b0317a846ad))
-* **plugins:** don't use the shorthand notation for plugins ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **plugins:** make sure `mason` is set up before mason plugins ([4afe41a](https://github.com/AstroNvim/AstroNvim/commit/4afe41a5b94f05802d6a81a7c6508eae3e71ec1a))
-* **status:** allow for function in colors definition ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **status:** use user provided `status.colors` table for overriding ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **ui:** unify capital/lowercase meaning for global/buffer ([cf50450](https://github.com/AstroNvim/AstroNvim/commit/cf50450f87bd8897604511369dde729364ed42d1))
-* **which-key:** remove separator icon when icons are disabled ([281606e](https://github.com/AstroNvim/AstroNvim/commit/281606e4c7696f3cc2d3eacf2cc5c342cdcbe2a4))
-* **which-key:** use a more minimal which-key separator ([a5be725](https://github.com/AstroNvim/AstroNvim/commit/a5be725018ddca1c471f050b5117708efba1684f))
-
-
-### Performance Improvements
-
-* **autocmds:** improve performance of `AstroFile` detection ([09144c5](https://github.com/AstroNvim/AstroNvim/commit/09144c543ec785e19b3a26cdaf4030c78c02d751))
-* **heirline:** simplify buffer matcher for disabling winbar ([91fd4d5](https://github.com/AstroNvim/AstroNvim/commit/91fd4d518971834b40209f6d254a0a176ce2d34c))
-* **heirline:** use logic to calculate offset rather than hardcoded list ([72e1780](https://github.com/AstroNvim/AstroNvim/commit/72e17808ad7d6a9d18c9d5f80390222050d71e1d))
-* improve initial installation and startup performance ([432897f](https://github.com/AstroNvim/AstroNvim/commit/432897fd8b1088dc44753ebda8cd53058d942e94))
-* improve performance of triggered plugin loading ([bae0ad7](https://github.com/AstroNvim/AstroNvim/commit/bae0ad70021e47991cc4514dee99897d7654c3e6))
-* **mappings:** remove unnecessary check ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **options:** set options directly ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **plugins:** lazy now ignores plugin fragments if a plugin is disabled ([811a0b1](https://github.com/AstroNvim/AstroNvim/commit/811a0b1ad4e45a900185b9990ad86d6f045d68ac))
-* **toggleterm:** optimize toggleterm `on_create` function ([c6a9f03](https://github.com/AstroNvim/AstroNvim/commit/c6a9f03a11c511ce36180ff045c13252f6d6b492))
-
-
-### Miscellaneous Chores
-
-* remove deprecated plugin configs and unnecessary LSPLoaded icon ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-
-
-### Code Refactoring
-
-* drop support for Neovim v0.8 ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* modularize config with AstroCore, AstroUI, and AstroLSP ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move `signs` and `diagnostics` configuration to AstroCore ([7898fcd](https://github.com/AstroNvim/AstroNvim/commit/7898fcd681ac19ecaadb3a1e85b120220fde986f))
-* move astronvim specific options to AstroCore options ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move astronvim.user_terminals to AstroCore ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move buffer to `astrocore` and icons to `astroui` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move colorscheme to AstroUI and polish to AstroCore ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move configuration defaults to `opts` tables ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move Heirline `setup_colors` function to AstroUI ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move plugins and lazy_snapshot into `astronvim` module ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move resession extension to AstroCore ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move status API to AstroUI ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move to a model of just providing plugins ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move UI/UX utils to `astrocore` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* move updater, git, and mason utilities to `astrocore` ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
-* **options:** move vim options to AstroCore `opts` ([170774b](https://github.com/AstroNvim/AstroNvim/commit/170774b87545e6a8fdffbec9a37a56403b1c1f5c))
-* remove `schemastore` from default plugins ([aeb24b0](https://github.com/AstroNvim/AstroNvim/commit/aeb24b0154c0a8907191acd0546bec904ad215c3))
-* remove updater mappings and commands ([0e0d8bd](https://github.com/AstroNvim/AstroNvim/commit/0e0d8bdef5e0a147f1f1a0c434539016d39940b5))
diff --git a/config.ld b/config.ld
new file mode 100644
index 0000000..61784df
--- /dev/null
+++ b/config.ld
@@ -0,0 +1,7 @@
+project='AstroNvim'
+title='AstroNvim API'
+description='Documentation of AstroNvim\'s core API'
+format = 'markdown'
+file='lua'
+dir='docs'
+no_space_before_args=true
diff --git a/init.lua b/init.lua
index 7523110..5570e85 100644
--- a/init.lua
+++ b/init.lua
@@ -1,8 +1,23 @@
-vim.api.nvim_echo({
-  { "This repository is not meant to be used as a direct Neovim configuration\n", "ErrorMsg" },
-  { "Please check the AstroNvim documentation for installation details\n", "WarningMsg" },
-  { "Press any key to exit...", "MoreMsg" },
-}, true, {})
+if vim.loader and vim.fn.has "nvim-0.9.1" == 1 then vim.loader.enable() end
 
-vim.fn.getchar()
-vim.cmd.quit()
+for _, source in ipairs {
+  "astronvim.bootstrap",
+  "astronvim.options",
+  "astronvim.lazy",
+  "astronvim.autocmds",
+  "astronvim.mappings",
+} do
+  local status_ok, fault = pcall(require, source)
+  if not status_ok then vim.api.nvim_err_writeln("Failed to load " .. source .. "\n\n" .. fault) end
+end
+
+if astronvim.default_colorscheme then
+  if not pcall(vim.cmd.colorscheme, astronvim.default_colorscheme) then
+    require("astronvim.utils").notify(
+      ("Error setting up colorscheme: `%s`"):format(astronvim.default_colorscheme),
+      vim.log.levels.ERROR
+    )
+  end
+end
+
+require("astronvim.utils").conditional_func(astronvim.user_opts("polish", nil, false), true)
diff --git a/lua/astronvim/autocmds.lua b/lua/astronvim/autocmds.lua
new file mode 100644
index 0000000..0e5fb0d
--- /dev/null
+++ b/lua/astronvim/autocmds.lua
@@ -0,0 +1,375 @@
+local augroup = vim.api.nvim_create_augroup
+local autocmd = vim.api.nvim_create_autocmd
+local cmd = vim.api.nvim_create_user_command
+local namespace = vim.api.nvim_create_namespace
+
+local utils = require "astronvim.utils"
+local is_available = utils.is_available
+local astroevent = utils.event
+
+vim.on_key(function(char)
+  if vim.fn.mode() == "n" then
+    local new_hlsearch = vim.tbl_contains({ "<CR>", "n", "N", "*", "#", "?", "/" }, vim.fn.keytrans(char))
+    if vim.opt.hlsearch:get() ~= new_hlsearch then vim.opt.hlsearch = new_hlsearch end
+  end
+end, namespace "auto_hlsearch")
+
+autocmd("BufReadPre", {
+  desc = "Disable certain functionality on very large files",
+  group = augroup("large_buf", { clear = true }),
+  callback = function(args)
+    local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(args.buf))
+    vim.b[args.buf].large_buf = (ok and stats and stats.size > vim.g.max_file.size)
+      or vim.api.nvim_buf_line_count(args.buf) > vim.g.max_file.lines
+  end,
+})
+
+autocmd({ "FocusGained", "TermClose", "TermLeave" }, {
+  desc = "Check if buffers changed on editor focus",
+  group = augroup("checktime", { clear = true }),
+  command = "checktime",
+})
+
+autocmd("BufWritePre", {
+  desc = "Automatically create parent directories if they don't exist when saving a file",
+  group = augroup("create_dir", { clear = true }),
+  callback = function(args)
+    if not require("astronvim.utils.buffer").is_valid(args.buf) then return end
+    vim.fn.mkdir(vim.fn.fnamemodify(vim.loop.fs_realpath(args.match) or args.match, ":p:h"), "p")
+  end,
+})
+
+local terminal_settings_group = augroup("terminal_settings", { clear = true })
+-- TODO: drop when dropping support for Neovim v0.9
+if vim.fn.has "nvim-0.9" == 1 and vim.fn.has "nvim-0.9.4" == 0 then
+  -- HACK: Disable custom statuscolumn for terminals because truncation/wrapping bug
+  -- https://github.com/neovim/neovim/issues/25472
+  autocmd("TermOpen", {
+    group = terminal_settings_group,
+    desc = "Disable custom statuscolumn for terminals to fix neovim/neovim#25472",
+    callback = function() vim.opt_local.statuscolumn = nil end,
+  })
+end
+autocmd("TermOpen", {
+  group = terminal_settings_group,
+  desc = "Disable foldcolumn and signcolumn for terinals",
+  callback = function()
+    vim.opt_local.foldcolumn = "0"
+    vim.opt_local.signcolumn = "no"
+  end,
+})
+
+local bufferline_group = augroup("bufferline", { clear = true })
+autocmd({ "BufAdd", "BufEnter", "TabNewEntered" }, {
+  desc = "Update buffers when adding new buffers",
+  group = bufferline_group,
+  callback = function(args)
+    local buf_utils = require "astronvim.utils.buffer"
+    if not vim.t.bufs then vim.t.bufs = {} end
+    if not buf_utils.is_valid(args.buf) then return end
+    if args.buf ~= buf_utils.current_buf then
+      buf_utils.last_buf = buf_utils.is_valid(buf_utils.current_buf) and buf_utils.current_buf or nil
+      buf_utils.current_buf = args.buf
+    end
+    local bufs = vim.t.bufs
+    if not vim.tbl_contains(bufs, args.buf) then
+      table.insert(bufs, args.buf)
+      vim.t.bufs = bufs
+    end
+    vim.t.bufs = vim.tbl_filter(buf_utils.is_valid, vim.t.bufs)
+    astroevent "BufsUpdated"
+  end,
+})
+autocmd({ "BufDelete", "TermClose" }, {
+  desc = "Update buffers when deleting buffers",
+  group = bufferline_group,
+  callback = function(args)
+    local removed
+    for _, tab in ipairs(vim.api.nvim_list_tabpages()) do
+      local bufs = vim.t[tab].bufs
+      if bufs then
+        for i, bufnr in ipairs(bufs) do
+          if bufnr == args.buf then
+            removed = true
+            table.remove(bufs, i)
+            vim.t[tab].bufs = bufs
+            break
+          end
+        end
+      end
+    end
+    vim.t.bufs = vim.tbl_filter(require("astronvim.utils.buffer").is_valid, vim.t.bufs)
+    if removed then astroevent "BufsUpdated" end
+    vim.cmd.redrawtabline()
+  end,
+})
+
+autocmd({ "VimEnter", "FileType", "BufEnter", "WinEnter" }, {
+  desc = "URL Highlighting",
+  group = augroup("highlighturl", { clear = true }),
+  callback = function() utils.set_url_match() end,
+})
+
+local view_group = augroup("auto_view", { clear = true })
+autocmd({ "BufWinLeave", "BufWritePost", "WinLeave" }, {
+  desc = "Save view with mkview for real files",
+  group = view_group,
+  callback = function(args)
+    if vim.b[args.buf].view_activated then vim.cmd.mkview { mods = { emsg_silent = true } } end
+  end,
+})
+autocmd("BufWinEnter", {
+  desc = "Try to load file view if available and enable view saving for real files",
+  group = view_group,
+  callback = function(args)
+    if not vim.b[args.buf].view_activated then
+      local filetype = vim.api.nvim_get_option_value("filetype", { buf = args.buf })
+      local buftype = vim.api.nvim_get_option_value("buftype", { buf = args.buf })
+      local ignore_filetypes = { "gitcommit", "gitrebase", "svg", "hgcommit" }
+      if buftype == "" and filetype and filetype ~= "" and not vim.tbl_contains(ignore_filetypes, filetype) then
+        vim.b[args.buf].view_activated = true
+        vim.cmd.loadview { mods = { emsg_silent = true } }
+      end
+    end
+  end,
+})
+
+autocmd("BufWinEnter", {
+  desc = "Make q close help, man, quickfix, dap floats",
+  group = augroup("q_close_windows", { clear = true }),
+  callback = function(args)
+    local buftype = vim.api.nvim_get_option_value("buftype", { buf = args.buf })
+    if vim.tbl_contains({ "help", "nofile", "quickfix" }, buftype) and vim.fn.maparg("q", "n") == "" then
+      vim.keymap.set("n", "q", "<cmd>close<cr>", {
+        desc = "Close window",
+        buffer = args.buf,
+        silent = true,
+        nowait = true,
+      })
+    end
+  end,
+})
+
+autocmd("TextYankPost", {
+  desc = "Highlight yanked text",
+  group = augroup("highlightyank", { clear = true }),
+  pattern = "*",
+  callback = function() vim.highlight.on_yank() end,
+})
+
+autocmd("FileType", {
+  desc = "Unlist quickfist buffers",
+  group = augroup("unlist_quickfist", { clear = true }),
+  pattern = "qf",
+  callback = function() vim.opt_local.buflisted = false end,
+})
+
+autocmd("BufEnter", {
+  desc = "Quit AstroNvim if more than one window is open and only sidebar windows are list",
+  group = augroup("auto_quit", { clear = true }),
+  callback = function()
+    local wins = vim.api.nvim_tabpage_list_wins(0)
+    -- Both neo-tree and aerial will auto-quit if there is only a single window left
+    if #wins <= 1 then return end
+    local sidebar_fts = { aerial = true, ["neo-tree"] = true }
+    for _, winid in ipairs(wins) do
+      if vim.api.nvim_win_is_valid(winid) then
+        local bufnr = vim.api.nvim_win_get_buf(winid)
+        local filetype = vim.api.nvim_get_option_value("filetype", { buf = bufnr })
+        -- If any visible windows are not sidebars, early return
+        if not sidebar_fts[filetype] then
+          return
+        -- If the visible window is a sidebar
+        else
+          -- only count filetypes once, so remove a found sidebar from the detection
+          sidebar_fts[filetype] = nil
+        end
+      end
+    end
+    if #vim.api.nvim_list_tabpages() > 1 then
+      vim.cmd.tabclose()
+    else
+      vim.cmd.qall()
+    end
+  end,
+})
+
+if is_available "alpha-nvim" then
+  autocmd({ "User", "BufWinEnter" }, {
+    desc = "Disable status, tablines, and cmdheight for alpha",
+    group = augroup("alpha_settings", { clear = true }),
+    callback = function(args)
+      if
+        (
+          (args.event == "User" and args.file == "AlphaReady")
+          or (args.event == "BufWinEnter" and vim.api.nvim_get_option_value("filetype", { buf = args.buf }) == "alpha")
+        ) and not vim.g.before_alpha
+      then
+        vim.g.before_alpha = {
+          showtabline = vim.opt.showtabline:get(),
+          laststatus = vim.opt.laststatus:get(),
+          cmdheight = vim.opt.cmdheight:get(),
+        }
+        vim.opt.showtabline, vim.opt.laststatus, vim.opt.cmdheight = 0, 0, 0
+      elseif
+        vim.g.before_alpha
+        and args.event == "BufWinEnter"
+        and vim.api.nvim_get_option_value("buftype", { buf = args.buf }) ~= "nofile"
+      then
+        vim.opt.laststatus, vim.opt.showtabline, vim.opt.cmdheight =
+          vim.g.before_alpha.laststatus, vim.g.before_alpha.showtabline, vim.g.before_alpha.cmdheight
+        vim.g.before_alpha = nil
+      end
+    end,
+  })
+  autocmd("VimEnter", {
+    desc = "Start Alpha when vim is opened with no arguments",
+    group = augroup("alpha_autostart", { clear = true }),
+    callback = function()
+      local should_skip
+      local lines = vim.api.nvim_buf_get_lines(0, 0, 2, false)
+      if
+        vim.fn.argc() > 0 -- don't start when opening a file
+        or #lines > 1 -- don't open if current buffer has more than 1 line
+        or (#lines == 1 and lines[1]:len() > 0) -- don't open the current buffer if it has anything on the first line
+        or #vim.tbl_filter(function(bufnr) return vim.bo[bufnr].buflisted end, vim.api.nvim_list_bufs()) > 1 -- don't open if any listed buffers
+        or not vim.o.modifiable -- don't open if not modifiable
+      then
+        should_skip = true
+      else
+        for _, arg in pairs(vim.v.argv) do
+          if arg == "-b" or arg == "-c" or vim.startswith(arg, "+") or arg == "-S" then
+            should_skip = true
+            break
+          end
+        end
+      end
+      if should_skip then return end
+      require("alpha").start(true)
+      vim.schedule(function() vim.cmd.doautocmd "FileType" end)
+    end,
+  })
+end
+
+-- HACK: indent blankline doesn't properly refresh when scrolling the window
+-- remove when fixed upstream: https://github.com/lukas-reineke/indent-blankline.nvim/issues/489
+if is_available "indent-blankline.nvim" then
+  autocmd("WinScrolled", {
+    desc = "Refresh indent blankline on window scroll",
+    group = augroup("indent_blankline_refresh_scroll", { clear = true }),
+    callback = function()
+      -- TODO: remove neovim version check when dropping support for Neovim 0.8
+      if vim.fn.has "nvim-0.9" ~= 1 or (vim.v.event.all and vim.v.event.all.leftcol ~= 0) then
+        pcall(vim.cmd.IndentBlanklineRefresh)
+      end
+    end,
+  })
+end
+
+if is_available "resession.nvim" then
+  autocmd("VimLeavePre", {
+    desc = "Save session on close",
+    group = augroup("resession_auto_save", { clear = true }),
+    callback = function()
+      local buf_utils = require "astronvim.utils.buffer"
+      local autosave = buf_utils.sessions.autosave
+      if autosave and buf_utils.is_valid_session() then
+        local save = require("resession").save
+        if autosave.last then save("Last Session", { notify = false }) end
+        if autosave.cwd then save(vim.fn.getcwd(), { dir = "dirsession", notify = false }) end
+      end
+    end,
+  })
+end
+
+if is_available "neo-tree.nvim" then
+  autocmd("BufEnter", {
+    desc = "Open Neo-Tree on startup with directory",
+    group = augroup("neotree_start", { clear = true }),
+    callback = function()
+      if package.loaded["neo-tree"] then
+        vim.api.nvim_del_augroup_by_name "neotree_start"
+      else
+        local stats = (vim.uv or vim.loop).fs_stat(vim.api.nvim_buf_get_name(0)) -- TODO: REMOVE vim.loop WHEN DROPPING SUPPORT FOR Neovim v0.9
+        if stats and stats.type == "directory" then
+          vim.api.nvim_del_augroup_by_name "neotree_start"
+          require "neo-tree"
+        end
+      end
+    end,
+  })
+  autocmd("TermClose", {
+    pattern = "*lazygit*",
+    desc = "Refresh Neo-Tree when closing lazygit",
+    group = augroup("neotree_refresh", { clear = true }),
+    callback = function()
+      local manager_avail, manager = pcall(require, "neo-tree.sources.manager")
+      if manager_avail then
+        for _, source in ipairs { "filesystem", "git_status", "document_symbols" } do
+          local module = "neo-tree.sources." .. source
+          if package.loaded[module] then manager.refresh(require(module).name) end
+        end
+      end
+    end,
+  })
+end
+
+autocmd("ColorScheme", {
+  desc = "Load custom highlights from user configuration",
+  group = augroup("astronvim_highlights", { clear = true }),
+  callback = function()
+    if vim.g.colors_name then
+      for _, module in ipairs { "init", vim.g.colors_name } do
+        for group, spec in pairs(astronvim.user_opts("highlights." .. module)) do
+          vim.api.nvim_set_hl(0, group, spec)
+        end
+      end
+    end
+    astroevent("ColorScheme", false)
+  end,
+})
+
+autocmd("FileType", {
+  desc = "configure editorconfig after filetype detection to override `ftplugin`s",
+  group = augroup("editorconfig_filetype", { clear = true }),
+  callback = function(args)
+    if vim.F.if_nil(vim.b.editorconfig, vim.g.editorconfig, true) then
+      local editorconfig_avail, editorconfig = pcall(require, "editorconfig")
+      if editorconfig_avail then editorconfig.config(args.buf) end
+    end
+  end,
+})
+
+autocmd({ "BufReadPost", "BufNewFile", "BufWritePost" }, {
+  desc = "AstroNvim user events for file detection (AstroFile and AstroGitFile)",
+  group = augroup("file_user_events", { clear = true }),
+  callback = function(args)
+    local current_file = vim.fn.resolve(vim.fn.expand "%")
+    if not (current_file == "" or vim.api.nvim_get_option_value("buftype", { buf = args.buf }) == "nofile") then
+      astroevent "File"
+      if
+        require("astronvim.utils.git").file_worktree()
+        or utils.cmd({ "git", "-C", vim.fn.fnamemodify(current_file, ":p:h"), "rev-parse" }, false)
+      then
+        astroevent "GitFile"
+        vim.api.nvim_del_augroup_by_name "file_user_events"
+      end
+      vim.schedule(function() vim.api.nvim_exec_autocmds("CursorMoved", { modeline = false }) end)
+    end
+  end,
+})
+
+cmd(
+  "AstroChangelog",
+  function() require("astronvim.utils.updater").changelog() end,
+  { desc = "Check AstroNvim Changelog" }
+)
+cmd(
+  "AstroUpdatePackages",
+  function() require("astronvim.utils.updater").update_packages() end,
+  { desc = "Update Plugins and Mason" }
+)
+cmd("AstroRollback", function() require("astronvim.utils.updater").rollback() end, { desc = "Rollback AstroNvim" })
+cmd("AstroUpdate", function() require("astronvim.utils.updater").update() end, { desc = "Update AstroNvim" })
+cmd("AstroVersion", function() require("astronvim.utils.updater").version() end, { desc = "Check AstroNvim Version" })
+cmd("AstroReload", function() require("astronvim.utils").reload() end, { desc = "Reload AstroNvim (Experimental)" })
diff --git a/lua/astronvim/bootstrap.lua b/lua/astronvim/bootstrap.lua
new file mode 100644
index 0000000..7ddcb91
--- /dev/null
+++ b/lua/astronvim/bootstrap.lua
@@ -0,0 +1,132 @@
+--- ### AstroNvim Core Bootstrap
+--
+-- This module simply sets up the global `astronvim` module.
+-- This is automatically loaded and should not be resourced, everything is accessible through the global `astronvim` variable.
+--
+-- @module astronvim.bootstrap
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+_G.astronvim = {}
+
+--- installation details from external installers
+astronvim.install = _G["astronvim_installation"] or { home = vim.fn.stdpath "config" }
+astronvim.supported_configs = { astronvim.install.home }
+--- external astronvim configuration folder
+astronvim.install.config = vim.fn.stdpath("config"):gsub("[^/\\]+$", "astronvim")
+-- check if they are the same, protects against NVIM_APPNAME use for isolated install
+if astronvim.install.home ~= astronvim.install.config then
+  vim.opt.rtp:append(astronvim.install.config)
+  --- supported astronvim user config folders
+  table.insert(astronvim.supported_configs, astronvim.install.config)
+end
+
+--- Looks to see if a module path references a lua file in a configuration folder and tries to load it. If there is an error loading the file, write an error and continue
+---@param module string The module path to try and load
+---@return table|nil # The loaded module if successful or nil
+local function load_module_file(module)
+  -- placeholder for final return value
+  local found_file = nil
+  -- search through each of the supported configuration locations
+  for _, config_path in ipairs(astronvim.supported_configs) do
+    -- convert the module path to a file path (example user.init -> user/init.lua)
+    local module_path = config_path .. "/lua/" .. module:gsub("%.", "/") .. ".lua"
+    -- check if there is a readable file, if so, set it as found
+    if vim.fn.filereadable(module_path) == 1 then found_file = module_path end
+  end
+  -- if we found a readable lua file, try to load it
+  local out = nil
+  if found_file then
+    -- try to load the file
+    local status_ok, loaded_module = pcall(require, module)
+    -- if successful at loading, set the return variable
+    if status_ok then
+      out = loaded_module
+    -- if unsuccessful, throw an error
+    else
+      vim.api.nvim_err_writeln("Error loading file: " .. found_file .. "\n\n" .. loaded_module)
+    end
+  end
+  -- return the loaded module or nil if no file found
+  return out
+end
+
+--- Main configuration engine logic for extending a default configuration table with either a function override or a table to merge into the default option
+-- @param overrides the override definition, either a table or a function that takes a single parameter of the original table
+-- @param default the default configuration table
+-- @param extend boolean value to either extend the default or simply overwrite it if an override is provided
+-- @return the new configuration table
+local function func_or_extend(overrides, default, extend)
+  -- if we want to extend the default with the provided override
+  if extend then
+    -- if the override is a table, use vim.tbl_deep_extend
+    if type(overrides) == "table" then
+      local opts = overrides or {}
+      default = default and vim.tbl_deep_extend("force", default, opts) or opts
+    -- if the override is  a function, call it with the default and overwrite default with the return value
+    elseif type(overrides) == "function" then
+      default = overrides(default)
+    end
+  -- if extend is set to false and we have a provided override, simply override the default
+  elseif overrides ~= nil then
+    default = overrides
+  end
+  -- return the modified default table
+  return default
+end
+
+--- user settings from the base `user/init.lua` file
+local user_settings = load_module_file "user.init"
+
+--- Search the user settings (user/init.lua table) for a table with a module like path string
+-- @param module the module path like string to look up in the user settings table
+-- @return the value of the table entry if exists or nil
+local function user_setting_table(module)
+  -- get the user settings table
+  local settings = user_settings or {}
+  -- iterate over the path string split by '.' to look up the table value
+  for tbl in string.gmatch(module, "([^%.]+)") do
+    settings = settings[tbl]
+    -- if key doesn't exist, keep the nil value and stop searching
+    if settings == nil then break end
+  end
+  -- return the found settings
+  return settings
+end
+
+--- User configuration entry point to override the default options of a configuration table with a user configuration file or table in the user/init.lua user settings
+---@param module string The module path of the override setting
+---@param default? any The default value that will be overridden
+---@param extend? boolean # Whether extend the default settings or overwrite them with the user settings entirely (default: true)
+---@return any # The new configuration settings with the user overrides applied
+function astronvim.user_opts(module, default, extend)
+  -- default to extend = true
+  if extend == nil then extend = true end
+  -- if no default table is provided set it to an empty table
+  if default == nil then default = {} end
+  -- try to load a module file if it exists
+  local user_module_settings = load_module_file("user." .. module)
+  -- if no user module file is found, try to load an override from the user settings table from user/init.lua
+  if user_module_settings == nil then user_module_settings = user_setting_table(module) end
+  -- if a user override was found call the configuration engine
+  if user_module_settings ~= nil then default = func_or_extend(user_module_settings, default, extend) end
+  -- return the final configuration table with any overrides applied
+  return default
+end
+
+--- Updater settings overridden with any user provided configuration
+astronvim.updater = {
+  options = astronvim.user_opts("updater", { remote = "origin", channel = "stable" }),
+  snapshot = { module = "lazy_snapshot", path = vim.fn.stdpath "config" .. "/lua/lazy_snapshot.lua" },
+  rollback_file = vim.fn.stdpath "cache" .. "/astronvim_rollback.lua",
+}
+local options = astronvim.updater.options
+if astronvim.install.is_stable ~= nil then options.channel = astronvim.install.is_stable and "stable" or "nightly" end
+if options.pin_plugins == nil then options.pin_plugins = options.channel == "stable" end
+
+--- table of user created terminals
+astronvim.user_terminals = {}
+--- table of language servers to ignore the setup of, configured through lsp.skip_setup in the user configuration
+astronvim.lsp = { skip_setup = astronvim.user_opts("lsp.skip_setup", {}), progress = {} }
+--- the default colorscheme to apply on startup
+astronvim.default_colorscheme = astronvim.user_opts("colorscheme", "astrotheme", false)
diff --git a/lua/astronvim/config.lua b/lua/astronvim/config.lua
deleted file mode 100644
index 25bb526..0000000
--- a/lua/astronvim/config.lua
+++ /dev/null
@@ -1,12 +0,0 @@
----@class AstroNvimOpts
----@field mapleader string? the leader key to map before setting up Lazy
----@field maplocalleader string? the local leader key to map before setting up Lazy
----@field icons_enabled boolean? whether to enable icons, default to `true`
----@field pin_plugins boolean? whether to pin plugins or not, if `nil` then will pin if version is set.
-
----@type AstroNvimOpts
-return {
-  mapleader = " ",
-  maplocalleader = ",",
-  icons_enabled = true,
-}
diff --git a/lua/astronvim/dev.lua b/lua/astronvim/dev.lua
deleted file mode 100644
index 1fbf75b..0000000
--- a/lua/astronvim/dev.lua
+++ /dev/null
@@ -1,52 +0,0 @@
-local M = {}
-
-local astrocore = require "astrocore"
-
---- Helper function to generate AstroNvim snapshots (For internal use only)
----@param write? false write to AstroNvim if in `dev` mode, false to force no write
----@return table # The plugin specification table of the snapshot
-function M.generate_snapshot(write)
-  local astronvim = assert(astrocore.get_plugin "AstroNvim")
-  if write ~= false then write = astronvim.dev end
-  local file
-  local prev_snapshot = require "astronvim.lazy_snapshot"
-  for _, plugin in ipairs(prev_snapshot) do
-    prev_snapshot[plugin[1]] = plugin
-  end
-  local plugins = assert(require("lazy").plugins())
-  table.sort(plugins, function(l, r) return l[1] < r[1] end)
-  local function git_commit(dir)
-    local commit = assert(astrocore.cmd({ "git", "-C", dir, "rev-parse", "HEAD" }, false))
-    if commit then return vim.trim(commit) end
-  end
-  if write then
-    file = assert(io.open(astronvim.dir .. "/lua/astronvim/lazy_snapshot.lua", "w"))
-    file:write "return {\n"
-  end
-  local snapshot = {}
-  for _, plugin in ipairs(plugins) do
-    if plugin[1] ~= "AstroNvim/AstroNvim" then
-      plugin = { plugin[1], commit = git_commit(plugin.dir), version = plugin.version }
-      if prev_snapshot[plugin[1]] and prev_snapshot[plugin[1]].version then
-        plugin.version = prev_snapshot[plugin[1]].version
-      end
-      if file then
-        file:write(("  { %q, "):format(plugin[1]))
-        if plugin.version then
-          file:write(("version = %q"):format(plugin.version))
-        else
-          file:write(("commit = %q"):format(plugin.commit))
-        end
-        file:write ", optional = true },\n"
-      end
-      table.insert(snapshot, plugin)
-    end
-  end
-  if file then
-    file:write "}\n"
-    file:close()
-  end
-  return snapshot
-end
-
-return M
diff --git a/lua/astronvim/health.lua b/lua/astronvim/health.lua
index 2c379c0..97682ce 100644
--- a/lua/astronvim/health.lua
+++ b/lua/astronvim/health.lua
@@ -1,26 +1,26 @@
--- ### AstroNvim Health Checks
---
--- use with `:checkhealth astronvim`
---
--- copyright 2023
--- license GNU General Public License v3.0
-
 local M = {}
 
-local health = vim.health
+-- TODO: remove deprecated method check after dropping support for neovim v0.9
+local health = {
+  start = vim.health.start or vim.health.report_start,
+  ok = vim.health.ok or vim.health.report_ok,
+  warn = vim.health.warn or vim.health.report_warn,
+  error = vim.health.error or vim.health.report_error,
+  info = vim.health.info or vim.health.report_info,
+}
 
 function M.check()
   health.start "AstroNvim"
 
-  -- health.info("AstroNvim Version: " .. require("astrocore.updater").version(true))
+  health.info("AstroNvim Version: " .. require("astronvim.utils.updater").version(true))
   health.info("Neovim Version: v" .. vim.fn.matchstr(vim.fn.execute "version", "NVIM v\\zs[^\n]*"))
 
   if vim.version().prerelease then
     health.warn "Neovim nightly is not officially supported and may have breaking changes"
-  elseif vim.fn.has "nvim-0.9" == 1 then
-    health.ok "Using stable Neovim >= 0.9.0"
+  elseif vim.fn.has "nvim-0.8" == 1 then
+    health.ok "Using stable Neovim >= 0.8.0"
   else
-    health.error "Neovim >= 0.9.0 is required"
+    health.error "Neovim >= 0.8.0 is required"
   end
 
   local programs = {
@@ -28,17 +28,24 @@ function M.check()
       cmd = { "git" },
       type = "error",
       msg = "Used for core functionality such as updater and plugin management",
+      extra_check = function(program)
+        local git_version = require("astronvim.utils.git").git_version()
+        if git_version then
+          if git_version.major < 2 or (git_version.major == 2 and git_version.min < 19) then
+            program.msg = ("Git %s installed, >= 2.19.0 is required"):format(git_version.str)
+          else
+            return true
+          end
+        else
+          program.msg = "Unable to validate git version"
+        end
+      end,
     },
     {
       cmd = { "xdg-open", "rundll32", "explorer.exe", "open" },
       type = "warn",
       msg = "Used for `gx` mapping for opening files with system opener (Optional)",
     },
-    {
-      cmd = { "rg" },
-      type = "warn",
-      msg = "Used for Telescope `live_grep` picker, `<Leader>fw` and `<Leader>fW` by default (Optional)",
-    },
     { cmd = { "lazygit" }, type = "warn", msg = "Used for mappings to pull up git TUI (Optional)" },
     { cmd = { "node" }, type = "warn", msg = "Used for mappings to pull up node REPL (Optional)" },
     {
diff --git a/lua/astronvim/icons/nerd_font.lua b/lua/astronvim/icons/nerd_font.lua
new file mode 100644
index 0000000..87aa092
--- /dev/null
+++ b/lua/astronvim/icons/nerd_font.lua
@@ -0,0 +1,60 @@
+return {
+  ActiveLSP = "",
+  ActiveTS = "",
+  ArrowLeft = "",
+  ArrowRight = "",
+  Bookmarks = "",
+  BufferClose = "󰅖",
+  DapBreakpoint = "",
+  DapBreakpointCondition = "",
+  DapBreakpointRejected = "",
+  DapLogPoint = ".>",
+  DapStopped = "󰁕",
+  Debugger = "",
+  DefaultFile = "󰈙",
+  Diagnostic = "󰒡",
+  DiagnosticError = "",
+  DiagnosticHint = "󰌵",
+  DiagnosticInfo = "󰋼",
+  DiagnosticWarn = "",
+  Ellipsis = "…",
+  FileNew = "",
+  FileModified = "",
+  FileReadOnly = "",
+  FoldClosed = "",
+  FoldOpened = "",
+  FoldSeparator = " ",
+  FolderClosed = "",
+  FolderEmpty = "",
+  FolderOpen = "",
+  Git = "󰊢",
+  GitAdd = "",
+  GitBranch = "",
+  GitChange = "",
+  GitConflict = "",
+  GitDelete = "",
+  GitIgnored = "◌",
+  GitRenamed = "➜",
+  GitSign = "▎",
+  GitStaged = "✓",
+  GitUnstaged = "✗",
+  GitUntracked = "★",
+  LSPLoaded = "", -- TODO: Remove unused icon in AstroNvim v4
+  LSPLoading1 = "",
+  LSPLoading2 = "󰀚",
+  LSPLoading3 = "",
+  MacroRecording = "",
+  Package = "󰏖",
+  Paste = "󰅌",
+  Refresh = "",
+  Search = "",
+  Selected = "❯",
+  Session = "󱂬",
+  Sort = "󰒺",
+  Spellcheck = "󰓆",
+  Tab = "󰓩",
+  TabClose = "󰅙",
+  Terminal = "",
+  Window = "",
+  WordFile = "󰈭",
+}
diff --git a/lua/astronvim/icons/text.lua b/lua/astronvim/icons/text.lua
new file mode 100644
index 0000000..ba3fe18
--- /dev/null
+++ b/lua/astronvim/icons/text.lua
@@ -0,0 +1,41 @@
+return {
+  ActiveLSP = "LSP:",
+  ArrowLeft = "<",
+  ArrowRight = ">",
+  BufferClose = "x",
+  DapBreakpoint = "B",
+  DapBreakpointCondition = "C",
+  DapBreakpointRejected = "R",
+  DapLogPoint = "L",
+  DapStopped = ">",
+  DefaultFile = "[F]",
+  DiagnosticError = "X",
+  DiagnosticHint = "?",
+  DiagnosticInfo = "i",
+  DiagnosticWarn = "!",
+  Ellipsis = "...",
+  FileModified = "*",
+  FileReadOnly = "[lock]",
+  FoldClosed = "+",
+  FoldOpened = "-",
+  FoldSeparator = " ",
+  FolderClosed = "[D]",
+  FolderEmpty = "[E]",
+  FolderOpen = "[O]",
+  GitAdd = "[+]",
+  GitChange = "[/]",
+  GitConflict = "[!]",
+  GitDelete = "[-]",
+  GitIgnored = "[I]",
+  GitRenamed = "[R]",
+  GitSign = "|",
+  GitStaged = "[S]",
+  GitUnstaged = "[U]",
+  GitUntracked = "[?]",
+  MacroRecording = "Recording:",
+  Paste = "[PASTE]",
+  Search = "?",
+  Selected = "*",
+  Spellcheck = "[SPELL]",
+  TabClose = "X",
+}
diff --git a/lua/astronvim/init.lua b/lua/astronvim/init.lua
deleted file mode 100644
index ed98868..0000000
--- a/lua/astronvim/init.lua
+++ /dev/null
@@ -1,68 +0,0 @@
-local M = {}
-
-M.did_init = false
-
-M.config = require "astronvim.config"
-
-local function lazy_notify()
-  -- Based on notification lazy loading in LazyVim
-  -- https://github.com/LazyVim/LazyVim/blob/a50f92f7550fb6e9f21c0852e6cb190e6fcd50f5/lua/lazyvim/util/init.lua#L90-L125
-  local notifications = {}
-  local function notify_queue(...) table.insert(notifications, vim.F.pack_len(...)) end
-  local original_notify = vim.notify
-  vim.notify = notify_queue
-
-  local uv = vim.uv or vim.loop
-  local timer, checker = uv.new_timer(), uv.new_check()
-
-  local replay = function()
-    timer:stop()
-    checker:stop()
-    if vim.notify == notify_queue then vim.notify = original_notify end
-    vim.schedule(function()
-      vim.tbl_map(function(notif) vim.notify(vim.F.unpack_len(notif)) end, notifications)
-    end)
-  end
-
-  -- wait till vim.notify has been replaced
-  checker:start(function()
-    if vim.notify ~= notify_queue then replay() end
-  end)
-  -- or if it took more than 500ms, then something went wrong
-  timer:start(500, 0, replay)
-end
-
-function M.init()
-  if vim.fn.has "nvim-0.9" == 0 then
-    vim.api.nvim_echo({
-      { "AstroNvim requires Neovim >= 0.9.0\n", "ErrorMsg" },
-      { "Press any key to exit", "MoreMsg" },
-    }, true, {})
-    vim.fn.getchar()
-    vim.cmd.quit()
-  end
-
-  if M.did_init then return end
-  M.did_init = true
-
-  lazy_notify()
-
-  -- force setup during initialization
-  local plugin = require("lazy.core.config").spec.plugins.AstroNvim
-
-  local opts = require("lazy.core.plugin").values(plugin, "opts")
-  if opts.pin_plugins == nil then opts.pin_plugins = plugin.version ~= nil end
-
-  ---@diagnostic disable-next-line: cast-local-type
-  opts = vim.tbl_deep_extend("force", M.config, opts)
-  ---@cast opts -nil
-  M.config = opts
-
-  if not vim.g.mapleader and M.config.mapleader then vim.g.mapleader = M.config.mapleader end
-  if not vim.g.maplocalleader and M.config.maplocalleader then vim.g.maplocalleader = M.config.maplocalleader end
-  if M.config.icons_enabled == false then vim.g.icons_enabled = false end
-end
-
-function M.setup() end
-
-return M
diff --git a/lua/astronvim/lazy.lua b/lua/astronvim/lazy.lua
new file mode 100644
index 0000000..e681250
--- /dev/null
+++ b/lua/astronvim/lazy.lua
@@ -0,0 +1,55 @@
+local git_version = vim.fn.system { "git", "--version" }
+if vim.api.nvim_get_vvar "shell_error" ~= 0 then
+  vim.api.nvim_err_writeln("Git doesn't appear to be available...\n\n" .. git_version)
+end
+local major, min, _ = unpack(vim.tbl_map(tonumber, vim.split(git_version:match "%d+%.%d+%.%d", "%.")))
+local modern_git = major > 2 or (major == 2 and min >= 19)
+
+local lazypath = vim.fn.stdpath "data" .. "/lazy/lazy.nvim"
+if not (vim.uv or vim.loop).fs_stat(lazypath) then -- TODO: REMOVE vim.loop WHEN DROPPING SUPPORT FOR Neovim v0.9
+  local clone = { "git", "clone", modern_git and "--filter=blob:none" or nil }
+  local output =
+    vim.fn.system(vim.list_extend(clone, { "--branch=stable", "https://github.com/folke/lazy.nvim.git", lazypath }))
+  if vim.api.nvim_get_vvar "shell_error" ~= 0 then
+    vim.api.nvim_err_writeln("Error cloning lazy.nvim repository...\n\n" .. output)
+  end
+  local oldcmdheight = vim.opt.cmdheight:get()
+  vim.opt.cmdheight = 1
+  vim.notify "Please wait while plugins are installed..."
+  vim.api.nvim_create_autocmd("User", {
+    desc = "Load Mason and Treesitter after Lazy installs plugins",
+    once = true,
+    pattern = "LazyInstall",
+    callback = function()
+      vim.cmd.bw()
+      vim.opt.cmdheight = oldcmdheight
+      vim.tbl_map(function(module) pcall(require, module) end, { "nvim-treesitter", "mason" })
+      require("astronvim.utils").notify "Mason is installing packages if configured, check status with `:Mason`"
+    end,
+  })
+end
+vim.opt.rtp:prepend(lazypath)
+
+local user_plugins = astronvim.user_opts "plugins"
+for _, config_dir in ipairs(astronvim.supported_configs) do
+  if vim.fn.isdirectory(config_dir .. "/lua/user/plugins") == 1 then user_plugins = { import = "user.plugins" } end
+end
+
+local spec = astronvim.updater.options.pin_plugins and { { import = astronvim.updater.snapshot.module } } or {}
+vim.list_extend(spec, { { import = "plugins" }, user_plugins })
+
+local colorscheme = astronvim.default_colorscheme and { astronvim.default_colorscheme } or nil
+
+require("lazy").setup(astronvim.user_opts("lazy", {
+  spec = spec,
+  defaults = { lazy = true },
+  git = { filter = modern_git },
+  install = { colorscheme = colorscheme },
+  performance = {
+    rtp = {
+      paths = astronvim.supported_configs,
+      disabled_plugins = { "tohtml", "gzip", "zipPlugin", "netrwPlugin", "tarPlugin" },
+    },
+  },
+  lockfile = vim.fn.stdpath "data" .. "/lazy-lock.json",
+}))
diff --git a/lua/astronvim/mappings.lua b/lua/astronvim/mappings.lua
new file mode 100644
index 0000000..5c97e01
--- /dev/null
+++ b/lua/astronvim/mappings.lua
@@ -0,0 +1,464 @@
+-- TODO: replace <leader> to <Leader> everywhere in AstroNvim v4 to match vimdoc
+local utils = require "astronvim.utils"
+local get_icon = utils.get_icon
+local is_available = utils.is_available
+local ui = require "astronvim.utils.ui"
+
+local maps = require("astronvim.utils").empty_map_table()
+
+local sections = {
+  f = { desc = get_icon("Search", 1, true) .. "Find" },
+  p = { desc = get_icon("Package", 1, true) .. "Packages" },
+  l = { desc = get_icon("ActiveLSP", 1, true) .. "LSP" },
+  u = { desc = get_icon("Window", 1, true) .. "UI/UX" },
+  b = { desc = get_icon("Tab", 1, true) .. "Buffers" },
+  bs = { desc = get_icon("Sort", 1, true) .. "Sort Buffers" },
+  d = { desc = get_icon("Debugger", 1, true) .. "Debugger" },
+  g = { desc = get_icon("Git", 1, true) .. "Git" },
+  S = { desc = get_icon("Session", 1, true) .. "Session" },
+  t = { desc = get_icon("Terminal", 1, true) .. "Terminal" },
+}
+
+-- Normal --
+-- Standard Operations
+maps.n["j"] = { "v:count == 0 ? 'gj' : 'j'", expr = true, desc = "Move cursor down" }
+maps.n["k"] = { "v:count == 0 ? 'gk' : 'k'", expr = true, desc = "Move cursor up" }
+maps.n["<leader>w"] = { "<cmd>w<cr>", desc = "Save" }
+maps.n["<leader>q"] = { "<cmd>confirm q<cr>", desc = "Quit" }
+maps.n["<leader>Q"] = { "<cmd>confirm qall<cr>", desc = "Quit all" }
+maps.n["<leader>n"] = { "<cmd>enew<cr>", desc = "New File" }
+maps.n["<C-s>"] = { "<cmd>w!<cr>", desc = "Force write" }
+maps.n["<C-q>"] = { "<cmd>qa!<cr>", desc = "Force quit" }
+maps.n["\\"] = { "<cmd>vsplit<cr>", desc = "Vertical Split" }
+maps.n["|"] = { "<cmd>split<cr>", desc = "Horizontal Split" }
+-- TODO: Remove when dropping support for <Neovim v0.10
+if not vim.ui.open then maps.n["gx"] = { utils.system_open, desc = "Open the file under cursor with system app" } end
+
+-- Plugin Manager
+maps.n["<leader>p"] = sections.p
+maps.n["<leader>pi"] = { function() require("lazy").install() end, desc = "Plugins Install" }
+maps.n["<leader>ps"] = { function() require("lazy").home() end, desc = "Plugins Status" }
+maps.n["<leader>pS"] = { function() require("lazy").sync() end, desc = "Plugins Sync" }
+maps.n["<leader>pu"] = { function() require("lazy").check() end, desc = "Plugins Check Updates" }
+maps.n["<leader>pU"] = { function() require("lazy").update() end, desc = "Plugins Update" }
+
+-- AstroNvim
+maps.n["<leader>pa"] = { "<cmd>AstroUpdatePackages<cr>", desc = "Update Plugins and Mason Packages" }
+maps.n["<leader>pA"] = { "<cmd>AstroUpdate<cr>", desc = "AstroNvim Update" }
+maps.n["<leader>pv"] = { "<cmd>AstroVersion<cr>", desc = "AstroNvim Version" }
+maps.n["<leader>pl"] = { "<cmd>AstroChangelog<cr>", desc = "AstroNvim Changelog" }
+
+-- Manage Buffers
+maps.n["<leader>c"] = { function() require("astronvim.utils.buffer").close() end, desc = "Close buffer" }
+maps.n["<leader>C"] = { function() require("astronvim.utils.buffer").close(0, true) end, desc = "Force close buffer" }
+maps.n["]b"] =
+  { function() require("astronvim.utils.buffer").nav(vim.v.count > 0 and vim.v.count or 1) end, desc = "Next buffer" }
+maps.n["[b"] = {
+  function() require("astronvim.utils.buffer").nav(-(vim.v.count > 0 and vim.v.count or 1)) end,
+  desc = "Previous buffer",
+}
+maps.n[">b"] = {
+  function() require("astronvim.utils.buffer").move(vim.v.count > 0 and vim.v.count or 1) end,
+  desc = "Move buffer tab right",
+}
+maps.n["<b"] = {
+  function() require("astronvim.utils.buffer").move(-(vim.v.count > 0 and vim.v.count or 1)) end,
+  desc = "Move buffer tab left",
+}
+
+maps.n["<leader>b"] = sections.b
+maps.n["<leader>bc"] =
+  { function() require("astronvim.utils.buffer").close_all(true) end, desc = "Close all buffers except current" }
+maps.n["<leader>bC"] = { function() require("astronvim.utils.buffer").close_all() end, desc = "Close all buffers" }
+maps.n["<leader>bl"] =
+  { function() require("astronvim.utils.buffer").close_left() end, desc = "Close all buffers to the left" }
+maps.n["<leader>bp"] = { function() require("astronvim.utils.buffer").prev() end, desc = "Previous buffer" }
+maps.n["<leader>br"] =
+  { function() require("astronvim.utils.buffer").close_right() end, desc = "Close all buffers to the right" }
+maps.n["<leader>bs"] = sections.bs
+maps.n["<leader>bse"] = { function() require("astronvim.utils.buffer").sort "extension" end, desc = "By extension" }
+maps.n["<leader>bsr"] =
+  { function() require("astronvim.utils.buffer").sort "unique_path" end, desc = "By relative path" }
+maps.n["<leader>bsp"] = { function() require("astronvim.utils.buffer").sort "full_path" end, desc = "By full path" }
+maps.n["<leader>bsi"] = { function() require("astronvim.utils.buffer").sort "bufnr" end, desc = "By buffer number" }
+maps.n["<leader>bsm"] = { function() require("astronvim.utils.buffer").sort "modified" end, desc = "By modification" }
+
+if is_available "heirline.nvim" then
+  maps.n["<leader>bb"] = {
+    function()
+      require("astronvim.utils.status.heirline").buffer_picker(function(bufnr) vim.api.nvim_win_set_buf(0, bufnr) end)
+    end,
+    desc = "Select buffer from tabline",
+  }
+  maps.n["<leader>bd"] = {
+    function()
+      require("astronvim.utils.status.heirline").buffer_picker(
+        function(bufnr) require("astronvim.utils.buffer").close(bufnr) end
+      )
+    end,
+    desc = "Close buffer from tabline",
+  }
+  maps.n["<leader>b\\"] = {
+    function()
+      require("astronvim.utils.status.heirline").buffer_picker(function(bufnr)
+        vim.cmd.split()
+        vim.api.nvim_win_set_buf(0, bufnr)
+      end)
+    end,
+    desc = "Horizontal split buffer from tabline",
+  }
+  maps.n["<leader>b|"] = {
+    function()
+      require("astronvim.utils.status.heirline").buffer_picker(function(bufnr)
+        vim.cmd.vsplit()
+        vim.api.nvim_win_set_buf(0, bufnr)
+      end)
+    end,
+    desc = "Vertical split buffer from tabline",
+  }
+end
+
+-- Navigate tabs
+maps.n["]t"] = { function() vim.cmd.tabnext() end, desc = "Next tab" }
+maps.n["[t"] = { function() vim.cmd.tabprevious() end, desc = "Previous tab" }
+
+-- Alpha
+if is_available "alpha-nvim" then
+  maps.n["<leader>h"] = {
+    function()
+      local wins = vim.api.nvim_tabpage_list_wins(0)
+      if #wins > 1 and vim.bo[vim.api.nvim_win_get_buf(wins[1])].filetype == "neo-tree" then
+        vim.fn.win_gotoid(wins[2]) -- go to non-neo-tree window to toggle alpha
+      end
+      require("alpha").start(false)
+    end,
+    desc = "Home Screen",
+  }
+end
+
+-- Comment
+if is_available "Comment.nvim" then
+  maps.n["<leader>/"] = {
+    function() require("Comment.api").toggle.linewise.count(vim.v.count > 0 and vim.v.count or 1) end,
+    desc = "Toggle comment line",
+  }
+  maps.v["<leader>/"] = {
+    "<esc><cmd>lua require('Comment.api').toggle.linewise(vim.fn.visualmode())<cr>",
+    desc = "Toggle comment for selection",
+  }
+end
+
+-- GitSigns
+if is_available "gitsigns.nvim" then
+  maps.n["<leader>g"] = sections.g
+  maps.n["]g"] = { function() require("gitsigns").next_hunk() end, desc = "Next Git hunk" }
+  maps.n["[g"] = { function() require("gitsigns").prev_hunk() end, desc = "Previous Git hunk" }
+  maps.n["<leader>gl"] = { function() require("gitsigns").blame_line() end, desc = "View Git blame" }
+  maps.n["<leader>gL"] = { function() require("gitsigns").blame_line { full = true } end, desc = "View full Git blame" }
+  maps.n["<leader>gp"] = { function() require("gitsigns").preview_hunk() end, desc = "Preview Git hunk" }
+  maps.n["<leader>gh"] = { function() require("gitsigns").reset_hunk() end, desc = "Reset Git hunk" }
+  maps.n["<leader>gr"] = { function() require("gitsigns").reset_buffer() end, desc = "Reset Git buffer" }
+  maps.n["<leader>gs"] = { function() require("gitsigns").stage_hunk() end, desc = "Stage Git hunk" }
+  maps.n["<leader>gS"] = { function() require("gitsigns").stage_buffer() end, desc = "Stage Git buffer" }
+  maps.n["<leader>gu"] = { function() require("gitsigns").undo_stage_hunk() end, desc = "Unstage Git hunk" }
+  maps.n["<leader>gd"] = { function() require("gitsigns").diffthis() end, desc = "View Git diff" }
+end
+
+-- NeoTree
+if is_available "neo-tree.nvim" then
+  maps.n["<leader>e"] = { "<cmd>Neotree toggle<cr>", desc = "Toggle Explorer" }
+  maps.n["<leader>o"] = {
+    function()
+      if vim.bo.filetype == "neo-tree" then
+        vim.cmd.wincmd "p"
+      else
+        vim.cmd.Neotree "focus"
+      end
+    end,
+    desc = "Toggle Explorer Focus",
+  }
+end
+
+-- Session Manager
+if is_available "neovim-session-manager" then
+  maps.n["<leader>S"] = sections.S
+  maps.n["<leader>Sl"] = { "<cmd>SessionManager! load_last_session<cr>", desc = "Load last session" }
+  maps.n["<leader>Ss"] = { "<cmd>SessionManager! save_current_session<cr>", desc = "Save this session" }
+  maps.n["<leader>Sd"] = { "<cmd>SessionManager! delete_session<cr>", desc = "Delete session" }
+  maps.n["<leader>r"] = { "<cmd>SessionManager! load_session<cr>", desc = "Search sessions" }
+  maps.n["<leader>S."] =
+    { "<cmd>SessionManager! load_current_dir_session<cr>", desc = "Load current directory session" }
+end
+if is_available "resession.nvim" then
+  maps.n["<leader>S"] = sections.S
+  maps.n["<leader>Sl"] = { function() require("resession").load "Last Session" end, desc = "Load last session" }
+  maps.n["<leader>Ss"] = { function() require("resession").save() end, desc = "Save this session" }
+  maps.n["<leader>St"] = { function() require("resession").save_tab() end, desc = "Save this tab's session" }
+  maps.n["<leader>Sd"] = { function() require("resession").delete() end, desc = "Delete a session" }
+  maps.n["<leader>Sf"] = { function() require("resession").load() end, desc = "Load a session" }
+  maps.n["<leader>S."] = {
+    function() require("resession").load(vim.fn.getcwd(), { dir = "dirsession" }) end,
+    desc = "Load current directory session",
+  }
+end
+
+-- Package Manager
+if is_available "mason.nvim" then
+  maps.n["<leader>pm"] = { "<cmd>Mason<cr>", desc = "Mason Installer" }
+  maps.n["<leader>pM"] = { "<cmd>MasonUpdateAll<cr>", desc = "Mason Update" }
+end
+
+-- Smart Splits
+if is_available "smart-splits.nvim" then
+  maps.n["<C-h>"] = { function() require("smart-splits").move_cursor_left() end, desc = "Move to left split" }
+  maps.n["<C-j>"] = { function() require("smart-splits").move_cursor_down() end, desc = "Move to below split" }
+  maps.n["<C-k>"] = { function() require("smart-splits").move_cursor_up() end, desc = "Move to above split" }
+  maps.n["<C-l>"] = { function() require("smart-splits").move_cursor_right() end, desc = "Move to right split" }
+  maps.n["<C-Up>"] = { function() require("smart-splits").resize_up() end, desc = "Resize split up" }
+  maps.n["<C-Down>"] = { function() require("smart-splits").resize_down() end, desc = "Resize split down" }
+  maps.n["<C-Left>"] = { function() require("smart-splits").resize_left() end, desc = "Resize split left" }
+  maps.n["<C-Right>"] = { function() require("smart-splits").resize_right() end, desc = "Resize split right" }
+else
+  maps.n["<C-h>"] = { "<C-w>h", desc = "Move to left split" }
+  maps.n["<C-j>"] = { "<C-w>j", desc = "Move to below split" }
+  maps.n["<C-k>"] = { "<C-w>k", desc = "Move to above split" }
+  maps.n["<C-l>"] = { "<C-w>l", desc = "Move to right split" }
+  maps.n["<C-Up>"] = { "<cmd>resize -2<CR>", desc = "Resize split up" }
+  maps.n["<C-Down>"] = { "<cmd>resize +2<CR>", desc = "Resize split down" }
+  maps.n["<C-Left>"] = { "<cmd>vertical resize -2<CR>", desc = "Resize split left" }
+  maps.n["<C-Right>"] = { "<cmd>vertical resize +2<CR>", desc = "Resize split right" }
+end
+
+-- SymbolsOutline
+if is_available "aerial.nvim" then
+  maps.n["<leader>l"] = sections.l
+  maps.n["<leader>lS"] = { function() require("aerial").toggle() end, desc = "Symbols outline" }
+end
+
+-- Telescope
+if is_available "telescope.nvim" then
+  maps.n["<leader>f"] = sections.f
+  maps.n["<leader>g"] = sections.g
+  maps.n["<leader>gb"] =
+    { function() require("telescope.builtin").git_branches { use_file_path = true } end, desc = "Git branches" }
+  maps.n["<leader>gc"] = {
+    function() require("telescope.builtin").git_commits { use_file_path = true } end,
+    desc = "Git commits (repository)",
+  }
+  maps.n["<leader>gC"] = {
+    function() require("telescope.builtin").git_bcommits { use_file_path = true } end,
+    desc = "Git commits (current file)",
+  }
+  maps.n["<leader>gt"] =
+    { function() require("telescope.builtin").git_status { use_file_path = true } end, desc = "Git status" }
+  maps.n["<leader>f<CR>"] = { function() require("telescope.builtin").resume() end, desc = "Resume previous search" }
+  maps.n["<leader>f'"] = { function() require("telescope.builtin").marks() end, desc = "Find marks" }
+  maps.n["<leader>f/"] =
+    { function() require("telescope.builtin").current_buffer_fuzzy_find() end, desc = "Find words in current buffer" }
+  maps.n["<leader>fa"] = {
+    function()
+      local cwd = vim.fn.stdpath "config" .. "/.."
+      local search_dirs = {}
+      for _, dir in ipairs(astronvim.supported_configs) do -- search all supported config locations
+        if dir == astronvim.install.home then dir = dir .. "/lua/user" end -- don't search the astronvim core files
+        if vim.fn.isdirectory(dir) == 1 then table.insert(search_dirs, dir) end -- add directory to search if exists
+      end
+      if vim.tbl_isempty(search_dirs) then -- if no config folders found, show warning
+        utils.notify("No user configuration files found", vim.log.levels.WARN)
+      else
+        if #search_dirs == 1 then cwd = search_dirs[1] end -- if only one directory, focus cwd
+        require("telescope.builtin").find_files {
+          prompt_title = "Config Files",
+          search_dirs = search_dirs,
+          cwd = cwd,
+          follow = true,
+        } -- call telescope
+      end
+    end,
+    desc = "Find AstroNvim config files",
+  }
+  maps.n["<leader>fb"] = { function() require("telescope.builtin").buffers() end, desc = "Find buffers" }
+  maps.n["<leader>fc"] = { function() require("telescope.builtin").grep_string() end, desc = "Find word under cursor" }
+  maps.n["<leader>fC"] = { function() require("telescope.builtin").commands() end, desc = "Find commands" }
+  maps.n["<leader>ff"] = { function() require("telescope.builtin").find_files() end, desc = "Find files" }
+  maps.n["<leader>fF"] = {
+    function() require("telescope.builtin").find_files { hidden = true, no_ignore = true } end,
+    desc = "Find all files",
+  }
+  maps.n["<leader>fh"] = { function() require("telescope.builtin").help_tags() end, desc = "Find help" }
+  maps.n["<leader>fk"] = { function() require("telescope.builtin").keymaps() end, desc = "Find keymaps" }
+  maps.n["<leader>fm"] = { function() require("telescope.builtin").man_pages() end, desc = "Find man" }
+  if is_available "nvim-notify" then
+    maps.n["<leader>fn"] =
+      { function() require("telescope").extensions.notify.notify() end, desc = "Find notifications" }
+    maps.n["<leader>uD"] =
+      { function() require("notify").dismiss { pending = true, silent = true } end, desc = "Dismiss notifications" }
+  end
+  maps.n["<leader>fo"] = { function() require("telescope.builtin").oldfiles() end, desc = "Find history" }
+  maps.n["<leader>fr"] = { function() require("telescope.builtin").registers() end, desc = "Find registers" }
+  maps.n["<leader>ft"] =
+    { function() require("telescope.builtin").colorscheme { enable_preview = true } end, desc = "Find themes" }
+  maps.n["<leader>fw"] = { function() require("telescope.builtin").live_grep() end, desc = "Find words" }
+  maps.n["<leader>fW"] = {
+    function()
+      require("telescope.builtin").live_grep {
+        additional_args = function(args) return vim.list_extend(args, { "--hidden", "--no-ignore" }) end,
+      }
+    end,
+    desc = "Find words in all files",
+  }
+  maps.n["<leader>l"] = sections.l
+  maps.n["<leader>ls"] = {
+    function()
+      local aerial_avail, _ = pcall(require, "aerial")
+      if aerial_avail then
+        require("telescope").extensions.aerial.aerial()
+      else
+        require("telescope.builtin").lsp_document_symbols()
+      end
+    end,
+    desc = "Search symbols",
+  }
+end
+
+-- Terminal
+if is_available "toggleterm.nvim" then
+  maps.n["<leader>t"] = sections.t
+  if vim.fn.executable "lazygit" == 1 then
+    maps.n["<leader>g"] = sections.g
+    maps.n["<leader>gg"] = {
+      function()
+        local worktree = require("astronvim.utils.git").file_worktree()
+        local flags = worktree and (" --work-tree=%s --git-dir=%s"):format(worktree.toplevel, worktree.gitdir) or ""
+        utils.toggle_term_cmd("lazygit " .. flags)
+      end,
+      desc = "ToggleTerm lazygit",
+    }
+    maps.n["<leader>tl"] = maps.n["<leader>gg"]
+  end
+  if vim.fn.executable "node" == 1 then
+    maps.n["<leader>tn"] = { function() utils.toggle_term_cmd "node" end, desc = "ToggleTerm node" }
+  end
+  local gdu = vim.fn.has "mac" == 1 and "gdu-go" or "gdu"
+  if vim.fn.executable(gdu) == 1 then
+    maps.n["<leader>tu"] = { function() utils.toggle_term_cmd(gdu) end, desc = "ToggleTerm gdu" }
+  end
+  if vim.fn.executable "btm" == 1 then
+    maps.n["<leader>tt"] = { function() utils.toggle_term_cmd "btm" end, desc = "ToggleTerm btm" }
+  end
+  local python = vim.fn.executable "python" == 1 and "python" or vim.fn.executable "python3" == 1 and "python3"
+  if python then maps.n["<leader>tp"] = { function() utils.toggle_term_cmd(python) end, desc = "ToggleTerm python" } end
+  maps.n["<leader>tf"] = { "<cmd>ToggleTerm direction=float<cr>", desc = "ToggleTerm float" }
+  maps.n["<leader>th"] =
+    { "<cmd>ToggleTerm size=10 direction=horizontal<cr><cmd>startinsert<CR>", desc = "ToggleTerm horizontal split" }
+  maps.n["<leader>tv"] =
+    { "<cmd>ToggleTerm size=80 direction=vertical<cr><cmd>startinsert<CR>", desc = "ToggleTerm vertical split" }
+  maps.n["<F2>"] = { '<Cmd>execute v:count . "ToggleTerm"<CR>', desc = "Toggle terminal" }
+  maps.i["<F7>"] = { "<Esc>" .. maps.n["<F2>"][1], desc = maps.n["<F2>"].desc }
+  maps.t["<F2>"] = maps.n["<F2>"]
+  maps.n["<C-'>"] = maps.n["<F7>"] -- requires terminal that supports binding <C-'>
+  maps.i["<C-'>"] = maps.i["<F7>"] -- requires terminal that supports binding <C-'>
+  maps.t["<C-'>"] = maps.t["<F7>"] -- requires terminal that supports binding <C-'>
+end
+
+if is_available "nvim-dap" then
+  maps.n["<leader>d"] = sections.d
+  maps.v["<leader>d"] = sections.d
+  -- modified function keys found with `showkey -a` in the terminal to get key code
+  -- run `nvim -V3log +quit` and search through the "Terminal info" in the `log` file for the correct keyname
+  maps.n["<F5>"] = { function() require("dap").continue() end, desc = "Debugger: Start" }
+  maps.n["<F17>"] = { function() require("dap").terminate() end, desc = "Debugger: Stop" } -- Shift+F5
+  maps.n["<F21>"] = { -- Shift+F9
+    function()
+      vim.ui.input({ prompt = "Condition: " }, function(condition)
+        if condition then require("dap").set_breakpoint(condition) end
+      end)
+    end,
+    desc = "Debugger: Conditional Breakpoint",
+  }
+  maps.n["<F29>"] = { function() require("dap").restart_frame() end, desc = "Debugger: Restart" } -- Control+F5
+  maps.n["<F6>"] = { function() require("dap").pause() end, desc = "Debugger: Pause" }
+  maps.n["<F9>"] = { function() require("dap").toggle_breakpoint() end, desc = "Debugger: Toggle Breakpoint" }
+  maps.n["<F10>"] = { function() require("dap").step_over() end, desc = "Debugger: Step Over" }
+  maps.n["<F11>"] = { function() require("dap").step_into() end, desc = "Debugger: Step Into" }
+  maps.n["<F23>"] = { function() require("dap").step_out() end, desc = "Debugger: Step Out" } -- Shift+F11
+  maps.n["<leader>db"] = { function() require("dap").toggle_breakpoint() end, desc = "Toggle Breakpoint (F9)" }
+  maps.n["<leader>dB"] = { function() require("dap").clear_breakpoints() end, desc = "Clear Breakpoints" }
+  maps.n["<leader>dc"] = { function() require("dap").continue() end, desc = "Start/Continue (F5)" }
+  maps.n["<leader>dC"] = {
+    function()
+      vim.ui.input({ prompt = "Condition: " }, function(condition)
+        if condition then require("dap").set_breakpoint(condition) end
+      end)
+    end,
+    desc = "Conditional Breakpoint (S-F9)",
+  }
+  maps.n["<leader>di"] = { function() require("dap").step_into() end, desc = "Step Into (F11)" }
+  maps.n["<leader>do"] = { function() require("dap").step_over() end, desc = "Step Over (F10)" }
+  maps.n["<leader>dO"] = { function() require("dap").step_out() end, desc = "Step Out (S-F11)" }
+  maps.n["<leader>dq"] = { function() require("dap").close() end, desc = "Close Session" }
+  maps.n["<leader>dQ"] = { function() require("dap").terminate() end, desc = "Terminate Session (S-F5)" }
+  maps.n["<leader>dp"] = { function() require("dap").pause() end, desc = "Pause (F6)" }
+  maps.n["<leader>dr"] = { function() require("dap").restart_frame() end, desc = "Restart (C-F5)" }
+  maps.n["<leader>dR"] = { function() require("dap").repl.toggle() end, desc = "Toggle REPL" }
+  maps.n["<leader>ds"] = { function() require("dap").run_to_cursor() end, desc = "Run To Cursor" }
+
+  if is_available "nvim-dap-ui" then
+    maps.n["<leader>dE"] = {
+      function()
+        vim.ui.input({ prompt = "Expression: " }, function(expr)
+          if expr then require("dapui").eval(expr, { enter = true }) end
+        end)
+      end,
+      desc = "Evaluate Input",
+    }
+    maps.v["<leader>dE"] = { function() require("dapui").eval() end, desc = "Evaluate Input" }
+    maps.n["<leader>du"] = { function() require("dapui").toggle() end, desc = "Toggle Debugger UI" }
+    maps.n["<leader>dh"] = { function() require("dap.ui.widgets").hover() end, desc = "Debugger Hover" }
+  end
+end
+
+-- Improved Code Folding
+if is_available "nvim-ufo" then
+  maps.n["zR"] = { function() require("ufo").openAllFolds() end, desc = "Open all folds" }
+  maps.n["zM"] = { function() require("ufo").closeAllFolds() end, desc = "Close all folds" }
+  maps.n["zr"] = { function() require("ufo").openFoldsExceptKinds() end, desc = "Fold less" }
+  maps.n["zm"] = { function() require("ufo").closeFoldsWith() end, desc = "Fold more" }
+  maps.n["zp"] = { function() require("ufo").peekFoldedLinesUnderCursor() end, desc = "Peek fold" }
+end
+
+-- Stay in indent mode
+maps.v["<S-Tab>"] = { "<gv", desc = "Unindent line" }
+maps.v["<Tab>"] = { ">gv", desc = "Indent line" }
+
+-- Improved Terminal Navigation
+maps.t["<C-h>"] = { "<cmd>wincmd h<cr>", desc = "Terminal left window navigation" }
+maps.t["<C-j>"] = { "<cmd>wincmd j<cr>", desc = "Terminal down window navigation" }
+maps.t["<C-k>"] = { "<cmd>wincmd k<cr>", desc = "Terminal up window navigation" }
+maps.t["<C-l>"] = { "<cmd>wincmd l<cr>", desc = "Terminal right window navigation" }
+
+maps.n["<leader>u"] = sections.u
+-- Custom menu for modification of the user experience
+if is_available "nvim-autopairs" then maps.n["<leader>ua"] = { ui.toggle_autopairs, desc = "Toggle autopairs" } end
+maps.n["<leader>ub"] = { ui.toggle_background, desc = "Toggle background" }
+if is_available "nvim-cmp" then maps.n["<leader>uc"] = { ui.toggle_cmp, desc = "Toggle autocompletion" } end
+if is_available "nvim-colorizer.lua" then
+  maps.n["<leader>uC"] = { "<cmd>ColorizerToggle<cr>", desc = "Toggle color highlight" }
+end
+maps.n["<leader>ud"] = { ui.toggle_diagnostics, desc = "Toggle diagnostics" }
+maps.n["<leader>ug"] = { ui.toggle_signcolumn, desc = "Toggle signcolumn" }
+maps.n["<leader>ui"] = { ui.set_indent, desc = "Change indent setting" }
+maps.n["<leader>ul"] = { ui.toggle_statusline, desc = "Toggle statusline" }
+maps.n["<leader>uL"] = { ui.toggle_codelens, desc = "Toggle CodeLens" }
+maps.n["<leader>un"] = { ui.change_number, desc = "Change line numbering" }
+maps.n["<leader>uN"] = { ui.toggle_ui_notifications, desc = "Toggle Notifications" }
+maps.n["<leader>up"] = { ui.toggle_paste, desc = "Toggle paste mode" }
+maps.n["<leader>us"] = { ui.toggle_spell, desc = "Toggle spellcheck" }
+maps.n["<leader>uS"] = { ui.toggle_conceal, desc = "Toggle conceal" }
+maps.n["<leader>ut"] = { ui.toggle_tabline, desc = "Toggle tabline" }
+maps.n["<leader>uu"] = { ui.toggle_url_match, desc = "Toggle URL highlight" }
+maps.n["<leader>uw"] = { ui.toggle_wrap, desc = "Toggle wrap" }
+maps.n["<leader>uy"] = { ui.toggle_syntax, desc = "Toggle syntax highlighting (buffer)" }
+maps.n["<leader>uh"] = { ui.toggle_foldcolumn, desc = "Toggle foldcolumn" }
+
+utils.set_mappings(astronvim.user_opts("mappings", maps))
diff --git a/lua/astronvim/options.lua b/lua/astronvim/options.lua
new file mode 100644
index 0000000..56bc7e9
--- /dev/null
+++ b/lua/astronvim/options.lua
@@ -0,0 +1,74 @@
+vim.opt.viewoptions:remove "curdir" -- disable saving current directory with views
+vim.opt.shortmess:append { s = true, I = true } -- disable search count wrap and startup messages
+vim.opt.backspace:append { "nostop" } -- don't stop backspace at insert
+if vim.fn.has "nvim-0.9" == 1 then
+  vim.opt.diffopt:append "linematch:60" -- enable linematch diff algorithm
+end
+local options = astronvim.user_opts("options", {
+  opt = {
+    breakindent = true, -- wrap indent to match  line start
+    clipboard = "unnamedplus", -- connection to the system clipboard
+    cmdheight = 0, -- hide command line unless needed
+    completeopt = { "menu", "menuone", "noselect" }, -- Options for insert mode completion
+    copyindent = true, -- copy the previous indentation on autoindenting
+    cursorline = true, -- highlight the text line of the cursor
+    expandtab = true, -- enable the use of space in tab
+    fileencoding = "utf-8", -- file content encoding for the buffer
+    fillchars = { eob = " " }, -- disable `~` on nonexistent lines
+    foldenable = true, -- enable fold for nvim-ufo
+    foldlevel = 99, -- set high foldlevel for nvim-ufo
+    foldlevelstart = 99, -- start with all code unfolded
+    foldcolumn = vim.fn.has "nvim-0.9" == 1 and "1" or nil, -- show foldcolumn in nvim 0.9
+    history = 100, -- number of commands to remember in a history table
+    ignorecase = true, -- case insensitive searching
+    infercase = true, -- infer cases in keyword completion
+    laststatus = 3, -- global statusline
+    linebreak = true, -- wrap lines at 'breakat'
+    mouse = "a", -- enable mouse support
+    number = true, -- show numberline
+    preserveindent = true, -- preserve indent structure as much as possible
+    pumheight = 10, -- height of the pop up menu
+    relativenumber = true, -- show relative numberline
+    shiftwidth = 4, -- number of space inserted for indentation
+    showmode = false, -- disable showing modes in command line
+    showtabline = 4, -- always display tabline
+    signcolumn = "yes", -- always show the sign column
+    smartcase = true, -- case sensitive searching
+    splitbelow = true, -- splitting a new window below the current one
+    splitright = true, -- splitting a new window at the right of the current one
+    tabstop = 4, -- number of space in a tab
+    termguicolors = true, -- enable 24-bit RGB color in the TUI
+    timeoutlen = 500, -- shorten key timeout length a little bit for which-key
+    title = true, -- set terminal title to the filename and path
+    undofile = true, -- enable persistent undo
+    updatetime = 300, -- length of time to wait before triggering the plugin
+    virtualedit = "block", -- allow going past end of line in visual block mode
+    wrap = false, -- disable wrapping of lines longer than the width of window
+    writebackup = false, -- disable making a backup before overwriting a file
+  },
+  g = {
+    mapleader = " ", -- set leader key
+    maplocalleader = ",", -- set default local leader key
+    -- AstroNvim specific global options
+    max_file = { size = 1024 * 100, lines = 10000 }, -- set global limits for large files
+    autoformat_enabled = true, -- enable or disable auto formatting at start (lsp.formatting.format_on_save must be enabled)
+    autopairs_enabled = true, -- enable autopairs at start
+    cmp_enabled = true, -- enable completion at start
+    codelens_enabled = true, -- enable or disable automatic codelens refreshing for lsp that support it
+    diagnostics_mode = 3, -- set the visibility of diagnostics in the UI (0=off, 1=only show in status line, 2=virtual text off, 3=all on)
+    highlighturl_enabled = true, -- highlight URLs by default
+    icons_enabled = true, -- disable icons in the UI (disable if no nerd font is available)
+    inlay_hints_enabled = false, -- enable or disable LSP inlay hints on startup (Neovim v0.10 only)
+    lsp_handlers_enabled = true, -- enable or disable default vim.lsp.handlers (hover and signature help)
+    semantic_tokens_enabled = true, -- enable or disable LSP semantic tokens on startup
+    ui_notifications_enabled = true, -- disable notifications (TODO: rename to  notifications_enabled in AstroNvim v4)
+    git_worktrees = nil, -- enable git integration for detached worktrees (specify a table where each entry is of the form { toplevel = vim.env.HOME, gitdir=vim.env.HOME .. "/.dotfiles" })
+  },
+  t = vim.t.bufs and vim.t.bufs or { bufs = vim.api.nvim_list_bufs() }, -- initialize buffers for the current tab
+})
+
+for scope, table in pairs(options) do
+  for setting, value in pairs(table) do
+    vim[scope][setting] = value
+  end
+end
diff --git a/lua/astronvim/plugins/_astrocore.lua b/lua/astronvim/plugins/_astrocore.lua
deleted file mode 100644
index f869619..0000000
--- a/lua/astronvim/plugins/_astrocore.lua
+++ /dev/null
@@ -1,83 +0,0 @@
-local astronvim = require "astronvim"
-astronvim.init()
-
-return {
-  { "folke/lazy.nvim", dir = vim.env.LAZY },
-  {
-    "AstroNvim/AstroNvim",
-    build = function()
-      if astronvim.config.pin_plugins and astronvim.config.update_notification ~= false then
-        vim.schedule(
-          function()
-            require("astrocore").notify(
-              "Pinned versions of core plugins may have been updated\nRun `:Lazy update` again to get these updates.",
-              vim.log.levels.WARN
-            )
-          end
-        )
-      end
-    end,
-    priority = 10000,
-    lazy = false,
-  },
-  { import = "astronvim.lazy_snapshot", cond = astronvim.config.pin_plugins },
-  {
-    "AstroNvim/astrocore",
-    dependencies = { "AstroNvim/astroui" },
-    lazy = false,
-    priority = 10000,
-    opts = function(_, opts)
-      local get_icon = require("astroui").get_icon
-      return require("astrocore").extend_tbl(opts, {
-        features = {
-          large_buf = { size = 1024 * 500, lines = 10000 }, -- set global limits for large files
-          autopairs = true, -- enable autopairs at start
-          cmp = true, -- enable completion at start
-          diagnostics_mode = 3, -- enable diagnostics by default
-          highlighturl = true, -- highlight URLs by default
-          notifications = true, -- disable notifications
-        },
-        diagnostics = {
-          virtual_text = true,
-          signs = {
-            text = {
-              [vim.diagnostic.severity.ERROR] = get_icon "DiagnosticError",
-              [vim.diagnostic.severity.HINT] = get_icon "DiagnosticHint",
-              [vim.diagnostic.severity.WARN] = get_icon "DiagnosticWarn",
-              [vim.diagnostic.severity.INFO] = get_icon "DiagnosticInfo",
-            },
-          },
-          update_in_insert = true,
-          underline = true,
-          severity_sort = true,
-          float = {
-            focused = false,
-            style = "minimal",
-            border = "rounded",
-            source = "always",
-            header = "",
-            prefix = "",
-          },
-        },
-        rooter = {
-          detector = { "lsp", { ".git", "_darcs", ".hg", ".bzr", ".svn" }, { "lua", "MakeFile", "package.json" } },
-          ignore = {
-            servers = {},
-            dirs = {},
-          },
-          autochdir = false,
-          scope = "global",
-          notify = false,
-        },
-        sessions = {
-          autosave = { last = true, cwd = true },
-          ignore = {
-            dirs = {},
-            filetypes = { "gitcommit", "gitrebase" },
-            buftypes = {},
-          },
-        },
-      } --[[@as AstroCoreOpts]])
-    end,
-  },
-}
diff --git a/lua/astronvim/plugins/_astrocore_autocmds.lua b/lua/astronvim/plugins/_astrocore_autocmds.lua
deleted file mode 100644
index b58211e..0000000
--- a/lua/astronvim/plugins/_astrocore_autocmds.lua
+++ /dev/null
@@ -1,282 +0,0 @@
-return {
-  "AstroNvim/astrocore",
-  ---@type AstroCoreOpts
-  opts = {
-    commands = {
-      AstroReload = { function() require("astrocore").reload() end, desc = "Reload AstroNvim (Experimental)" },
-      AstroUpdate = { function() require("astrocore").update_packages() end, desc = "Update Lazy and Mason" },
-    },
-    autocmds = {
-      auto_quit = {
-        {
-          event = "BufEnter",
-          desc = "Quit AstroNvim if more than one window is open and only sidebar windows are list",
-          callback = function()
-            local wins = vim.api.nvim_tabpage_list_wins(0)
-            -- Both neo-tree and aerial will auto-quit if there is only a single window left
-            if #wins <= 1 then return end
-            local sidebar_fts = { aerial = true, ["neo-tree"] = true }
-            for _, winid in ipairs(wins) do
-              if vim.api.nvim_win_is_valid(winid) then
-                local bufnr = vim.api.nvim_win_get_buf(winid)
-                local filetype = vim.bo[bufnr].filetype
-                -- If any visible windows are not sidebars, early return
-                if not sidebar_fts[filetype] then
-                  return
-                -- If the visible window is a sidebar
-                else
-                  -- only count filetypes once, so remove a found sidebar from the detection
-                  sidebar_fts[filetype] = nil
-                end
-              end
-            end
-            if #vim.api.nvim_list_tabpages() > 1 then
-              vim.cmd.tabclose()
-            else
-              vim.cmd.qall()
-            end
-          end,
-        },
-      },
-      autoview = {
-        {
-          event = { "BufWinLeave", "BufWritePost", "WinLeave" },
-          desc = "Save view with mkview for real files",
-          callback = function(event)
-            if vim.b[event.buf].view_activated then vim.cmd.mkview { mods = { emsg_silent = true } } end
-          end,
-        },
-        {
-          event = "BufWinEnter",
-          desc = "Try to load file view if available and enable view saving for real files",
-          callback = function(event)
-            if not vim.b[event.buf].view_activated then
-              local filetype = vim.bo[event.buf].filetype
-              local buftype = vim.bo[event.buf].buftype
-              local ignore_filetypes = { "gitcommit", "gitrebase", "svg", "hgcommit" }
-              if buftype == "" and filetype and filetype ~= "" and not vim.tbl_contains(ignore_filetypes, filetype) then
-                vim.b[event.buf].view_activated = true
-                vim.cmd.loadview { mods = { emsg_silent = true } }
-              end
-            end
-          end,
-        },
-      },
-      bufferline = {
-        {
-          event = { "BufAdd", "BufEnter", "TabNewEntered" },
-          desc = "Update buffers when adding new buffers",
-          callback = function(args)
-            local buf_utils = require "astrocore.buffer"
-            if not vim.t.bufs then vim.t.bufs = {} end
-            if not buf_utils.is_valid(args.buf) then return end
-            if args.buf ~= buf_utils.current_buf then
-              buf_utils.last_buf = buf_utils.is_valid(buf_utils.current_buf) and buf_utils.current_buf or nil
-              buf_utils.current_buf = args.buf
-            end
-            local bufs = vim.t.bufs
-            if not vim.tbl_contains(bufs, args.buf) then
-              table.insert(bufs, args.buf)
-              vim.t.bufs = bufs
-            end
-            vim.t.bufs = vim.tbl_filter(buf_utils.is_valid, vim.t.bufs)
-            require("astrocore").event "BufsUpdated"
-          end,
-        },
-        {
-          event = { "BufDelete", "TermClose" },
-          desc = "Update buffers when deleting buffers",
-          callback = function(args)
-            local removed
-            for _, tab in ipairs(vim.api.nvim_list_tabpages()) do
-              local bufs = vim.t[tab].bufs
-              if bufs then
-                for i, bufnr in ipairs(bufs) do
-                  if bufnr == args.buf then
-                    removed = true
-                    table.remove(bufs, i)
-                    vim.t[tab].bufs = bufs
-                    break
-                  end
-                end
-              end
-            end
-            vim.t.bufs = vim.tbl_filter(require("astrocore.buffer").is_valid, vim.t.bufs)
-            if removed then require("astrocore").event "BufsUpdated" end
-            vim.cmd.redrawtabline()
-          end,
-        },
-      },
-      checktime = {
-        {
-          event = { "FocusGained", "TermClose", "TermLeave" },
-          desc = "Check if buffers changed on editor focus",
-          command = "checktime",
-        },
-      },
-      create_dir = {
-        {
-          event = "BufWritePre",
-          desc = "Automatically create parent directories if they don't exist when saving a file",
-          callback = function(args)
-            if not require("astrocore.buffer").is_valid(args.buf) then return end
-            vim.fn.mkdir(vim.fn.fnamemodify(vim.loop.fs_realpath(args.match) or args.match, ":p:h"), "p")
-          end,
-        },
-      },
-      editorconfig_filetype = {
-        {
-          event = "FileType",
-          desc = "configure editorconfig after filetype detection to override `ftplugin`s",
-          callback = function(args)
-            if vim.F.if_nil(vim.b.editorconfig, vim.g.editorconfig, true) then
-              local editorconfig_avail, editorconfig = pcall(require, "editorconfig")
-              if editorconfig_avail then editorconfig.config(args.buf) end
-            end
-          end,
-        },
-      },
-      file_user_events = {
-        {
-          event = { "BufReadPost", "BufNewFile", "BufWritePost" },
-          desc = "AstroNvim user events for file detection (AstroFile and AstroGitFile)",
-          callback = function(args)
-            if vim.b[args.buf].astrofile_checked then return end
-            vim.b[args.buf].astrofile_checked = true
-            vim.schedule(function()
-              if not vim.api.nvim_buf_is_valid(args.buf) then return end
-              local astro = require "astrocore"
-              local current_file = vim.api.nvim_buf_get_name(args.buf)
-              if vim.g.vscode or not (current_file == "" or vim.bo[args.buf].buftype == "nofile") then
-                astro.event "File"
-                local folder = vim.fn.fnamemodify(current_file, ":p:h")
-                if vim.fn.has "win32" == 1 then folder = ('"%s"'):format(folder) end
-                if vim.fn.executable "git" == 1 then
-                  if astro.cmd({ "git", "-C", folder, "rev-parse" }, false) or astro.file_worktree() then
-                    astro.event "GitFile"
-                    pcall(vim.api.nvim_del_augroup_by_name, "file_user_events")
-                  end
-                else
-                  pcall(vim.api.nvim_del_augroup_by_name, "file_user_events")
-                end
-                vim.schedule(function()
-                  if require("astrocore.buffer").is_valid(args.buf) then
-                    vim.api.nvim_exec_autocmds(args.event, { buffer = args.buf, data = args.data, modeline = false })
-                  end
-                end)
-              end
-            end)
-          end,
-        },
-      },
-      highlighturl = {
-        {
-          event = { "VimEnter", "FileType", "BufEnter", "WinEnter" },
-          desc = "URL Highlighting",
-          callback = function(args)
-            for _, win in ipairs(vim.api.nvim_list_wins()) do
-              if
-                vim.api.nvim_win_get_buf(win) == args.buf
-                and vim.tbl_get(require "astrocore", "config", "features", "highlighturl")
-                and not vim.w[win].highlighturl_enabled
-              then
-                require("astrocore").set_url_match(win)
-              end
-            end
-          end,
-        },
-        {
-          event = { "VimEnter", "User" },
-          desc = "Set up the default HighlightURL highlight group",
-          callback = function(args)
-            if args.event == "VimEnter" or args.match == "AstroColorScheme" then
-              vim.api.nvim_set_hl(0, "HighlightURL", { default = true, underline = true })
-            end
-          end,
-        },
-      },
-      highlightyank = {
-        {
-          event = "TextYankPost",
-          desc = "Highlight yanked text",
-          pattern = "*",
-          callback = function() vim.highlight.on_yank() end,
-        },
-      },
-      large_buf_settings = {
-        {
-          event = "User",
-          desc = "Disable certain functionality on very large files",
-          pattern = "AstroLargeBuf",
-          callback = function(args)
-            vim.opt_local.wrap = true -- enable wrap, long lines in vim are slow
-            vim.opt_local.list = false -- disable list chars
-            vim.b[args.buf].autoformat = false -- disable autoformat on save
-            vim.b[args.buf].cmp_enabled = false -- disable completion
-            vim.b[args.buf].miniindentscope_disable = true -- disable indent scope
-            vim.b[args.buf].matchup_matchparen_enabled = 0 -- disable vim-matchup
-            local astrocore = require "astrocore"
-            if vim.tbl_get(astrocore.config, "features", "highlighturl") then
-              astrocore.config.features.highlighturl = false
-              vim.tbl_map(function(win)
-                if vim.w[win].highlighturl_enabled then astrocore.delete_url_match(win) end
-              end, vim.api.nvim_list_wins())
-            end
-            local ibl_avail, ibl = pcall(require, "ibl") -- disable indent-blankline
-            if ibl_avail then ibl.setup_buffer(args.buf, { enabled = false }) end
-            local illuminate_avail, illuminate = pcall(require, "illuminate.engine") -- disable vim-illuminate
-            if illuminate_avail then illuminate.stop_buf(args.buf) end
-            local rainbow_avail, rainbow = pcall(require, "rainbow-delimiters") -- disable rainbow-delimiters
-            if rainbow_avail then rainbow.disable(args.buf) end
-          end,
-        },
-      },
-      q_close_windows = {
-        {
-          event = "BufWinEnter",
-          desc = "Make q close help, man, quickfix, dap floats",
-          callback = function(event)
-            if vim.tbl_contains({ "help", "nofile", "quickfix" }, vim.bo[event.buf].buftype) then
-              vim.keymap.set("n", "q", "<Cmd>close<CR>", {
-                desc = "Close window",
-                buffer = event.buf,
-                silent = true,
-                nowait = true,
-              })
-            end
-          end,
-        },
-      },
-      terminal_settings = {
-        {
-          event = "TermOpen",
-          desc = "Disable line number/fold column/sign column for terminals",
-          callback = function()
-            vim.opt_local.number = false
-            vim.opt_local.relativenumber = false
-            vim.opt_local.foldcolumn = "0"
-            vim.opt_local.signcolumn = "no"
-          end,
-        },
-      },
-      unlist_quickfix = {
-        {
-          event = "FileType",
-          desc = "Unlist quickfist buffers",
-          pattern = "qf",
-          callback = function() vim.opt_local.buflisted = false end,
-        },
-      },
-    },
-    on_keys = {
-      auto_hlsearch = {
-        function(char)
-          if vim.fn.mode() == "n" then
-            local new_hlsearch = vim.tbl_contains({ "<CR>", "n", "N", "*", "#", "?", "/" }, vim.fn.keytrans(char))
-            if vim.opt.hlsearch:get() ~= new_hlsearch then vim.opt.hlsearch = new_hlsearch end
-          end
-        end,
-      },
-    },
-  },
-}
diff --git a/lua/astronvim/plugins/_astrocore_mappings.lua b/lua/astronvim/plugins/_astrocore_mappings.lua
deleted file mode 100644
index 44facb1..0000000
--- a/lua/astronvim/plugins/_astrocore_mappings.lua
+++ /dev/null
@@ -1,149 +0,0 @@
-return {
-  "AstroNvim/astrocore",
-  ---@param opts AstroCoreOpts
-  opts = function(_, opts)
-    local astro = require "astrocore"
-    local get_icon = require("astroui").get_icon
-    -- initialize internally use mapping section titles
-    opts._map_sections = {
-      f = { desc = get_icon("Search", 1, true) .. "Find" },
-      p = { desc = get_icon("Package", 1, true) .. "Packages" },
-      l = { desc = get_icon("ActiveLSP", 1, true) .. "Language Tools" },
-      u = { desc = get_icon("Window", 1, true) .. "UI/UX" },
-      b = { desc = get_icon("Tab", 1, true) .. "Buffers" },
-      bs = { desc = get_icon("Sort", 1, true) .. "Sort Buffers" },
-      d = { desc = get_icon("Debugger", 1, true) .. "Debugger" },
-      g = { desc = get_icon("Git", 1, true) .. "Git" },
-      S = { desc = get_icon("Session", 1, true) .. "Session" },
-      t = { desc = get_icon("Terminal", 1, true) .. "Terminal" },
-    }
-
-    -- initialize mappings table
-    local maps = astro.empty_map_table()
-    local sections = assert(opts._map_sections)
-
-    -- Normal --
-    -- Standard Operations
-    maps.n["j"] = { "v:count == 0 ? 'gj' : 'j'", expr = true, silent = true, desc = "Move cursor down" }
-    maps.x["j"] = maps.n["j"]
-    maps.n["k"] = { "v:count == 0 ? 'gk' : 'k'", expr = true, silent = true, desc = "Move cursor up" }
-    maps.x["k"] = maps.n["k"]
-    maps.n["<Leader>w"] = { "<Cmd>w<CR>", desc = "Save" }
-    maps.n["<Leader>q"] = { "<Cmd>confirm q<CR>", desc = "Quit Window" }
-    maps.n["<Leader>Q"] = { "<Cmd>confirm qall<CR>", desc = "Exit AstroNvim" }
-    maps.n["<Leader>n"] = { "<Cmd>enew<CR>", desc = "New File" }
-    maps.n["<C-S>"] = { "<Cmd>silent! update! | redraw<CR>", desc = "Force write" }
-    -- TODO: AstroNvim v5, remove <C-S> outside of normal mode to not conflict with default signature help
-    maps.i["<C-S>"] = { "<Esc>" .. maps.n["<C-S>"][1], desc = maps.n["<C-S>"].desc }
-    maps.x["<C-S>"] = maps.i["<C-s>"]
-    maps.n["<C-Q>"] = { "<Cmd>q!<CR>", desc = "Force quit" }
-    maps.n["|"] = { "<Cmd>vsplit<CR>", desc = "Vertical Split" }
-    maps.n["\\"] = { "<Cmd>split<CR>", desc = "Horizontal Split" }
-    -- TODO: remove deprecated method check after dropping support for neovim v0.9
-    if not vim.ui.open then
-      maps.n["gx"] = { astro.system_open, desc = "Open the file under cursor with system app" }
-    end
-
-    -- Plugin Manager
-    maps.n["<Leader>p"] = vim.tbl_get(sections, "p")
-    maps.n["<Leader>pi"] = { function() require("lazy").install() end, desc = "Plugins Install" }
-    maps.n["<Leader>ps"] = { function() require("lazy").home() end, desc = "Plugins Status" }
-    maps.n["<Leader>pS"] = { function() require("lazy").sync() end, desc = "Plugins Sync" }
-    maps.n["<Leader>pu"] = { function() require("lazy").check() end, desc = "Plugins Check Updates" }
-    maps.n["<Leader>pU"] = { function() require("lazy").update() end, desc = "Plugins Update" }
-    maps.n["<Leader>pa"] = { function() require("astrocore").update_packages() end, desc = "Update Lazy and Mason" }
-
-    -- Manage Buffers
-    maps.n["<Leader>c"] = { function() require("astrocore.buffer").close() end, desc = "Close buffer" }
-    maps.n["<Leader>C"] = { function() require("astrocore.buffer").close(0, true) end, desc = "Force close buffer" }
-    maps.n["]b"] = {
-      function() require("astrocore.buffer").nav(vim.v.count1) end,
-      desc = "Next buffer",
-    }
-    maps.n["[b"] = {
-      function() require("astrocore.buffer").nav(-vim.v.count1) end,
-      desc = "Previous buffer",
-    }
-    maps.n[">b"] = {
-      function() require("astrocore.buffer").move(vim.v.count1) end,
-      desc = "Move buffer tab right",
-    }
-    maps.n["<b"] = {
-      function() require("astrocore.buffer").move(-vim.v.count1) end,
-      desc = "Move buffer tab left",
-    }
-
-    maps.n["<Leader>b"] = vim.tbl_get(sections, "b")
-    maps.n["<Leader>bc"] =
-      { function() require("astrocore.buffer").close_all(true) end, desc = "Close all buffers except current" }
-    maps.n["<Leader>bC"] = { function() require("astrocore.buffer").close_all() end, desc = "Close all buffers" }
-    maps.n["<Leader>bl"] =
-      { function() require("astrocore.buffer").close_left() end, desc = "Close all buffers to the left" }
-    maps.n["<Leader>bp"] = { function() require("astrocore.buffer").prev() end, desc = "Previous buffer" }
-    maps.n["<Leader>br"] =
-      { function() require("astrocore.buffer").close_right() end, desc = "Close all buffers to the right" }
-    maps.n["<Leader>bs"] = vim.tbl_get(sections, "bs")
-    maps.n["<Leader>bse"] = { function() require("astrocore.buffer").sort "extension" end, desc = "By extension" }
-    maps.n["<Leader>bsr"] = { function() require("astrocore.buffer").sort "unique_path" end, desc = "By relative path" }
-    maps.n["<Leader>bsp"] = { function() require("astrocore.buffer").sort "full_path" end, desc = "By full path" }
-    maps.n["<Leader>bsi"] = { function() require("astrocore.buffer").sort "bufnr" end, desc = "By buffer number" }
-    maps.n["<Leader>bsm"] = { function() require("astrocore.buffer").sort "modified" end, desc = "By modification" }
-
-    maps.n["<Leader>l"] = vim.tbl_get(sections, "l")
-    maps.n["<Leader>ld"] = { function() vim.diagnostic.open_float() end, desc = "Hover diagnostics" }
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.n["[d"] = { function() vim.diagnostic.goto_prev() end, desc = "Previous diagnostic" }
-      maps.n["]d"] = { function() vim.diagnostic.goto_next() end, desc = "Next diagnostic" }
-      maps.n["<C-W>d"] = { function() vim.diagnostic.open_float() end, desc = "Hover diagnostics" }
-    end
-    maps.n["gl"] = { function() vim.diagnostic.open_float() end, desc = "Hover diagnostics" }
-
-    -- Navigate tabs
-    maps.n["]t"] = { function() vim.cmd.tabnext() end, desc = "Next tab" }
-    maps.n["[t"] = { function() vim.cmd.tabprevious() end, desc = "Previous tab" }
-
-    -- Split navigation
-    maps.n["<C-H>"] = { "<C-w>h", desc = "Move to left split" }
-    maps.n["<C-J>"] = { "<C-w>j", desc = "Move to below split" }
-    maps.n["<C-K>"] = { "<C-w>k", desc = "Move to above split" }
-    maps.n["<C-L>"] = { "<C-w>l", desc = "Move to right split" }
-    maps.n["<C-Up>"] = { "<Cmd>resize -2<CR>", desc = "Resize split up" }
-    maps.n["<C-Down>"] = { "<Cmd>resize +2<CR>", desc = "Resize split down" }
-    maps.n["<C-Left>"] = { "<Cmd>vertical resize -2<CR>", desc = "Resize split left" }
-    maps.n["<C-Right>"] = { "<Cmd>vertical resize +2<CR>", desc = "Resize split right" }
-
-    -- Stay in indent mode
-    maps.v["<S-Tab>"] = { "<gv", desc = "Unindent line" }
-    maps.v["<Tab>"] = { ">gv", desc = "Indent line" }
-
-    -- Improved Terminal Navigation
-    maps.t["<C-H>"] = { "<Cmd>wincmd h<CR>", desc = "Terminal left window navigation" }
-    maps.t["<C-J>"] = { "<Cmd>wincmd j<CR>", desc = "Terminal down window navigation" }
-    maps.t["<C-K>"] = { "<Cmd>wincmd k<CR>", desc = "Terminal up window navigation" }
-    maps.t["<C-L>"] = { "<Cmd>wincmd l<CR>", desc = "Terminal right window navigation" }
-
-    maps.n["<Leader>u"] = vim.tbl_get(sections, "u")
-    -- Custom menu for modification of the user experience
-    maps.n["<Leader>uA"] = { function() require("astrocore.toggles").autochdir() end, desc = "Toggle rooter autochdir" }
-    maps.n["<Leader>ub"] = { function() require("astrocore.toggles").background() end, desc = "Toggle background" }
-    maps.n["<Leader>ud"] = { function() require("astrocore.toggles").diagnostics() end, desc = "Toggle diagnostics" }
-    maps.n["<Leader>ug"] = { function() require("astrocore.toggles").signcolumn() end, desc = "Toggle signcolumn" }
-    maps.n["<Leader>u>"] = { function() require("astrocore.toggles").foldcolumn() end, desc = "Toggle foldcolumn" }
-    maps.n["<Leader>ui"] = { function() require("astrocore.toggles").indent() end, desc = "Change indent setting" }
-    maps.n["<Leader>ul"] = { function() require("astrocore.toggles").statusline() end, desc = "Toggle statusline" }
-    maps.n["<Leader>un"] = { function() require("astrocore.toggles").number() end, desc = "Change line numbering" }
-    maps.n["<Leader>uN"] =
-      { function() require("astrocore.toggles").notifications() end, desc = "Toggle Notifications" }
-    maps.n["<Leader>up"] = { function() require("astrocore.toggles").paste() end, desc = "Toggle paste mode" }
-    maps.n["<Leader>us"] = { function() require("astrocore.toggles").spell() end, desc = "Toggle spellcheck" }
-    maps.n["<Leader>uS"] = { function() require("astrocore.toggles").conceal() end, desc = "Toggle conceal" }
-    maps.n["<Leader>ut"] = { function() require("astrocore.toggles").tabline() end, desc = "Toggle tabline" }
-    maps.n["<Leader>uu"] = { function() require("astrocore.toggles").url_match() end, desc = "Toggle URL highlight" }
-    maps.n["<Leader>uw"] = { function() require("astrocore.toggles").wrap() end, desc = "Toggle wrap" }
-    maps.n["<Leader>uy"] =
-      { function() require("astrocore.toggles").buffer_syntax() end, desc = "Toggle syntax highlight" }
-
-    opts.mappings = maps
-  end,
-}
diff --git a/lua/astronvim/plugins/_astrocore_options.lua b/lua/astronvim/plugins/_astrocore_options.lua
deleted file mode 100644
index 0d4a17d..0000000
--- a/lua/astronvim/plugins/_astrocore_options.lua
+++ /dev/null
@@ -1,57 +0,0 @@
-return {
-  "AstroNvim/astrocore",
-  ---@param opts AstroCoreOpts
-  opts = function(_, opts)
-    local opt = {}
-    opt.backspace = vim.list_extend(vim.opt.backspace:get(), { "nostop" }) -- don't stop backspace at insert
-    opt.breakindent = true -- wrap indent to match  line start
-    opt.clipboard = "unnamedplus" -- connection to the system clipboard
-    opt.cmdheight = 0 -- hide command line unless needed
-    opt.completeopt = { "menu", "menuone", "noselect" } -- Options for insert mode completion
-    opt.confirm = true -- raise a dialog asking if you wish to save the current file(s)
-    opt.copyindent = true -- copy the previous indentation on autoindenting
-    opt.cursorline = true -- highlight the text line of the cursor
-    opt.diffopt = vim.list_extend(vim.opt.diffopt:get(), { "algorithm:histogram", "linematch:60" }) -- enable linematch diff algorithm
-    opt.expandtab = true -- enable the use of space in tab
-    opt.fileencoding = "utf-8" -- file content encoding for the buffer
-    opt.fillchars = { eob = " " } -- disable `~` on nonexistent lines
-    opt.foldcolumn = "1" -- show foldcolumn
-    opt.foldenable = true -- enable fold for nvim-ufo
-    opt.foldlevel = 99 -- set high foldlevel for nvim-ufo
-    opt.foldlevelstart = 99 -- start with all code unfolded
-    opt.history = 100 -- number of commands to remember in a history table
-    opt.ignorecase = true -- case insensitive searching
-    opt.infercase = true -- infer cases in keyword completion
-    opt.laststatus = 3 -- global statusline
-    opt.linebreak = true -- wrap lines at 'breakat'
-    opt.mouse = "a" -- enable mouse support
-    opt.number = true -- show numberline
-    opt.preserveindent = true -- preserve indent structure as much as possible
-    opt.pumheight = 10 -- height of the pop up menu
-    opt.relativenumber = true -- show relative numberline
-    opt.shiftwidth = 2 -- number of space inserted for indentation
-    opt.shortmess = vim.tbl_deep_extend("force", vim.opt.shortmess:get(), { s = true, I = true }) -- disable search count wrap and startup messages
-    opt.showmode = false -- disable showing modes in command line
-    opt.showtabline = 2 -- always display tabline
-    opt.signcolumn = "yes" -- always show the sign column
-    opt.smartcase = true -- case sensitive searching
-    opt.splitbelow = true -- splitting a new window below the current one
-    opt.splitright = true -- splitting a new window at the right of the current one
-    opt.tabstop = 2 -- number of space in a tab
-    opt.termguicolors = true -- enable 24-bit RGB color in the TUI
-    opt.timeoutlen = 500 -- shorten key timeout length a little bit for which-key
-    opt.title = true -- set terminal title to the filename and path
-    opt.undofile = true -- enable persistent undo
-    opt.updatetime = 300 -- length of time to wait before triggering the plugin
-    opt.viewoptions = vim.tbl_filter(function(val) return val ~= "curdir" end, vim.opt.viewoptions:get())
-    opt.virtualedit = "block" -- allow going past end of line in visual block mode
-    opt.wrap = false -- disable wrapping of lines longer than the width of window
-    opt.writebackup = false -- disable making a backup before overwriting a file
-
-    local g = {}
-    g.markdown_recommended_style = 0
-
-    if not vim.t.bufs then vim.t.bufs = vim.api.nvim_list_bufs() end -- initialize buffer list
-    opts.options = { opt = opt, g = g, t = { bufs = vim.t.bufs } }
-  end,
-}
diff --git a/lua/astronvim/plugins/_astrolsp.lua b/lua/astronvim/plugins/_astrolsp.lua
deleted file mode 100644
index 7818a79..0000000
--- a/lua/astronvim/plugins/_astrolsp.lua
+++ /dev/null
@@ -1,29 +0,0 @@
-return {
-  "AstroNvim/astrolsp",
-  lazy = true,
-  opts = function(_, opts)
-    return require("astrocore").extend_tbl(opts, {
-      features = {
-        codelens = true,
-        inlay_hints = false,
-        lsp_handlers = true,
-        semantic_tokens = true,
-      },
-      capabilities = vim.lsp.protocol.make_client_capabilities(),
-      ---@diagnostic disable-next-line: missing-fields
-      config = { lua_ls = { settings = { Lua = { workspace = { checkThirdParty = false } } } } },
-      flags = {},
-      formatting = { format_on_save = { enabled = true }, disabled = {} },
-      handlers = { function(server, server_opts) require("lspconfig")[server].setup(server_opts) end },
-      lsp_handlers = {
-        ["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, { border = "rounded", silent = true }),
-        ["textDocument/signatureHelp"] = vim.lsp.with(
-          vim.lsp.handlers.signature_help,
-          { border = "rounded", silent = true }
-        ),
-      },
-      servers = {},
-      on_attach = nil,
-    } --[[@as AstroLSPOpts]])
-  end,
-}
diff --git a/lua/astronvim/plugins/_astrolsp_autocmds.lua b/lua/astronvim/plugins/_astrolsp_autocmds.lua
deleted file mode 100644
index 7430aa9..0000000
--- a/lua/astronvim/plugins/_astrolsp_autocmds.lua
+++ /dev/null
@@ -1,48 +0,0 @@
-local formatting_enabled = function(client)
-  local formatting_disabled = vim.tbl_get(require("astrolsp").config, "formatting", "disabled")
-  return client.supports_method "textDocument/formatting"
-    and formatting_disabled ~= true
-    and not vim.tbl_contains(formatting_disabled, client.name)
-end
-
-return {
-  "AstroNvim/astrolsp",
-  ---@type AstroLSPOpts
-  opts = {
-    commands = {
-      Format = {
-        cond = formatting_enabled,
-        function() vim.lsp.buf.format(require("astrolsp").format_opts) end,
-        desc = "Format file with LSP",
-      },
-    },
-    autocmds = {
-      lsp_codelens_refresh = {
-        cond = "textDocument/codeLens",
-        {
-          event = { "InsertLeave", "BufEnter" },
-          desc = "Refresh codelens (buffer)",
-          callback = function(args)
-            if require("astrolsp").config.features.codelens then vim.lsp.codelens.refresh { bufnr = args.buf } end
-          end,
-        },
-      },
-      lsp_auto_format = {
-        cond = formatting_enabled,
-        {
-          event = "BufWritePre",
-          desc = "autoformat on save",
-          callback = function(_, _, bufnr)
-            local astrolsp = require "astrolsp"
-            local autoformat = assert(astrolsp.config.formatting.format_on_save)
-            local buffer_autoformat = vim.b[bufnr].autoformat
-            if buffer_autoformat == nil then buffer_autoformat = autoformat.enabled end
-            if buffer_autoformat and ((not autoformat.filter) or autoformat.filter(bufnr)) then
-              vim.lsp.buf.format(vim.tbl_deep_extend("force", astrolsp.format_opts, { bufnr = bufnr }))
-            end
-          end,
-        },
-      },
-    },
-  },
-}
diff --git a/lua/astronvim/plugins/_astrolsp_mappings.lua b/lua/astronvim/plugins/_astrolsp_mappings.lua
deleted file mode 100644
index b48b200..0000000
--- a/lua/astronvim/plugins/_astrolsp_mappings.lua
+++ /dev/null
@@ -1,130 +0,0 @@
-return {
-  "AstroNvim/astrolsp",
-  ---@param opts AstroLSPOpts
-  opts = function(_, opts)
-    local maps = require("astrocore").empty_map_table()
-    maps.v["<Leader>l"] = { desc = require("astroui").get_icon("ActiveLSP", 1, true) .. "Language Tools" }
-
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.n["crr"] = {
-        function() vim.lsp.buf.code_action() end,
-        desc = "LSP code action",
-        cond = "testDocument/codeAction", -- LSP client capability string
-      }
-      maps.v["<C-R>r"] = maps.n["crr"]
-      maps.v["<C-R><C-R>"] = maps.n["<C-R>r"]
-    end
-    maps.n["<Leader>la"] = {
-      function() vim.lsp.buf.code_action() end,
-      desc = "LSP code action",
-      cond = "testDocument/codeAction", -- LSP client capability string
-    }
-    maps.v["<Leader>la"] = maps.n["<Leader>la"]
-
-    maps.n["<Leader>ll"] =
-      { function() vim.lsp.codelens.refresh() end, desc = "LSP CodeLens refresh", cond = "textDocument/codeLens" }
-    maps.n["<Leader>lL"] =
-      { function() vim.lsp.codelens.run() end, desc = "LSP CodeLens run", cond = "textDocument/codeLens" }
-    maps.n["<Leader>uL"] = {
-      function() require("astrolsp.toggles").codelens() end,
-      desc = "Toggle CodeLens",
-      cond = "textDocument/codeLens",
-    }
-
-    maps.n["gD"] = {
-      function() vim.lsp.buf.declaration() end,
-      desc = "Declaration of current symbol",
-      cond = "textDocument/declaration",
-    }
-    maps.n["gd"] = {
-      function() vim.lsp.buf.definition() end,
-      desc = "Show the definition of current symbol",
-      cond = "textDocument/definition",
-    }
-
-    local formatting_enabled = function(client)
-      local disabled = opts.formatting.disabled
-      return client.supports_method "textDocument/formatting"
-        and disabled ~= true
-        and not vim.tbl_contains(disabled, client.name)
-    end
-    maps.n["<Leader>lf"] = {
-      function() vim.lsp.buf.format(require("astrolsp").format_opts) end,
-      desc = "Format buffer",
-      cond = formatting_enabled,
-    }
-    maps.v["<Leader>lf"] = maps.n["<Leader>lf"]
-    maps.n["<Leader>uf"] = {
-      function() require("astrolsp.toggles").buffer_autoformat() end,
-      desc = "Toggle autoformatting (buffer)",
-      cond = formatting_enabled,
-    }
-    maps.n["<Leader>uF"] = {
-      function() require("astrolsp.toggles").autoformat() end,
-      desc = "Toggle autoformatting (global)",
-      cond = formatting_enabled,
-    }
-
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.n["K"] = { function() vim.lsp.buf.hover() end, desc = "Hover symbol details", cond = "textDocument/hover" }
-    end
-
-    maps.n["gI"] = {
-      function() vim.lsp.buf.implementation() end,
-      desc = "Implementation of current symbol",
-      cond = "textDocument/implementation",
-    }
-
-    maps.n["<Leader>uh"] = {
-      function() require("astrolsp.toggles").buffer_inlay_hints() end,
-      desc = "Toggle LSP inlay hints (buffer)",
-      cond = vim.lsp.inlay_hint and "textDocument/inlayHint" or false,
-    }
-
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.n["gr"] = {
-        function() vim.lsp.buf.references() end,
-        desc = "References of current symbol",
-        cond = "textDocument/references",
-      }
-    end
-    maps.n["<Leader>lR"] =
-      { function() vim.lsp.buf.references() end, desc = "Search references", cond = "textDocument/references" }
-
-    maps.n["<Leader>lr"] =
-      { function() vim.lsp.buf.rename() end, desc = "Rename current symbol", cond = "textDocument/rename" }
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.n["crn"] =
-        { function() vim.lsp.buf.rename() end, desc = "Rename current symbol", cond = "textDocument/rename" }
-    end
-
-    maps.n["<Leader>lh"] =
-      { function() vim.lsp.buf.signature_help() end, desc = "Signature help", cond = "textDocument/signatureHelp" }
-    maps.n["gK"] = maps.n["<Leader>lh"]
-    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
-    if vim.fn.has "nvim-0.10" == 0 then
-      maps.i["<C-S>"] =
-        { function() vim.lsp.buf.signature_help() end, desc = "Signature help", cond = "textDocument/signatureHelp" }
-    end
-
-    maps.n["gy"] = {
-      function() vim.lsp.buf.type_definition() end,
-      desc = "Definition of current type",
-      cond = "textDocument/typeDefinition",
-    }
-
-    maps.n["<Leader>lG"] =
-      { function() vim.lsp.buf.workspace_symbol() end, desc = "Search workspace symbols", cond = "workspace/symbol" }
-
-    maps.n["<Leader>uY"] = {
-      function() require("astrolsp.toggles").buffer_semantic_tokens() end,
-      desc = "Toggle LSP semantic highlight (buffer)",
-      cond = function(client) return client.server_capabilities.semanticTokensProvider and vim.lsp.semantic_tokens end,
-    }
-    opts.mappings = require("astrocore").extend_tbl(opts.mappings, maps)
-  end,
-}
diff --git a/lua/astronvim/plugins/_astrotheme.lua b/lua/astronvim/plugins/_astrotheme.lua
deleted file mode 100644
index 7125b50..0000000
--- a/lua/astronvim/plugins/_astrotheme.lua
+++ /dev/null
@@ -1 +0,0 @@
-return { "AstroNvim/astrotheme", lazy = true, opts = { plugins = { ["dashboard-nvim"] = true } } }
diff --git a/lua/astronvim/plugins/_astroui.lua b/lua/astronvim/plugins/_astroui.lua
deleted file mode 100644
index 6afc0fc..0000000
--- a/lua/astronvim/plugins/_astroui.lua
+++ /dev/null
@@ -1,110 +0,0 @@
-return {
-  "AstroNvim/astroui",
-  lazy = true,
-  ---@type AstroUIOpts
-  opts = {
-    colorscheme = "astrodark",
-    icons = {
-      ActiveLSP = "",
-      ActiveTS = "",
-      ArrowLeft = "",
-      ArrowRight = "",
-      Bookmarks = "",
-      BufferClose = "󰅖",
-      DapBreakpoint = "",
-      DapBreakpointCondition = "",
-      DapBreakpointRejected = "",
-      DapLogPoint = ".>",
-      DapStopped = "󰁕",
-      Debugger = "",
-      DefaultFile = "󰈙",
-      Diagnostic = "󰒡",
-      DiagnosticError = "",
-      DiagnosticHint = "󰌵",
-      DiagnosticInfo = "󰋼",
-      DiagnosticWarn = "",
-      Ellipsis = "…",
-      Environment = "",
-      FileNew = "",
-      FileModified = "",
-      FileReadOnly = "",
-      FoldClosed = "",
-      FoldOpened = "",
-      FoldSeparator = " ",
-      FolderClosed = "",
-      FolderEmpty = "",
-      FolderOpen = "",
-      Git = "󰊢",
-      GitAdd = "",
-      GitBranch = "",
-      GitChange = "",
-      GitConflict = "",
-      GitDelete = "",
-      GitIgnored = "◌",
-      GitRenamed = "➜",
-      GitSign = "▎",
-      GitStaged = "✓",
-      GitUnstaged = "✗",
-      GitUntracked = "★",
-      LSPLoading1 = "",
-      LSPLoading2 = "󰀚",
-      LSPLoading3 = "",
-      MacroRecording = "",
-      Package = "󰏖",
-      Paste = "󰅌",
-      Refresh = "",
-      Search = "",
-      Selected = "❯",
-      Session = "󱂬",
-      Sort = "󰒺",
-      Spellcheck = "󰓆",
-      Tab = "󰓩",
-      TabClose = "󰅙",
-      Terminal = "",
-      Window = "",
-      WordFile = "󰈭",
-    },
-    text_icons = {
-      ActiveLSP = "LSP:",
-      ArrowLeft = "<",
-      ArrowRight = ">",
-      BufferClose = "x",
-      DapBreakpoint = "B",
-      DapBreakpointCondition = "C",
-      DapBreakpointRejected = "R",
-      DapLogPoint = "L",
-      DapStopped = ">",
-      DefaultFile = "[F]",
-      DiagnosticError = "X",
-      DiagnosticHint = "?",
-      DiagnosticInfo = "i",
-      DiagnosticWarn = "!",
-      Ellipsis = "...",
-      Environment = "Env:",
-      FileModified = "*",
-      FileReadOnly = "[lock]",
-      FoldClosed = "+",
-      FoldOpened = "-",
-      FoldSeparator = " ",
-      FolderClosed = "[D]",
-      FolderEmpty = "[E]",
-      FolderOpen = "[O]",
-      GitAdd = "[+]",
-      GitChange = "[/]",
-      GitConflict = "[!]",
-      GitDelete = "[-]",
-      GitIgnored = "[I]",
-      GitRenamed = "[R]",
-      GitSign = "|",
-      GitStaged = "[S]",
-      GitUnstaged = "[U]",
-      GitUntracked = "[?]",
-      MacroRecording = "Recording:",
-      Paste = "[PASTE]",
-      Search = "?",
-      Selected = "*",
-      Spellcheck = "[SPELL]",
-      TabClose = "X",
-    },
-  },
-}
diff --git a/lua/astronvim/plugins/_astroui_status.lua b/lua/astronvim/plugins/_astroui_status.lua
deleted file mode 100644
index 510e639..0000000
--- a/lua/astronvim/plugins/_astroui_status.lua
+++ /dev/null
@@ -1,241 +0,0 @@
-return {
-  "AstroNvim/astroui",
-  ---@param opts AstroUIOpts
-  opts = function(_, opts)
-    local sign_handlers = {}
-    -- gitsigns handlers
-    local gitsigns_handler = function(_)
-      local gitsigns_avail, gitsigns = pcall(require, "gitsigns")
-      if gitsigns_avail then vim.schedule(gitsigns.preview_hunk) end
-    end
-    for _, sign in ipairs { "Topdelete", "Untracked", "Add", "Change", "Changedelete", "Delete" } do
-      local name = "GitSigns" .. sign
-      if not sign_handlers[name] then sign_handlers[name] = gitsigns_handler end
-    end
-    sign_handlers["gitsigns_extmark_signs_"] = gitsigns_handler
-    -- diagnostic handlers
-    local diagnostics_handler = function(args)
-      if args.mods:find "c" then
-        vim.schedule(vim.lsp.buf.code_action)
-      else
-        vim.schedule(vim.diagnostic.open_float)
-      end
-    end
-    for _, sign in ipairs { "Error", "Hint", "Info", "Warn" } do
-      local name = "DiagnosticSign" .. sign
-      if not sign_handlers[name] then sign_handlers[name] = diagnostics_handler end
-    end
-    -- DAP handlers
-    local dap_breakpoint_handler = function(_)
-      local dap_avail, dap = pcall(require, "dap")
-      if dap_avail then vim.schedule(dap.toggle_breakpoint) end
-    end
-    for _, sign in ipairs { "", "Rejected", "Condition" } do
-      local name = "DapBreakpoint" .. sign
-      if not sign_handlers[name] then sign_handlers[name] = dap_breakpoint_handler end
-    end
-
-    opts.status = {
-      fallback_colors = {
-        none = "NONE",
-        fg = "#abb2bf",
-        bg = "#1e222a",
-        dark_bg = "#2c323c",
-        blue = "#61afef",
-        green = "#98c379",
-        grey = "#5c6370",
-        bright_grey = "#777d86",
-        dark_grey = "#5c5c5c",
-        orange = "#ff9640",
-        purple = "#c678dd",
-        bright_purple = "#a9a1e1",
-        red = "#e06c75",
-        bright_red = "#ec5f67",
-        white = "#c9c9c9",
-        yellow = "#e5c07b",
-        bright_yellow = "#ebae34",
-      },
-      modes = {
-        ["n"] = { "NORMAL", "normal" },
-        ["no"] = { "OP", "normal" },
-        ["nov"] = { "OP", "normal" },
-        ["noV"] = { "OP", "normal" },
-        ["no"] = { "OP", "normal" },
-        ["niI"] = { "NORMAL", "normal" },
-        ["niR"] = { "NORMAL", "normal" },
-        ["niV"] = { "NORMAL", "normal" },
-        ["i"] = { "INSERT", "insert" },
-        ["ic"] = { "INSERT", "insert" },
-        ["ix"] = { "INSERT", "insert" },
-        ["t"] = { "TERM", "terminal" },
-        ["nt"] = { "TERM", "terminal" },
-        ["v"] = { "VISUAL", "visual" },
-        ["vs"] = { "VISUAL", "visual" },
-        ["V"] = { "LINES", "visual" },
-        ["Vs"] = { "LINES", "visual" },
-        [""] = { "BLOCK", "visual" },
-        ["s"] = { "BLOCK", "visual" },
-        ["R"] = { "REPLACE", "replace" },
-        ["Rc"] = { "REPLACE", "replace" },
-        ["Rx"] = { "REPLACE", "replace" },
-        ["Rv"] = { "V-REPLACE", "replace" },
-        ["s"] = { "SELECT", "visual" },
-        ["S"] = { "SELECT", "visual" },
-        [""] = { "BLOCK", "visual" },
-        ["c"] = { "COMMAND", "command" },
-        ["cv"] = { "COMMAND", "command" },
-        ["ce"] = { "COMMAND", "command" },
-        ["r"] = { "PROMPT", "inactive" },
-        ["rm"] = { "MORE", "inactive" },
-        ["r?"] = { "CONFIRM", "inactive" },
-        ["!"] = { "SHELL", "inactive" },
-        ["null"] = { "null", "inactive" },
-      },
-      separators = {
-        none = { "", "" },
-        left = { "", "  " },
-        right = { "  ", "" },
-        center = { "  ", "  " },
-        tab = { "", " " },
-        breadcrumbs = "  ",
-        path = "  ",
-      },
-      attributes = {
-        buffer_active = { bold = true, italic = true },
-        buffer_picker = { bold = true },
-        macro_recording = { bold = true },
-        git_branch = { bold = true },
-        git_diff = { bold = true },
-        virtual_env = { bold = true },
-      },
-      icon_highlights = {
-        file_icon = {
-          tabline = function(self) return self.is_active or self.is_visible end,
-          statusline = true,
-        },
-      },
-      sign_handlers = sign_handlers,
-      setup_colors = function()
-        local astroui = require "astroui"
-        ---@type AstroUIStatusOpts
-        local status_opts = astroui.config.status
-        local color = assert(status_opts.fallback_colors)
-        local get_hlgroup = astroui.get_hlgroup
-        local lualine_mode = require("astroui.status.hl").lualine_mode
-        local function resolve_lualine(orig, ...) return (not orig or orig == "NONE") and lualine_mode(...) or orig end
-
-        local Normal = get_hlgroup("Normal", { fg = color.fg, bg = color.bg })
-        local Comment = get_hlgroup("Comment", { fg = color.bright_grey, bg = color.bg })
-        local Error = get_hlgroup("Error", { fg = color.red, bg = color.bg })
-        local StatusLine = get_hlgroup("StatusLine", { fg = color.fg, bg = color.dark_bg })
-        local TabLine = get_hlgroup("TabLine", { fg = color.grey, bg = color.none })
-        local TabLineFill = get_hlgroup("TabLineFill", { fg = color.fg, bg = color.dark_bg })
-        local TabLineSel = get_hlgroup("TabLineSel", { fg = color.fg, bg = color.none })
-        local WinBar = get_hlgroup("WinBar", { fg = color.bright_grey, bg = color.bg })
-        local WinBarNC = get_hlgroup("WinBarNC", { fg = color.grey, bg = color.bg })
-        local Conditional = get_hlgroup("Conditional", { fg = color.bright_purple, bg = color.dark_bg })
-        local String = get_hlgroup("String", { fg = color.green, bg = color.dark_bg })
-        local TypeDef = get_hlgroup("TypeDef", { fg = color.yellow, bg = color.dark_bg })
-        local NvimEnvironmentName = get_hlgroup("NvimEnvironmentName", { fg = color.yellow, bg = color.dark_bg })
-        local GitSignsAdd = get_hlgroup("GitSignsAdd", { fg = color.green, bg = color.dark_bg })
-        local GitSignsChange = get_hlgroup("GitSignsChange", { fg = color.orange, bg = color.dark_bg })
-        local GitSignsDelete = get_hlgroup("GitSignsDelete", { fg = color.bright_red, bg = color.dark_bg })
-        local DiagnosticError = get_hlgroup("DiagnosticError", { fg = color.bright_red, bg = color.dark_bg })
-        local DiagnosticWarn = get_hlgroup("DiagnosticWarn", { fg = color.orange, bg = color.dark_bg })
-        local DiagnosticInfo = get_hlgroup("DiagnosticInfo", { fg = color.white, bg = color.dark_bg })
-        local DiagnosticHint = get_hlgroup("DiagnosticHint", { fg = color.bright_yellow, bg = color.dark_bg })
-        local HeirlineInactive =
-          resolve_lualine(get_hlgroup("HeirlineInactive", { bg = nil }).bg, "inactive", color.dark_grey)
-        local HeirlineNormal = resolve_lualine(get_hlgroup("HeirlineNormal", { bg = nil }).bg, "normal", color.blue)
-        local HeirlineInsert = resolve_lualine(get_hlgroup("HeirlineInsert", { bg = nil }).bg, "insert", color.green)
-        local HeirlineVisual = resolve_lualine(get_hlgroup("HeirlineVisual", { bg = nil }).bg, "visual", color.purple)
-        local HeirlineReplace =
-          resolve_lualine(get_hlgroup("HeirlineReplace", { bg = nil }).bg, "replace", color.bright_red)
-        local HeirlineCommand =
-          resolve_lualine(get_hlgroup("HeirlineCommand", { bg = nil }).bg, "command", color.bright_yellow)
-        local HeirlineTerminal =
-          resolve_lualine(get_hlgroup("HeirlineTerminal", { bg = nil }).bg, "insert", HeirlineInsert)
-
-        local colors = {
-          close_fg = Error.fg,
-          fg = StatusLine.fg,
-          bg = StatusLine.bg,
-          section_fg = StatusLine.fg,
-          section_bg = StatusLine.bg,
-          git_branch_fg = Conditional.fg,
-          mode_fg = StatusLine.bg,
-          treesitter_fg = String.fg,
-          virtual_env_fg = NvimEnvironmentName.fg,
-          scrollbar = TypeDef.fg,
-          git_added = GitSignsAdd.fg,
-          git_changed = GitSignsChange.fg,
-          git_removed = GitSignsDelete.fg,
-          diag_ERROR = DiagnosticError.fg,
-          diag_WARN = DiagnosticWarn.fg,
-          diag_INFO = DiagnosticInfo.fg,
-          diag_HINT = DiagnosticHint.fg,
-          winbar_fg = WinBar.fg,
-          winbar_bg = WinBar.bg,
-          winbarnc_fg = WinBarNC.fg,
-          winbarnc_bg = WinBarNC.bg,
-          tabline_bg = TabLineFill.bg,
-          tabline_fg = TabLineFill.bg,
-          buffer_fg = Comment.fg,
-          buffer_path_fg = WinBarNC.fg,
-          buffer_close_fg = Comment.fg,
-          buffer_bg = TabLineFill.bg,
-          buffer_active_fg = Normal.fg,
-          buffer_active_path_fg = WinBarNC.fg,
-          buffer_active_close_fg = Error.fg,
-          buffer_active_bg = Normal.bg,
-          buffer_visible_fg = Normal.fg,
-          buffer_visible_path_fg = WinBarNC.fg,
-          buffer_visible_close_fg = Error.fg,
-          buffer_visible_bg = Normal.bg,
-          buffer_overflow_fg = Comment.fg,
-          buffer_overflow_bg = TabLineFill.bg,
-          buffer_picker_fg = Error.fg,
-          tab_close_fg = Error.fg,
-          tab_close_bg = TabLineFill.bg,
-          tab_fg = TabLine.fg,
-          tab_bg = TabLine.bg,
-          tab_active_fg = TabLineSel.fg,
-          tab_active_bg = TabLineSel.bg,
-          inactive = HeirlineInactive,
-          normal = HeirlineNormal,
-          insert = HeirlineInsert,
-          visual = HeirlineVisual,
-          replace = HeirlineReplace,
-          command = HeirlineCommand,
-          terminal = HeirlineTerminal,
-        }
-
-        local user_colors = status_opts.colors
-        if type(user_colors) == "table" then
-          colors = require("astrocore").extend_tbl(colors, user_colors)
-        elseif type(user_colors) == "function" then
-          colors = user_colors(colors)
-        end
-
-        for _, section in ipairs {
-          "git_branch",
-          "file_info",
-          "git_diff",
-          "diagnostics",
-          "lsp",
-          "macro_recording",
-          "mode",
-          "cmd_info",
-          "treesitter",
-          "nav",
-          "virtual_env",
-        } do
-          if not colors[section .. "_bg"] then colors[section .. "_bg"] = colors["section_bg"] end
-          if not colors[section .. "_fg"] then colors[section .. "_fg"] = colors["section_fg"] end
-        end
-
-        return colors
-      end,
-    }
-  end,
-}
diff --git a/lua/astronvim/plugins/aerial.lua b/lua/astronvim/plugins/aerial.lua
deleted file mode 100644
index 59f86fc..0000000
--- a/lua/astronvim/plugins/aerial.lua
+++ /dev/null
@@ -1,45 +0,0 @@
-return {
-  "stevearc/aerial.nvim",
-  event = "User AstroFile",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>lS"] = { function() require("aerial").toggle() end, desc = "Symbols outline" }
-      end,
-    },
-  },
-  opts = function()
-    local opts = {
-      attach_mode = "global",
-      backends = { "lsp", "treesitter", "markdown", "man" },
-      layout = { min_width = 28 },
-      show_guides = true,
-      filter_kind = false,
-      guides = {
-        mid_item = "├ ",
-        last_item = "└ ",
-        nested_top = "│ ",
-        whitespace = "  ",
-      },
-      keymaps = {
-        ["[y"] = "actions.prev",
-        ["]y"] = "actions.next",
-        ["[Y"] = "actions.prev_up",
-        ["]Y"] = "actions.next_up",
-        ["{"] = false,
-        ["}"] = false,
-        ["[["] = false,
-        ["]]"] = false,
-      },
-    }
-
-    local large_buf = vim.tbl_get(require("astrocore").config, "features", "large_buf")
-    if large_buf then
-      opts.disable_max_lines, opts.disable_max_size = large_buf.lines, large_buf.size
-    end
-
-    return opts
-  end,
-}
diff --git a/lua/astronvim/plugins/alpha.lua b/lua/astronvim/plugins/alpha.lua
deleted file mode 100644
index 053b540..0000000
--- a/lua/astronvim/plugins/alpha.lua
+++ /dev/null
@@ -1,152 +0,0 @@
-return {
-  "goolord/alpha-nvim",
-  cmd = "Alpha",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>h"] = {
-          function()
-            local wins = vim.api.nvim_tabpage_list_wins(0)
-            if #wins > 1 and vim.bo[vim.api.nvim_win_get_buf(wins[1])].filetype == "neo-tree" then
-              vim.fn.win_gotoid(wins[2]) -- go to non-neo-tree window to toggle alpha
-            end
-            require("alpha").start(false)
-          end,
-          desc = "Home Screen",
-        }
-        opts.autocmds.alpha_settings = {
-          {
-            event = { "User", "BufWinEnter" },
-            desc = "Disable status, tablines, and cmdheight for alpha",
-            callback = function(event)
-              if
-                (
-                  (event.event == "User" and event.file == "AlphaReady")
-                  or (event.event == "BufWinEnter" and vim.bo[event.buf].filetype == "alpha")
-                ) and not vim.g.before_alpha
-              then
-                vim.g.before_alpha = {
-                  showtabline = vim.opt.showtabline:get(),
-                  laststatus = vim.opt.laststatus:get(),
-                  cmdheight = vim.opt.cmdheight:get(),
-                }
-                vim.opt.showtabline, vim.opt.laststatus, vim.opt.cmdheight = 0, 0, 0
-              elseif vim.g.before_alpha and event.event == "BufWinEnter" and vim.bo[event.buf].buftype ~= "nofile" then
-                vim.opt.laststatus, vim.opt.showtabline, vim.opt.cmdheight =
-                  vim.g.before_alpha.laststatus, vim.g.before_alpha.showtabline, vim.g.before_alpha.cmdheight
-                vim.g.before_alpha = nil
-              end
-            end,
-          },
-        }
-        opts.autocmds.alpha_autostart = {
-          {
-            event = "VimEnter",
-            desc = "Start Alpha when vim is opened with no arguments",
-            callback = function()
-              local should_skip
-              local lines = vim.api.nvim_buf_get_lines(0, 0, 2, false)
-              if
-                vim.fn.argc() > 0 -- don't start when opening a file
-                or #lines > 1 -- don't open if current buffer has more than 1 line
-                or (#lines == 1 and lines[1]:len() > 0) -- don't open the current buffer if it has anything on the first line
-                or #vim.tbl_filter(function(bufnr) return vim.bo[bufnr].buflisted end, vim.api.nvim_list_bufs()) > 1 -- don't open if any listed buffers
-                or not vim.o.modifiable -- don't open if not modifiable
-              then
-                should_skip = true
-              else
-                for _, arg in pairs(vim.v.argv) do
-                  if arg == "-b" or arg == "-c" or vim.startswith(arg, "+") or arg == "-S" then
-                    should_skip = true
-                    break
-                  end
-                end
-              end
-              if should_skip then return end
-              require("lazy").load { plugins = { "alpha-nvim" } }
-              require("alpha").start(true)
-              vim.schedule(function() vim.cmd.doautocmd "FileType" end)
-            end,
-          },
-        }
-      end,
-    },
-  },
-  opts = function()
-    local dashboard = require "alpha.themes.dashboard"
-
-    dashboard.leader = "LDR"
-
-    --- @param shortcut string Shortcut string of a button mapping
-    --- @param desc string Real text description of the mapping
-    --- @param rhs string? Righthand side of mapping if defining a new mapping (_optional_)
-    --- @param map_opts table? `keymap.set` options used during keymap creating (_optional_)
-    dashboard.button = function(shortcut, desc, rhs, map_opts)
-      -- HACK: fixes leader customization, remove after fixed upstream
-      -- https://github.com/goolord/alpha-nvim/pull/271
-      local lhs = shortcut:gsub("%s", ""):gsub(dashboard.leader, "<Leader>")
-      local default_map_opts = { noremap = true, silent = true, nowait = true, desc = desc }
-
-      local leader = vim.g.mapleader
-      if leader == " " then leader = "SPC" end
-
-      return {
-        type = "button",
-        val = desc,
-        on_press = function()
-          vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(rhs or lhs .. "<Ignore>", true, false, true), "t", false)
-        end,
-        opts = {
-          position = "center",
-          shortcut = shortcut:gsub(dashboard.leader, leader),
-          cursor = -2,
-          width = 36,
-          align_shortcut = "right",
-          hl = "DashboardCenter",
-          hl_shortcut = "DashboardShortcut",
-          keymap = rhs and { "n", lhs, rhs, require("astrocore").extend_tbl(default_map_opts, map_opts) },
-        },
-      }
-    end
-
-    dashboard.section.header.val = {
-      " █████  ███████ ████████ ██████   ██████",
-      "██   ██ ██         ██    ██   ██ ██    ██",
-      "███████ ███████    ██    ██████  ██    ██",
-      "██   ██      ██    ██    ██   ██ ██    ██",
-      "██   ██ ███████    ██    ██   ██  ██████",
-      " ",
-      "    ███    ██ ██    ██ ██ ███    ███",
-      "    ████   ██ ██    ██ ██ ████  ████",
-      "    ██ ██  ██ ██    ██ ██ ██ ████ ██",
-      "    ██  ██ ██  ██  ██  ██ ██  ██  ██",
-      "    ██   ████   ████   ██ ██      ██",
-    }
-    dashboard.section.header.opts.hl = "DashboardHeader"
-    dashboard.section.footer.opts.hl = "DashboardFooter"
-
-    local get_icon = require("astroui").get_icon
-    dashboard.section.buttons.val = {
-      dashboard.button("LDR n  ", get_icon("FileNew", 2, true) .. "New File  "),
-      dashboard.button("LDR f f", get_icon("Search", 2, true) .. "Find File  "),
-      dashboard.button("LDR f o", get_icon("DefaultFile", 2, true) .. "Recents  "),
-      dashboard.button("LDR f w", get_icon("WordFile", 2, true) .. "Find Word  "),
-      dashboard.button("LDR f '", get_icon("Bookmarks", 2, true) .. "Bookmarks  "),
-      dashboard.button("LDR S l", get_icon("Refresh", 2, true) .. "Last Session  "),
-    }
-
-    dashboard.config.layout = {
-      { type = "padding", val = vim.fn.max { 2, vim.fn.floor(vim.fn.winheight(0) * 0.2) } },
-      dashboard.section.header,
-      { type = "padding", val = 5 },
-      dashboard.section.buttons,
-      { type = "padding", val = 3 },
-      dashboard.section.footer,
-    }
-    dashboard.config.opts.noautocmd = true
-    return dashboard
-  end,
-  config = function(...) require "astronvim.plugins.configs.alpha"(...) end,
-}
diff --git a/lua/astronvim/plugins/autopairs.lua b/lua/astronvim/plugins/autopairs.lua
deleted file mode 100644
index c2852cd..0000000
--- a/lua/astronvim/plugins/autopairs.lua
+++ /dev/null
@@ -1,29 +0,0 @@
-return {
-  "windwp/nvim-autopairs",
-  event = "User AstroFile",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>ua"] = { function() require("astrocore.toggles").autopairs() end, desc = "Toggle autopairs" }
-      end,
-    },
-  },
-  opts = {
-    check_ts = true,
-    ts_config = { java = false },
-    fast_wrap = {
-      map = "<M-e>",
-      chars = { "{", "[", "(", '"', "'" },
-      pattern = ([[ [%'%"%)%>%]%)%}%,] ]]):gsub("%s+", ""),
-      offset = 0,
-      end_key = "$",
-      keys = "qwertyuiopzxcvbnmasdfghjkl",
-      check_comma = true,
-      highlight = "PmenuSel",
-      highlight_grey = "LineNr",
-    },
-  },
-  config = function(...) require "astronvim.plugins.configs.nvim-autopairs"(...) end,
-}
diff --git a/lua/astronvim/plugins/better-escape.lua b/lua/astronvim/plugins/better-escape.lua
deleted file mode 100644
index 826460d..0000000
--- a/lua/astronvim/plugins/better-escape.lua
+++ /dev/null
@@ -1 +0,0 @@
-return { "max397574/better-escape.nvim", event = "InsertCharPre", opts = { timeout = 300 } }
diff --git a/lua/astronvim/plugins/cmp_luasnip.lua b/lua/astronvim/plugins/cmp_luasnip.lua
deleted file mode 100644
index ce82a6f..0000000
--- a/lua/astronvim/plugins/cmp_luasnip.lua
+++ /dev/null
@@ -1,178 +0,0 @@
-local function has_words_before()
-  local line, col = (unpack or table.unpack)(vim.api.nvim_win_get_cursor(0))
-  return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match "%s" == nil
-end
-
-return {
-  {
-    "hrsh7th/nvim-cmp",
-    dependencies = {
-      {
-        "AstroNvim/astrocore",
-        opts = function(_, opts)
-          local maps = opts.mappings
-          maps.n["<Leader>uc"] =
-            { function() require("astrocore.toggles").buffer_cmp() end, desc = "Toggle autocompletion (buffer)" }
-          maps.n["<Leader>uC"] =
-            { function() require("astrocore.toggles").cmp() end, desc = "Toggle autocompletion (global)" }
-        end,
-      },
-      { "hrsh7th/cmp-buffer", lazy = true },
-      { "hrsh7th/cmp-path", lazy = true },
-      { "hrsh7th/cmp-nvim-lsp", lazy = true },
-    },
-    event = "InsertEnter",
-    opts = function()
-      local cmp, astro = require "cmp", require "astrocore"
-
-      local sources = {}
-      for source_plugin, source in pairs {
-        ["cmp-buffer"] = { name = "buffer", priority = 500, group_index = 2 },
-        ["cmp-nvim-lsp"] = { name = "nvim_lsp", priority = 1000 },
-        ["cmp-path"] = { name = "path", priority = 250 },
-      } do
-        if astro.is_available(source_plugin) then table.insert(sources, source) end
-      end
-
-      return {
-        enabled = function()
-          local dap_prompt = astro.is_available "cmp-dap" -- add interoperability with cmp-dap
-            and vim.tbl_contains({ "dap-repl", "dapui_watches", "dapui_hover" }, vim.bo[0].filetype)
-          if vim.bo[0].buftype == "prompt" and not dap_prompt then return false end
-          return vim.F.if_nil(vim.b.cmp_enabled, astro.config.features.cmp)
-        end,
-        preselect = cmp.PreselectMode.None,
-        formatting = { fields = { "kind", "abbr", "menu" } },
-        confirm_opts = {
-          behavior = cmp.ConfirmBehavior.Replace,
-          select = false,
-        },
-        window = {
-          completion = cmp.config.window.bordered {
-            col_offset = -2,
-            side_padding = 0,
-            border = "rounded",
-            winhighlight = "Normal:NormalFloat,FloatBorder:FloatBorder,CursorLine:PmenuSel,Search:None",
-          },
-          documentation = cmp.config.window.bordered {
-            border = "rounded",
-            winhighlight = "Normal:NormalFloat,FloatBorder:FloatBorder,CursorLine:PmenuSel,Search:None",
-          },
-        },
-        mapping = {
-          ["<Up>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Select },
-          ["<Down>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Select },
-          ["<C-P>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
-          ["<C-N>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
-          ["<C-K>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
-          ["<C-J>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
-          ["<C-U>"] = cmp.mapping(cmp.mapping.scroll_docs(-4), { "i", "c" }),
-          ["<C-D>"] = cmp.mapping(cmp.mapping.scroll_docs(4), { "i", "c" }),
-          ["<C-Space>"] = cmp.mapping(cmp.mapping.complete(), { "i", "c" }),
-          ["<C-Y>"] = cmp.config.disable,
-          ["<C-E>"] = cmp.mapping { i = cmp.mapping.abort(), c = cmp.mapping.close() },
-          ["<CR>"] = cmp.mapping.confirm { select = false },
-          ["<Tab>"] = cmp.mapping(function(fallback)
-            if cmp.visible() then
-              cmp.select_next_item()
-            elseif vim.snippet and vim.snippet.active { direction = 1 } then
-              vim.schedule(function() vim.snippet.jump(1) end)
-            elseif has_words_before() then
-              cmp.complete()
-            else
-              fallback()
-            end
-          end, { "i", "s" }),
-          ["<S-Tab>"] = cmp.mapping(function(fallback)
-            if cmp.visible() then
-              cmp.select_prev_item()
-            elseif vim.snippet and vim.snippet.active { direction = -1 } then
-              vim.schedule(function() vim.snippet.jump(-1) end)
-            else
-              fallback()
-            end
-          end, { "i", "s" }),
-        },
-        sources = sources,
-      }
-    end,
-    config = function(...) require "astronvim.plugins.configs.cmp"(...) end,
-  },
-  {
-    "AstroNvim/astrolsp",
-    optional = true,
-    opts = function(_, opts)
-      local astrocore = require "astrocore"
-      if astrocore.is_available "cmp-nvim-lsp" then
-        opts.capabilities = astrocore.extend_tbl(opts.capabilities, {
-          textDocument = {
-            completion = {
-              completionItem = {
-                documentationFormat = { "markdown", "plaintext" },
-                snippetSupport = true,
-                preselectSupport = true,
-                insertReplaceSupport = true,
-                labelDetailsSupport = true,
-                deprecatedSupport = true,
-                commitCharactersSupport = true,
-                tagSupport = { valueSet = { 1 } },
-                resolveSupport = { properties = { "documentation", "detail", "additionalTextEdits" } },
-              },
-            },
-          },
-        })
-      end
-    end,
-  },
-  {
-    "L3MON4D3/LuaSnip",
-    lazy = true,
-    build = vim.fn.has "win32" == 0
-        and "echo 'NOTE: jsregexp is optional, so not a big deal if it fails to build\n'; make install_jsregexp"
-      or nil,
-    dependencies = {
-      { "rafamadriz/friendly-snippets", lazy = true },
-      {
-        "hrsh7th/nvim-cmp",
-        dependencies = { { "saadparwaiz1/cmp_luasnip", lazy = true } },
-        opts = function(_, opts)
-          local luasnip, cmp = require "luasnip", require "cmp"
-
-          if not opts.snippet then opts.snippet = {} end
-          opts.snippet.expand = function(args) luasnip.lsp_expand(args.body) end
-
-          if not opts.sources then opts.sources = {} end
-          table.insert(opts.sources, { name = "luasnip", priority = 750 })
-
-          if not opts.mappings then opts.mappings = {} end
-          opts.mapping["<Tab>"] = cmp.mapping(function(fallback)
-            if cmp.visible() then
-              cmp.select_next_item()
-            elseif luasnip.expand_or_locally_jumpable() then
-              luasnip.expand_or_jump()
-            elseif has_words_before() then
-              cmp.complete()
-            else
-              fallback()
-            end
-          end, { "i", "s" })
-          opts.mapping["<S-Tab>"] = cmp.mapping(function(fallback)
-            if cmp.visible() then
-              cmp.select_prev_item()
-            elseif luasnip.jumpable(-1) then
-              luasnip.jump(-1)
-            else
-              fallback()
-            end
-          end, { "i", "s" })
-        end,
-      },
-    },
-    opts = {
-      history = true,
-      delete_check_events = "TextChanged",
-      region_check_events = "CursorMoved",
-    },
-    config = function(...) require "astronvim.plugins.configs.luasnip"(...) end,
-  },
-}
diff --git a/lua/astronvim/plugins/colorizer.lua b/lua/astronvim/plugins/colorizer.lua
deleted file mode 100644
index 790b63a..0000000
--- a/lua/astronvim/plugins/colorizer.lua
+++ /dev/null
@@ -1,17 +0,0 @@
-return {
-  -- TODO: replace with nvim-highlight-colors: https://github.com/brenoprata10/nvim-highlight-colors
-  "NvChad/nvim-colorizer.lua",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>uz"] = { "<Cmd>ColorizerToggle<CR>", desc = "Toggle color highlight" }
-      end,
-    },
-  },
-  event = "User AstroFile",
-  cmd = { "ColorizerToggle", "ColorizerAttachToBuffer", "ColorizerDetachFromBuffer", "ColorizerReloadAllBuffers" },
-  opts = { user_default_options = { names = false } },
-  config = function(...) require "astronvim.plugins.configs.colorizer"(...) end,
-}
diff --git a/lua/astronvim/plugins/comment.lua b/lua/astronvim/plugins/comment.lua
deleted file mode 100644
index 46a0caf..0000000
--- a/lua/astronvim/plugins/comment.lua
+++ /dev/null
@@ -1,52 +0,0 @@
-return {
-  "numToStr/Comment.nvim",
-  dependencies = {
-    { "JoosepAlviste/nvim-ts-context-commentstring", lazy = true, opts = { enable_autocmd = false } },
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>/"] = {
-          function()
-            return require("Comment.api").call(
-              "toggle.linewise." .. (vim.v.count == 0 and "current" or "count_repeat"),
-              "g@$"
-            )()
-          end,
-          expr = true,
-          silent = true,
-          desc = "Toggle comment line",
-        }
-        maps.x["<Leader>/"] = {
-          "<Esc><Cmd>lua require('Comment.api').locked('toggle.linewise')(vim.fn.visualmode())<CR>",
-          desc = "Toggle comment for selection",
-        }
-      end,
-    },
-  },
-  keys = function(_, keys)
-    local plugin = require("lazy.core.config").spec.plugins["Comment.nvim"]
-    local opts = require("lazy.core.plugin").values(plugin, "opts", false)
-    if vim.tbl_get(opts, "mappings", "basic") ~= false then
-      vim.list_extend(keys, {
-        { vim.tbl_get(opts, "toggler", "line") or "gcc", desc = "Comment toggle current line" },
-        { vim.tbl_get(opts, "toggler", "block") or "gbc", desc = "Comment toggle current block" },
-        { vim.tbl_get(opts, "opleader", "line") or "gc", desc = "Comment toggle linewise" },
-        { vim.tbl_get(opts, "opleader", "block") or "gb", desc = "Comment toggle blockwise" },
-        { vim.tbl_get(opts, "opleader", "line") or "gc", mode = "x", desc = "Comment toggle linewise (visual)" },
-        { vim.tbl_get(opts, "opleader", "block") or "gb", mode = "x", desc = "Comment toggle blockwise (visual)" },
-      })
-    end
-    if vim.tbl_get(opts, "mappings", "extra") ~= false then
-      vim.list_extend(keys, {
-        { vim.tbl_get(keys, "extra", "below") or "gco", desc = "Comment insert below" },
-        { vim.tbl_get(opts, "extra", "above") or "gcO", desc = "Comment insert above" },
-        { vim.tbl_get(opts, "extra", "eol") or "gcA", desc = "Comment insert end of line" },
-      })
-    end
-  end,
-  opts = function(_, opts)
-    local commentstring_avail, commentstring = pcall(require, "ts_context_commentstring.integrations.comment_nvim")
-    if commentstring_avail then opts.pre_hook = commentstring.create_pre_hook() end
-  end,
-}
diff --git a/lua/astronvim/plugins/configs/cmp.lua b/lua/astronvim/plugins/configs/cmp.lua
deleted file mode 100644
index d4d7851..0000000
--- a/lua/astronvim/plugins/configs/cmp.lua
+++ /dev/null
@@ -1,6 +0,0 @@
-return function(_, opts)
-  for _, source in ipairs(opts.sources or {}) do
-    if not source.group_index then source.group_index = 1 end
-  end
-  require("cmp").setup(opts)
-end
diff --git a/lua/astronvim/plugins/configs/colorizer.lua b/lua/astronvim/plugins/configs/colorizer.lua
deleted file mode 100644
index 7449d80..0000000
--- a/lua/astronvim/plugins/configs/colorizer.lua
+++ /dev/null
@@ -1,7 +0,0 @@
-return function(_, opts)
-  local colorizer = require "colorizer"
-  colorizer.setup(opts)
-  for _, tab in ipairs(vim.api.nvim_list_tabpages()) do
-    if vim.t[tab].bufs then vim.tbl_map(function(buf) colorizer.attach_to_buffer(buf) end, vim.t[tab].bufs) end
-  end
-end
diff --git a/lua/astronvim/plugins/configs/heirline.lua b/lua/astronvim/plugins/configs/heirline.lua
deleted file mode 100644
index 6e6f017..0000000
--- a/lua/astronvim/plugins/configs/heirline.lua
+++ /dev/null
@@ -1,10 +0,0 @@
-return function(_, opts)
-  require("heirline").setup(opts)
-
-  vim.api.nvim_create_autocmd("User", {
-    pattern = "AstroColorScheme",
-    group = vim.api.nvim_create_augroup("Heirline", { clear = true }),
-    desc = "Refresh heirline colors",
-    callback = function() require("astroui.status.heirline").refresh_colors() end,
-  })
-end
diff --git a/lua/astronvim/plugins/configs/lspconfig.lua b/lua/astronvim/plugins/configs/lspconfig.lua
deleted file mode 100644
index ca0343c..0000000
--- a/lua/astronvim/plugins/configs/lspconfig.lua
+++ /dev/null
@@ -1,14 +0,0 @@
-return function(_, _)
-  local setup_servers = function()
-    vim.tbl_map(require("astrolsp").lsp_setup, require("astrolsp").config.servers)
-    require("astrocore").exec_buffer_autocmds("FileType", { group = "lspconfig" })
-
-    require("astrocore").event "LspSetup"
-  end
-  local astrocore = require "astrocore"
-  if astrocore.is_available "mason-lspconfig.nvim" then
-    astrocore.on_load("mason-lspconfig.nvim", setup_servers)
-  else
-    setup_servers()
-  end
-end
diff --git a/lua/astronvim/plugins/configs/nvim-autopairs.lua b/lua/astronvim/plugins/configs/nvim-autopairs.lua
deleted file mode 100644
index 02a48f9..0000000
--- a/lua/astronvim/plugins/configs/nvim-autopairs.lua
+++ /dev/null
@@ -1,13 +0,0 @@
-return function(_, opts)
-  local npairs = require "nvim-autopairs"
-  npairs.setup(opts)
-
-  local astrocore = require "astrocore"
-  if not astrocore.config.features.autopairs then npairs.disable() end
-  astrocore.on_load(
-    "nvim-cmp",
-    function()
-      require("cmp").event:on("confirm_done", require("nvim-autopairs.completion.cmp").on_confirm_done { tex = false })
-    end
-  )
-end
diff --git a/lua/astronvim/plugins/configs/nvim-treesitter.lua b/lua/astronvim/plugins/configs/nvim-treesitter.lua
deleted file mode 100644
index 66661db..0000000
--- a/lua/astronvim/plugins/configs/nvim-treesitter.lua
+++ /dev/null
@@ -1,29 +0,0 @@
-return function(plugin, opts)
-  local ts = require(plugin.main)
-
-  -- HACK: force install all parsers bundled with neovim
-  -- TODO: remove when nvim-treesitter v1 released
-  if opts.ensure_installed ~= "all" then
-    opts.ensure_installed = require("astrocore").list_insert_unique(
-      opts.ensure_installed,
-      { "bash", "c", "lua", "markdown", "markdown_inline", "python", "query", "vim", "vimdoc" }
-    )
-  end
-  if vim.fn.executable "git" == 0 then opts.ensure_installed = nil end
-
-  -- disable all treesitter modules on large buffer
-  if vim.tbl_get(require("astrocore").config, "features", "large_buf") then
-    for _, module in ipairs(ts.available_modules()) do
-      if not opts[module] then opts[module] = {} end
-      local module_opts = opts[module]
-      local disable = module_opts.disable
-      module_opts.disable = function(lang, bufnr)
-        return vim.b[bufnr].large_buf
-          or (type(disable) == "table" and vim.tbl_contains(disable, lang))
-          or (type(disable) == "function" and disable(lang, bufnr))
-      end
-    end
-  end
-
-  ts.setup(opts)
-end
diff --git a/lua/astronvim/plugins/configs/telescope.lua b/lua/astronvim/plugins/configs/telescope.lua
deleted file mode 100644
index 0693033..0000000
--- a/lua/astronvim/plugins/configs/telescope.lua
+++ /dev/null
@@ -1,8 +0,0 @@
-return function(_, opts)
-  local telescope = require "telescope"
-  telescope.setup(opts)
-  local is_available = require("astrocore").is_available
-  if is_available "nvim-notify" then telescope.load_extension "notify" end
-  if is_available "aerial.nvim" then telescope.load_extension "aerial" end
-  if is_available "telescope-fzf-native.nvim" then telescope.load_extension "fzf" end
-end
diff --git a/lua/astronvim/plugins/configs/ts-autotag.lua b/lua/astronvim/plugins/configs/ts-autotag.lua
deleted file mode 100644
index fc53524..0000000
--- a/lua/astronvim/plugins/configs/ts-autotag.lua
+++ /dev/null
@@ -1,4 +0,0 @@
-return function(_, opts)
-  require("nvim-ts-autotag").setup(opts)
-  require("astrocore").exec_buffer_autocmds("FileType", { group = "nvim_ts_xmltag" })
-end
diff --git a/lua/astronvim/plugins/configs/vim-illuminate.lua b/lua/astronvim/plugins/configs/vim-illuminate.lua
deleted file mode 100644
index ebb74b0..0000000
--- a/lua/astronvim/plugins/configs/vim-illuminate.lua
+++ /dev/null
@@ -1 +0,0 @@
-return function(_, opts) require("illuminate").configure(opts) end
diff --git a/lua/astronvim/plugins/dap.lua b/lua/astronvim/plugins/dap.lua
deleted file mode 100644
index 0ba56f3..0000000
--- a/lua/astronvim/plugins/dap.lua
+++ /dev/null
@@ -1,100 +0,0 @@
-return {
-  "mfussenegger/nvim-dap",
-  lazy = true,
-  dependencies = {
-    {
-      "jay-babu/mason-nvim-dap.nvim",
-      dependencies = { "nvim-dap", "williamboman/mason.nvim" },
-      init = function(plugin) require("astrocore").on_load("mason.nvim", plugin.name) end,
-      cmd = { "DapInstall", "DapUninstall" },
-      opts = { ensure_installed = {}, handlers = {} },
-    },
-    {
-      "rcarriga/nvim-dap-ui",
-      lazy = true,
-      dependencies = {
-        { "nvim-neotest/nvim-nio", lazy = true },
-        {
-          "AstroNvim/astrocore",
-          opts = function(_, opts)
-            local maps = opts.mappings
-            maps.n["<Leader>d"] = vim.tbl_get(opts, "_map_sections", "d")
-            maps.v["<Leader>d"] = vim.tbl_get(opts, "_map_sections", "d")
-            maps.n["<Leader>dE"] = {
-              function()
-                vim.ui.input({ prompt = "Expression: " }, function(expr)
-                  if expr then require("dapui").eval(expr, { enter = true }) end
-                end)
-              end,
-              desc = "Evaluate Input",
-            }
-            maps.n["<Leader>du"] = { function() require("dapui").toggle() end, desc = "Toggle Debugger UI" }
-            maps.n["<Leader>dh"] = { function() require("dap.ui.widgets").hover() end, desc = "Debugger Hover" }
-            maps.v["<Leader>dE"] = { function() require("dapui").eval() end, desc = "Evaluate Input" }
-          end,
-        },
-      },
-      opts = { floating = { border = "rounded" } },
-      config = function(...) require "astronvim.plugins.configs.nvim-dap-ui"(...) end,
-    },
-    {
-      "rcarriga/cmp-dap",
-      lazy = true,
-      dependencies = { "hrsh7th/nvim-cmp" },
-      config = function(...) require "astronvim.plugins.configs.cmp-dap"(...) end,
-    },
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local get_icon = require("astroui").get_icon
-        local maps = opts.mappings
-        maps.n["<Leader>d"] = vim.tbl_get(opts, "_map_sections", "d")
-        -- modified function keys found with `showkey -a` in the terminal to get key code
-        -- run `nvim -V3log +quit` and search through the "Terminal info" in the `log` file for the correct keyname
-        maps.n["<F5>"] = { function() require("dap").continue() end, desc = "Debugger: Start" }
-        maps.n["<F17>"] = { function() require("dap").terminate() end, desc = "Debugger: Stop" } -- Shift+F5
-        maps.n["<F21>"] = { -- Shift+F9
-          function()
-            vim.ui.input({ prompt = "Condition: " }, function(condition)
-              if condition then require("dap").set_breakpoint(condition) end
-            end)
-          end,
-          desc = "Debugger: Conditional Breakpoint",
-        }
-        maps.n["<F29>"] = { function() require("dap").restart_frame() end, desc = "Debugger: Restart" } -- Control+F5
-        maps.n["<F6>"] = { function() require("dap").pause() end, desc = "Debugger: Pause" }
-        maps.n["<F9>"] = { function() require("dap").toggle_breakpoint() end, desc = "Debugger: Toggle Breakpoint" }
-        maps.n["<F10>"] = { function() require("dap").step_over() end, desc = "Debugger: Step Over" }
-        maps.n["<F11>"] = { function() require("dap").step_into() end, desc = "Debugger: Step Into" }
-        maps.n["<F23>"] = { function() require("dap").step_out() end, desc = "Debugger: Step Out" } -- Shift+F11
-        maps.n["<Leader>db"] = { function() require("dap").toggle_breakpoint() end, desc = "Toggle Breakpoint (F9)" }
-        maps.n["<Leader>dB"] = { function() require("dap").clear_breakpoints() end, desc = "Clear Breakpoints" }
-        maps.n["<Leader>dc"] = { function() require("dap").continue() end, desc = "Start/Continue (F5)" }
-        maps.n["<Leader>dC"] = {
-          function()
-            vim.ui.input({ prompt = "Condition: " }, function(condition)
-              if condition then require("dap").set_breakpoint(condition) end
-            end)
-          end,
-          desc = "Conditional Breakpoint (S-F9)",
-        }
-        maps.n["<Leader>di"] = { function() require("dap").step_into() end, desc = "Step Into (F11)" }
-        maps.n["<Leader>do"] = { function() require("dap").step_over() end, desc = "Step Over (F10)" }
-        maps.n["<Leader>dO"] = { function() require("dap").step_out() end, desc = "Step Out (S-F11)" }
-        maps.n["<Leader>dq"] = { function() require("dap").close() end, desc = "Close Session" }
-        maps.n["<Leader>dQ"] = { function() require("dap").terminate() end, desc = "Terminate Session (S-F5)" }
-        maps.n["<Leader>dp"] = { function() require("dap").pause() end, desc = "Pause (F6)" }
-        maps.n["<Leader>dr"] = { function() require("dap").restart_frame() end, desc = "Restart (C-F5)" }
-        maps.n["<Leader>dR"] = { function() require("dap").repl.toggle() end, desc = "Toggle REPL" }
-        maps.n["<Leader>ds"] = { function() require("dap").run_to_cursor() end, desc = "Run To Cursor" }
-
-        if not opts.signs then opts.signs = {} end
-        opts.signs.DapBreakpoint = { text = get_icon "DapBreakpoint", texthl = "DiagnosticInfo" }
-        opts.signs.DapBreakpointCondition = { text = get_icon "DapBreakpointCondition", texthl = "DiagnosticInfo" }
-        opts.signs.DapBreakpointRejected = { text = get_icon "DapBreakpointRejected", texthl = "DiagnosticError" }
-        opts.signs.DapLogPoint = { text = get_icon "DapLogPoint", texthl = "DiagnosticInfo" }
-        opts.signs.DapStopped = { text = get_icon "DapStopped", texthl = "DiagnosticWarn" }
-      end,
-    },
-  },
-}
diff --git a/lua/astronvim/plugins/dressing.lua b/lua/astronvim/plugins/dressing.lua
deleted file mode 100644
index f98963c..0000000
--- a/lua/astronvim/plugins/dressing.lua
+++ /dev/null
@@ -1,9 +0,0 @@
-return {
-  "stevearc/dressing.nvim",
-  lazy = true,
-  init = function() require("astrocore").load_plugin_with_func("dressing.nvim", vim.ui, { "input", "select" }) end,
-  opts = {
-    input = { default_prompt = "➤ " },
-    select = { backend = { "telescope", "builtin" } },
-  },
-}
diff --git a/lua/astronvim/plugins/gitsigns.lua b/lua/astronvim/plugins/gitsigns.lua
deleted file mode 100644
index f19a2e1..0000000
--- a/lua/astronvim/plugins/gitsigns.lua
+++ /dev/null
@@ -1,40 +0,0 @@
-return {
-  "lewis6991/gitsigns.nvim",
-  enabled = vim.fn.executable "git" == 1,
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>g"] = vim.tbl_get(opts, "_map_sections", "g")
-        maps.n["]g"] = { function() require("gitsigns").next_hunk() end, desc = "Next Git hunk" }
-        maps.n["[g"] = { function() require("gitsigns").prev_hunk() end, desc = "Previous Git hunk" }
-        maps.n["<Leader>gl"] = { function() require("gitsigns").blame_line() end, desc = "View Git blame" }
-        maps.n["<Leader>gL"] =
-          { function() require("gitsigns").blame_line { full = true } end, desc = "View full Git blame" }
-        maps.n["<Leader>gp"] = { function() require("gitsigns").preview_hunk_inline() end, desc = "Preview Git hunk" }
-        maps.n["<Leader>gh"] = { function() require("gitsigns").reset_hunk() end, desc = "Reset Git hunk" }
-        maps.n["<Leader>gr"] = { function() require("gitsigns").reset_buffer() end, desc = "Reset Git buffer" }
-        maps.n["<Leader>gs"] = { function() require("gitsigns").stage_hunk() end, desc = "Stage Git hunk" }
-        maps.n["<Leader>gS"] = { function() require("gitsigns").stage_buffer() end, desc = "Stage Git buffer" }
-        maps.n["<Leader>gu"] = { function() require("gitsigns").undo_stage_hunk() end, desc = "Unstage Git hunk" }
-        maps.n["<Leader>gd"] = { function() require("gitsigns").diffthis() end, desc = "View Git diff" }
-      end,
-    },
-  },
-  event = "User AstroGitFile",
-  opts = function()
-    local get_icon = require("astroui").get_icon
-    return {
-      signs = {
-        add = { text = get_icon "GitSign" },
-        change = { text = get_icon "GitSign" },
-        delete = { text = get_icon "GitSign" },
-        topdelete = { text = get_icon "GitSign" },
-        changedelete = { text = get_icon "GitSign" },
-        untracked = { text = get_icon "GitSign" },
-      },
-      worktrees = require("astrocore").config.git_worktrees,
-    }
-  end,
-}
diff --git a/lua/astronvim/plugins/guess-indent.lua b/lua/astronvim/plugins/guess-indent.lua
deleted file mode 100644
index 063ed33..0000000
--- a/lua/astronvim/plugins/guess-indent.lua
+++ /dev/null
@@ -1,5 +0,0 @@
-return {
-  "NMAC427/guess-indent.nvim",
-  event = "User AstroFile",
-  config = function(...) require "astronvim.plugins.configs.guess-indent"(...) end,
-}
diff --git a/lua/astronvim/plugins/indent-blankline.lua b/lua/astronvim/plugins/indent-blankline.lua
deleted file mode 100644
index f4c2606..0000000
--- a/lua/astronvim/plugins/indent-blankline.lua
+++ /dev/null
@@ -1,42 +0,0 @@
-return {
-  "lukas-reineke/indent-blankline.nvim",
-  event = "User AstroFile",
-  cmd = { "IBLEnable", "IBLDisable", "IBLToggle", "IBLEnableScope", "IBLDisableScope", "IBLToggleScope" },
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>u|"] = { "<Cmd>IBLToggle<CR>", desc = "Toggle indent guides" }
-      end,
-    },
-  },
-  main = "ibl",
-  opts = {
-    indent = { char = "▏" },
-    scope = { show_start = false, show_end = false },
-    exclude = {
-      buftypes = {
-        "nofile",
-        "prompt",
-        "quickfix",
-        "terminal",
-      },
-      filetypes = {
-        "aerial",
-        "alpha",
-        "dashboard",
-        "help",
-        "lazy",
-        "mason",
-        "neo-tree",
-        "NvimTree",
-        "neogitstatus",
-        "notify",
-        "startify",
-        "toggleterm",
-        "Trouble",
-      },
-    },
-  },
-}
diff --git a/lua/astronvim/plugins/lspconfig.lua b/lua/astronvim/plugins/lspconfig.lua
deleted file mode 100644
index 91ba53f..0000000
--- a/lua/astronvim/plugins/lspconfig.lua
+++ /dev/null
@@ -1,30 +0,0 @@
-return {
-  "neovim/nvim-lspconfig",
-  dependencies = {
-    {
-      "AstroNvim/astrolsp",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>li"] =
-          { "<Cmd>LspInfo<CR>", desc = "LSP information", cond = function() return vim.fn.exists ":LspInfo" > 0 end }
-      end,
-    },
-    { "folke/neoconf.nvim", lazy = true, opts = {} },
-    {
-      "williamboman/mason-lspconfig.nvim",
-      dependencies = { "williamboman/mason.nvim" },
-      cmd = { "LspInstall", "LspUninstall" },
-      init = function(plugin) require("astrocore").on_load("mason.nvim", plugin.name) end,
-      opts = {
-        ensure_installed = {},
-        handlers = { function(server) require("astrolsp").lsp_setup(server) end },
-      },
-    },
-  },
-  cmd = function(_, cmds) -- HACK: lazy load lspconfig on `:Neoconf` if neoconf is available
-    if require("astrocore").is_available "neoconf.nvim" then table.insert(cmds, "Neoconf") end
-    vim.list_extend(cmds, { "LspInfo", "LspLog", "LspStart" }) -- add normal `nvim-lspconfig` commands
-  end,
-  event = "User AstroFile",
-  config = function(...) require "astronvim.plugins.configs.lspconfig"(...) end,
-}
diff --git a/lua/astronvim/plugins/lspkind.lua b/lua/astronvim/plugins/lspkind.lua
deleted file mode 100644
index 802ccd9..0000000
--- a/lua/astronvim/plugins/lspkind.lua
+++ /dev/null
@@ -1,39 +0,0 @@
-return {
-  {
-    "onsails/lspkind.nvim",
-    lazy = true,
-    enabled = vim.g.icons_enabled ~= false,
-    opts = {
-      mode = "symbol",
-      symbol_map = {
-        Array = "󰅪",
-        Boolean = "⊨",
-        Class = "󰌗",
-        Constructor = "",
-        Key = "󰌆",
-        Namespace = "󰅪",
-        Null = "NULL",
-        Number = "#",
-        Object = "󰀚",
-        Package = "󰏗",
-        Property = "",
-        Reference = "",
-        Snippet = "",
-        String = "󰀬",
-        TypeParameter = "󰊄",
-        Unit = "",
-      },
-      menu = {},
-    },
-    config = function(...) require "astronvim.plugins.configs.lspkind"(...) end,
-  },
-  {
-    "hrsh7th/nvim-cmp",
-    opts = function(_, opts)
-      if require("astrocore").is_available "lspkind.nvim" then
-        if not opts.formatting then opts.formatting = {} end
-        opts.formatting.format = require("lspkind").cmp_format(require("astrocore").plugin_opts "lspkind.nvim")
-      end
-    end,
-  },
-}
diff --git a/lua/astronvim/plugins/mason.lua b/lua/astronvim/plugins/mason.lua
deleted file mode 100644
index a7c9409..0000000
--- a/lua/astronvim/plugins/mason.lua
+++ /dev/null
@@ -1,44 +0,0 @@
-return {
-  "williamboman/mason.nvim",
-  cmd = {
-    "Mason",
-    "MasonInstall",
-    "MasonUninstall",
-    "MasonUninstallAll",
-    "MasonLog",
-  },
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>pm"] = { function() require("mason.ui").open() end, desc = "Mason Installer" }
-        maps.n["<Leader>pM"] = { function() require("astrocore.mason").update_all() end, desc = "Mason Update" }
-        opts.commands.AstroMasonUpdate = {
-          function(options) require("astrocore.mason").update(options.fargs) end,
-          nargs = "*",
-          desc = "Update Mason Package",
-          complete = function(arg_lead)
-            local _ = require "mason-core.functional"
-            return _.sort_by(
-              _.identity,
-              _.filter(_.starts_with(arg_lead), require("mason-registry").get_installed_package_names())
-            )
-          end,
-        }
-        opts.commands.AstroMasonUpdateAll =
-          { function() require("astrocore.mason").update_all() end, desc = "Update Mason Packages" }
-      end,
-    },
-  },
-  opts = {
-    ui = {
-      icons = {
-        package_installed = "✓",
-        package_uninstalled = "✗",
-        package_pending = "⟳",
-      },
-    },
-  },
-  build = ":MasonUpdate",
-}
diff --git a/lua/astronvim/plugins/mini-bufremove.lua b/lua/astronvim/plugins/mini-bufremove.lua
deleted file mode 100644
index bd15ab7..0000000
--- a/lua/astronvim/plugins/mini-bufremove.lua
+++ /dev/null
@@ -1 +0,0 @@
-return { "echasnovski/mini.bufremove", lazy = true }
diff --git a/lua/astronvim/plugins/neodev.lua b/lua/astronvim/plugins/neodev.lua
deleted file mode 100644
index 9d2aa7e..0000000
--- a/lua/astronvim/plugins/neodev.lua
+++ /dev/null
@@ -1 +0,0 @@
-return { "folke/neodev.nvim", lazy = true, opts = {} }
diff --git a/lua/astronvim/plugins/none-ls.lua b/lua/astronvim/plugins/none-ls.lua
deleted file mode 100644
index 222b903..0000000
--- a/lua/astronvim/plugins/none-ls.lua
+++ /dev/null
@@ -1,27 +0,0 @@
-return {
-  "nvimtools/none-ls.nvim",
-  main = "null-ls",
-  dependencies = {
-    { "nvim-lua/plenary.nvim", lazy = true },
-    {
-      "AstroNvim/astrolsp",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>lI"] = {
-          "<Cmd>NullLsInfo<CR>",
-          desc = "Null-ls information",
-          cond = function() return vim.fn.exists ":NullLsInfo" > 0 end,
-        }
-      end,
-    },
-    {
-      "jay-babu/mason-null-ls.nvim",
-      dependencies = { "williamboman/mason.nvim" },
-      cmd = { "NullLsInstall", "NullLsUninstall" },
-      init = function(plugin) require("astrocore").on_load("mason.nvim", plugin.name) end,
-      opts = { ensure_installed = {}, handlers = {} },
-    },
-  },
-  event = "User AstroFile",
-  opts = function() return { on_attach = require("astrolsp").on_attach } end,
-}
diff --git a/lua/astronvim/plugins/notify.lua b/lua/astronvim/plugins/notify.lua
deleted file mode 100644
index ac502c9..0000000
--- a/lua/astronvim/plugins/notify.lua
+++ /dev/null
@@ -1,44 +0,0 @@
-return {
-  "rcarriga/nvim-notify",
-  lazy = true,
-  dependencies = {
-    { "nvim-lua/plenary.nvim", lazy = true },
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>uD"] = {
-          function() require("notify").dismiss { pending = true, silent = true } end,
-          desc = "Dismiss notifications",
-        }
-      end,
-    },
-  },
-  init = function() require("astrocore").load_plugin_with_func("nvim-notify", vim, "notify") end,
-  opts = function(_, opts)
-    local get_icon = require("astroui").get_icon
-    opts.icons = {
-      DEBUG = get_icon "Debugger",
-      ERROR = get_icon "DiagnosticError",
-      INFO = get_icon "DiagnosticInfo",
-      TRACE = get_icon "DiagnosticHint",
-      WARN = get_icon "DiagnosticWarn",
-    }
-    opts.max_height = function() return math.floor(vim.o.lines * 0.75) end
-    opts.max_width = function() return math.floor(vim.o.columns * 0.75) end
-    opts.on_open = function(win)
-      local astrocore = require "astrocore"
-      vim.api.nvim_win_set_config(win, { zindex = 175 })
-      if not astrocore.config.features.notifications then
-        vim.api.nvim_win_close(win, true)
-        return
-      end
-      if astrocore.is_available "nvim-treesitter" then require("lazy").load { plugins = { "nvim-treesitter" } } end
-      vim.wo[win].conceallevel = 3
-      local buf = vim.api.nvim_win_get_buf(win)
-      if not pcall(vim.treesitter.start, buf, "markdown") then vim.bo[buf].syntax = "markdown" end
-      vim.wo[win].spell = false
-    end
-  end,
-  config = function(...) require "astronvim.plugins.configs.notify"(...) end,
-}
diff --git a/lua/astronvim/plugins/nvim-ufo.lua b/lua/astronvim/plugins/nvim-ufo.lua
deleted file mode 100644
index 77bbac6..0000000
--- a/lua/astronvim/plugins/nvim-ufo.lua
+++ /dev/null
@@ -1,59 +0,0 @@
-return {
-  {
-    "kevinhwang91/nvim-ufo",
-    event = { "User AstroFile", "InsertEnter" },
-    dependencies = {
-      { "kevinhwang91/promise-async", lazy = true },
-      {
-        "AstroNvim/astrocore",
-        opts = function(_, opts)
-          local maps = opts.mappings
-          maps.n["zR"] = { function() require("ufo").openAllFolds() end, desc = "Open all folds" }
-          maps.n["zM"] = { function() require("ufo").closeAllFolds() end, desc = "Close all folds" }
-          maps.n["zr"] = { function() require("ufo").openFoldsExceptKinds() end, desc = "Fold less" }
-          maps.n["zm"] = { function() require("ufo").closeFoldsWith() end, desc = "Fold more" }
-          maps.n["zp"] = { function() require("ufo").peekFoldedLinesUnderCursor() end, desc = "Peek fold" }
-        end,
-      },
-    },
-    opts = {
-      preview = {
-        mappings = {
-          scrollB = "<C-B>",
-          scrollF = "<C-F>",
-          scrollU = "<C-U>",
-          scrollD = "<C-D>",
-        },
-      },
-      provider_selector = function(_, filetype, buftype)
-        local function handleFallbackException(bufnr, err, providerName)
-          if type(err) == "string" and err:match "UfoFallbackException" then
-            return require("ufo").getFolds(bufnr, providerName)
-          else
-            return require("promise").reject(err)
-          end
-        end
-
-        return (filetype == "" or buftype == "nofile") and "indent" -- only use indent until a file is opened
-          or function(bufnr)
-            return require("ufo")
-              .getFolds(bufnr, "lsp")
-              :catch(function(err) return handleFallbackException(bufnr, err, "treesitter") end)
-              :catch(function(err) return handleFallbackException(bufnr, err, "indent") end)
-          end
-      end,
-    },
-  },
-  {
-    "AstroNvim/astrolsp",
-    optional = true,
-    opts = function(_, opts)
-      local astrocore = require "astrocore"
-      if astrocore.is_available "nvim-ufo" then
-        opts.capabilities = astrocore.extend_tbl(opts.capabilities, {
-          textDocument = { foldingRange = { dynamicRegistration = false, lineFoldingOnly = true } },
-        })
-      end
-    end,
-  },
-}
diff --git a/lua/astronvim/plugins/resession.lua b/lua/astronvim/plugins/resession.lua
deleted file mode 100644
index c3181ff..0000000
--- a/lua/astronvim/plugins/resession.lua
+++ /dev/null
@@ -1,50 +0,0 @@
-return {
-  "stevearc/resession.nvim",
-  lazy = true,
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>S"] = vim.tbl_get(opts, "_map_sections", "S")
-        maps.n["<Leader>Sl"] = { function() require("resession").load "Last Session" end, desc = "Load last session" }
-        maps.n["<Leader>Ss"] = { function() require("resession").save() end, desc = "Save this session" }
-        maps.n["<Leader>SS"] = {
-          function() require("resession").save(vim.fn.getcwd(), { dir = "dirsession" }) end,
-          desc = "Save this dirsession",
-        }
-        maps.n["<Leader>St"] = { function() require("resession").save_tab() end, desc = "Save this tab's session" }
-        maps.n["<Leader>Sd"] = { function() require("resession").delete() end, desc = "Delete a session" }
-        maps.n["<Leader>SD"] =
-          { function() require("resession").delete(nil, { dir = "dirsession" }) end, desc = "Delete a dirsession" }
-        maps.n["<Leader>Sf"] = { function() require("resession").load() end, desc = "Load a session" }
-        maps.n["<Leader>SF"] =
-          { function() require("resession").load(nil, { dir = "dirsession" }) end, desc = "Load a dirsession" }
-        maps.n["<Leader>S."] = {
-          function() require("resession").load(vim.fn.getcwd(), { dir = "dirsession" }) end,
-          desc = "Load current dirsession",
-        }
-        opts.autocmds.resession_auto_save = {
-          {
-            event = "VimLeavePre",
-            desc = "Save session on close",
-            callback = function()
-              local buf_utils = require "astrocore.buffer"
-              local autosave = buf_utils.sessions.autosave
-              if autosave and buf_utils.is_valid_session() then
-                local save = require("resession").save
-                if autosave.last then save("Last Session", { notify = false }) end
-                if autosave.cwd then save(vim.fn.getcwd(), { dir = "dirsession", notify = false }) end
-              end
-            end,
-          },
-        }
-      end,
-    },
-  },
-  opts = {
-    buf_filter = function(bufnr) return require("astrocore.buffer").is_restorable(bufnr) end,
-    tab_buf_filter = function(tabpage, bufnr) return vim.tbl_contains(vim.t[tabpage].bufs, bufnr) end,
-    extensions = { astrocore = { enable_in_tab = true } },
-  },
-}
diff --git a/lua/astronvim/plugins/smart-splits.lua b/lua/astronvim/plugins/smart-splits.lua
deleted file mode 100644
index 27a0584..0000000
--- a/lua/astronvim/plugins/smart-splits.lua
+++ /dev/null
@@ -1,21 +0,0 @@
-return {
-  "mrjones2014/smart-splits.nvim",
-  event = "VeryLazy", -- load on very lazy for mux detection
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<C-H>"] = { function() require("smart-splits").move_cursor_left() end, desc = "Move to left split" }
-        maps.n["<C-J>"] = { function() require("smart-splits").move_cursor_down() end, desc = "Move to below split" }
-        maps.n["<C-K>"] = { function() require("smart-splits").move_cursor_up() end, desc = "Move to above split" }
-        maps.n["<C-L>"] = { function() require("smart-splits").move_cursor_right() end, desc = "Move to right split" }
-        maps.n["<C-Up>"] = { function() require("smart-splits").resize_up() end, desc = "Resize split up" }
-        maps.n["<C-Down>"] = { function() require("smart-splits").resize_down() end, desc = "Resize split down" }
-        maps.n["<C-Left>"] = { function() require("smart-splits").resize_left() end, desc = "Resize split left" }
-        maps.n["<C-Right>"] = { function() require("smart-splits").resize_right() end, desc = "Resize split right" }
-      end,
-    },
-  },
-  opts = { ignored_filetypes = { "nofile", "quickfix", "qf", "prompt" }, ignored_buftypes = { "nofile" } },
-}
diff --git a/lua/astronvim/plugins/telescope.lua b/lua/astronvim/plugins/telescope.lua
deleted file mode 100644
index 5c75324..0000000
--- a/lua/astronvim/plugins/telescope.lua
+++ /dev/null
@@ -1,172 +0,0 @@
-return {
-  {
-    "nvim-telescope/telescope.nvim",
-    dependencies = {
-      { "nvim-lua/plenary.nvim", lazy = true },
-      {
-        "nvim-telescope/telescope-fzf-native.nvim",
-        lazy = true,
-        enabled = vim.fn.executable "make" == 1,
-        build = "make",
-      },
-      "nvim-treesitter/nvim-treesitter",
-      {
-        "AstroNvim/astrocore",
-        opts = function(_, opts)
-          local maps = opts.mappings
-          local astro = require "astrocore"
-          local is_available = astro.is_available
-          maps.n["<Leader>f"] = vim.tbl_get(opts, "_map_sections", "f")
-          if vim.fn.executable "git" == 1 then
-            maps.n["<Leader>g"] = vim.tbl_get(opts, "_map_sections", "g")
-            maps.n["<Leader>gb"] = {
-              function() require("telescope.builtin").git_branches { use_file_path = true } end,
-              desc = "Git branches",
-            }
-            maps.n["<Leader>gc"] = {
-              function() require("telescope.builtin").git_commits { use_file_path = true } end,
-              desc = "Git commits (repository)",
-            }
-            maps.n["<Leader>gC"] = {
-              function() require("telescope.builtin").git_bcommits { use_file_path = true } end,
-              desc = "Git commits (current file)",
-            }
-            maps.n["<Leader>gt"] =
-              { function() require("telescope.builtin").git_status { use_file_path = true } end, desc = "Git status" }
-          end
-          maps.n["<Leader>f<CR>"] =
-            { function() require("telescope.builtin").resume() end, desc = "Resume previous search" }
-          maps.n["<Leader>f'"] = { function() require("telescope.builtin").marks() end, desc = "Find marks" }
-          maps.n["<Leader>f/"] = {
-            function() require("telescope.builtin").current_buffer_fuzzy_find() end,
-            desc = "Find words in current buffer",
-          }
-          maps.n["<Leader>fa"] = {
-            function()
-              require("telescope.builtin").find_files {
-                prompt_title = "Config Files",
-                cwd = vim.fn.stdpath "config",
-                follow = true,
-              }
-            end,
-            desc = "Find AstroNvim config files",
-          }
-          maps.n["<Leader>fb"] = { function() require("telescope.builtin").buffers() end, desc = "Find buffers" }
-          maps.n["<Leader>fc"] =
-            { function() require("telescope.builtin").grep_string() end, desc = "Find word under cursor" }
-          maps.n["<Leader>fC"] = { function() require("telescope.builtin").commands() end, desc = "Find commands" }
-          maps.n["<Leader>ff"] = { function() require("telescope.builtin").find_files() end, desc = "Find files" }
-          maps.n["<Leader>fF"] = {
-            function() require("telescope.builtin").find_files { hidden = true, no_ignore = true } end,
-            desc = "Find all files",
-          }
-          maps.n["<Leader>fh"] = { function() require("telescope.builtin").help_tags() end, desc = "Find help" }
-          maps.n["<Leader>fk"] = { function() require("telescope.builtin").keymaps() end, desc = "Find keymaps" }
-          maps.n["<Leader>fm"] = { function() require("telescope.builtin").man_pages() end, desc = "Find man" }
-          if is_available "nvim-notify" then
-            maps.n["<Leader>fn"] =
-              { function() require("telescope").extensions.notify.notify() end, desc = "Find notifications" }
-          end
-          maps.n["<Leader>fo"] = { function() require("telescope.builtin").oldfiles() end, desc = "Find history" }
-          maps.n["<Leader>fr"] = { function() require("telescope.builtin").registers() end, desc = "Find registers" }
-          maps.n["<Leader>ft"] =
-            { function() require("telescope.builtin").colorscheme { enable_preview = true } end, desc = "Find themes" }
-          if vim.fn.executable "rg" == 1 then
-            maps.n["<Leader>fw"] = { function() require("telescope.builtin").live_grep() end, desc = "Find words" }
-            maps.n["<Leader>fW"] = {
-              function()
-                require("telescope.builtin").live_grep {
-                  additional_args = function(args) return vim.list_extend(args, { "--hidden", "--no-ignore" }) end,
-                }
-              end,
-              desc = "Find words in all files",
-            }
-          end
-          maps.n["<Leader>ls"] = {
-            function()
-              if is_available "aerial.nvim" then
-                require("telescope").extensions.aerial.aerial()
-              else
-                require("telescope.builtin").lsp_document_symbols()
-              end
-            end,
-            desc = "Search symbols",
-          }
-          if vim.fn.has "nvim-0.10" == 1 then
-            maps.n.gr = { function() require("telescope.builtin").lsp_references() end, desc = "Search references" }
-          end
-        end,
-      },
-    },
-    cmd = "Telescope",
-    opts = function()
-      local actions = require "telescope.actions"
-      local get_icon = require("astroui").get_icon
-      return {
-        defaults = {
-          git_worktrees = require("astrocore").config.git_worktrees,
-          prompt_prefix = get_icon("Selected", 1),
-          selection_caret = get_icon("Selected", 1),
-          path_display = { "truncate" },
-          sorting_strategy = "ascending",
-          layout_config = {
-            horizontal = { prompt_position = "top", preview_width = 0.55 },
-            vertical = { mirror = false },
-            width = 0.87,
-            height = 0.80,
-            preview_cutoff = 120,
-          },
-          mappings = {
-            i = {
-              ["<C-N>"] = actions.cycle_history_next,
-              ["<C-P>"] = actions.cycle_history_prev,
-              ["<C-J>"] = actions.move_selection_next,
-              ["<C-K>"] = actions.move_selection_previous,
-            },
-            n = { q = actions.close },
-          },
-        },
-      }
-    end,
-    config = function(...) require "astronvim.plugins.configs.telescope"(...) end,
-  },
-  {
-    "AstroNvim/astrolsp",
-    optional = true,
-    opts = function(_, opts)
-      if require("astrocore").is_available "telescope.nvim" then
-        local maps = opts.mappings
-        maps.n["<Leader>lD"] =
-          { function() require("telescope.builtin").diagnostics() end, desc = "Search diagnostics" }
-        if maps.n.gd then
-          maps.n.gd[1] = function() require("telescope.builtin").lsp_definitions { reuse_win = true } end
-        end
-        if maps.n.gI then
-          maps.n.gI[1] = function() require("telescope.builtin").lsp_implementations { reuse_win = true } end
-        end
-        -- TODO: remove when dropping support for Neovim v0.9
-        if maps.n.gr then maps.n.gr[1] = function() require("telescope.builtin").lsp_references() end end
-        if maps.n["<Leader>lR"] then
-          maps.n["<Leader>lR"][1] = function() require("telescope.builtin").lsp_references() end
-        end
-        if maps.n.gy then
-          maps.n.gy[1] = function() require("telescope.builtin").lsp_type_definitions { reuse_win = true } end
-        end
-        if maps.n["<Leader>lG"] then
-          maps.n["<Leader>lG"][1] = function()
-            vim.ui.input({ prompt = "Symbol Query: (leave empty for word under cursor)" }, function(query)
-              if query then
-                -- word under cursor if given query is empty
-                if query == "" then query = vim.fn.expand "<cword>" end
-                require("telescope.builtin").lsp_workspace_symbols {
-                  query = query,
-                  prompt_title = ("Find word (%s)"):format(query),
-                }
-              end
-            end)
-          end
-        end
-      end
-    end,
-  },
-}
diff --git a/lua/astronvim/plugins/todo-comments.lua b/lua/astronvim/plugins/todo-comments.lua
deleted file mode 100644
index 890ae61..0000000
--- a/lua/astronvim/plugins/todo-comments.lua
+++ /dev/null
@@ -1,20 +0,0 @@
-return {
-  "folke/todo-comments.nvim",
-  cmd = { "TodoTrouble", "TodoTelescope", "TodoLocList", "TodoQuickFix" },
-  event = "User AstroFile",
-  dependencies = {
-    { "nvim-lua/plenary.nvim", lazy = true },
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        if require("astrocore").is_available "telescope.nvim" then
-          maps.n["<Leader>fT"] = { "<Cmd>TodoTelescope<CR>", desc = "Find TODOs" }
-        end
-        maps.n["]T"] = { function() require("todo-comments").jump_next() end, desc = "Next TODO comment" }
-        maps.n["[T"] = { function() require("todo-comments").jump_prev() end, desc = "Previous TODO comment" }
-      end,
-    },
-  },
-  opts = {},
-}
diff --git a/lua/astronvim/plugins/toggleterm.lua b/lua/astronvim/plugins/toggleterm.lua
deleted file mode 100644
index 3555eb9..0000000
--- a/lua/astronvim/plugins/toggleterm.lua
+++ /dev/null
@@ -1,77 +0,0 @@
-return {
-  "akinsho/toggleterm.nvim",
-  cmd = { "ToggleTerm", "TermExec" },
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        local astro = require "astrocore"
-        maps.n["<Leader>t"] = vim.tbl_get(opts, "_map_sections", "t")
-        if vim.fn.executable "git" == 1 and vim.fn.executable "lazygit" == 1 then
-          maps.n["<Leader>g"] = vim.tbl_get(opts, "_map_sections", "g")
-          maps.n["<Leader>gg"] = {
-            function()
-              local worktree = astro.file_worktree()
-              local flags = worktree and (" --work-tree=%s --git-dir=%s"):format(worktree.toplevel, worktree.gitdir)
-                or ""
-              astro.toggle_term_cmd("lazygit " .. flags)
-            end,
-            desc = "ToggleTerm lazygit",
-          }
-          maps.n["<Leader>tl"] = maps.n["<Leader>gg"]
-        end
-        if vim.fn.executable "node" == 1 then
-          maps.n["<Leader>tn"] = { function() astro.toggle_term_cmd "node" end, desc = "ToggleTerm node" }
-        end
-        local gdu = vim.fn.has "mac" == 1 and "gdu-go" or "gdu"
-        if vim.fn.executable(gdu) == 1 then
-          maps.n["<Leader>tu"] = { function() astro.toggle_term_cmd(gdu) end, desc = "ToggleTerm gdu" }
-        end
-        if vim.fn.executable "btm" == 1 then
-          maps.n["<Leader>tt"] = { function() astro.toggle_term_cmd "btm" end, desc = "ToggleTerm btm" }
-        end
-        local python = vim.fn.executable "python" == 1 and "python" or vim.fn.executable "python3" == 1 and "python3"
-        if python then
-          maps.n["<Leader>tp"] = { function() astro.toggle_term_cmd(python) end, desc = "ToggleTerm python" }
-        end
-        maps.n["<Leader>tf"] = { "<Cmd>ToggleTerm direction=float<CR>", desc = "ToggleTerm float" }
-        maps.n["<Leader>th"] =
-          { "<Cmd>ToggleTerm size=10 direction=horizontal<CR>", desc = "ToggleTerm horizontal split" }
-        maps.n["<Leader>tv"] = { "<Cmd>ToggleTerm size=80 direction=vertical<CR>", desc = "ToggleTerm vertical split" }
-        maps.n["<F7>"] = { '<Cmd>execute v:count . "ToggleTerm"<CR>', desc = "Toggle terminal" }
-        maps.t["<F7>"] = { "<Cmd>ToggleTerm<CR>", desc = maps.n["<F7>"].desc }
-        maps.i["<F7>"] = { "<Esc>" .. maps.t["<F7>"][1], desc = maps.n["<F7>"].desc }
-        maps.n["<C-'>"] = maps.n["<F7>"] -- requires terminal that supports binding <C-'>
-        maps.t["<C-'>"] = maps.t["<F7>"] -- requires terminal that supports binding <C-'>
-        maps.i["<C-'>"] = maps.i["<F7>"] -- requires terminal that supports binding <C-'>
-      end,
-    },
-  },
-  opts = {
-    highlights = {
-      Normal = { link = "Normal" },
-      NormalNC = { link = "NormalNC" },
-      NormalFloat = { link = "NormalFloat" },
-      FloatBorder = { link = "FloatBorder" },
-      StatusLine = { link = "StatusLine" },
-      StatusLineNC = { link = "StatusLineNC" },
-      WinBar = { link = "WinBar" },
-      WinBarNC = { link = "WinBarNC" },
-    },
-    size = 10,
-    ---@param t Terminal
-    on_create = function(t)
-      vim.opt_local.foldcolumn = "0"
-      vim.opt_local.signcolumn = "no"
-      if t.hidden then
-        local toggle = function() t:toggle() end
-        vim.keymap.set({ "n", "t", "i" }, "<C-'>", toggle, { desc = "Toggle terminal", buffer = t.bufnr })
-        vim.keymap.set({ "n", "t", "i" }, "<F7>", toggle, { desc = "Toggle terminal", buffer = t.bufnr })
-      end
-    end,
-    shading_factor = 2,
-    direction = "float",
-    float_opts = { border = "rounded" },
-  },
-}
diff --git a/lua/astronvim/plugins/ts-autotag.lua b/lua/astronvim/plugins/ts-autotag.lua
deleted file mode 100644
index 1fbca18..0000000
--- a/lua/astronvim/plugins/ts-autotag.lua
+++ /dev/null
@@ -1,6 +0,0 @@
-return {
-  "windwp/nvim-ts-autotag",
-  event = "User AstroFile",
-  opts = {},
-  config = function(...) require "astronvim.plugins.configs.ts-autotag"(...) end,
-}
diff --git a/lua/astronvim/plugins/vim-illuminate.lua b/lua/astronvim/plugins/vim-illuminate.lua
deleted file mode 100644
index 47f5a84..0000000
--- a/lua/astronvim/plugins/vim-illuminate.lua
+++ /dev/null
@@ -1,29 +0,0 @@
-return {
-  "RRethy/vim-illuminate",
-  event = "User AstroFile",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["]r"] = { function() require("illuminate")["goto_next_reference"](false) end, desc = "Next reference" }
-        maps.n["[r"] =
-          { function() require("illuminate")["goto_prev_reference"](false) end, desc = "Previous reference" }
-        maps.n["<Leader>ur"] =
-          { function() require("illuminate").toggle_buf() end, desc = "Toggle reference highlighting (buffer)" }
-        maps.n["<Leader>uR"] =
-          { function() require("illuminate").toggle() end, desc = "Toggle reference highlighting (global)" }
-      end,
-    },
-  },
-  opts = function()
-    return {
-      delay = 200,
-      min_count_to_highlight = 2,
-      large_file_cutoff = vim.tbl_get(require "astrocore", "config", "features", "large_buf", "lines"),
-      large_file_overrides = { providers = { "lsp" } },
-      should_enable = function(bufnr) return require("astrocore.buffer").is_valid(bufnr) end,
-    }
-  end,
-  config = function(...) require "astronvim.plugins.configs.vim-illuminate"(...) end,
-}
diff --git a/lua/astronvim/plugins/web-devicons.lua b/lua/astronvim/plugins/web-devicons.lua
deleted file mode 100644
index 95be1bd..0000000
--- a/lua/astronvim/plugins/web-devicons.lua
+++ /dev/null
@@ -1,24 +0,0 @@
-return {
-  "nvim-tree/nvim-web-devicons",
-  lazy = true,
-  enabled = vim.g.icons_enabled ~= false,
-  opts = function()
-    return {
-      override = {
-        default_icon = { icon = require("astroui").get_icon "DefaultFile" },
-        deb = { icon = "", name = "Deb" },
-        lock = { icon = "󰌾", name = "Lock" },
-        mp3 = { icon = "󰎆", name = "Mp3" },
-        mp4 = { icon = "", name = "Mp4" },
-        out = { icon = "", name = "Out" },
-        ["robots.txt"] = { icon = "󰚩", name = "Robots" },
-        ttf = { icon = "", name = "TrueTypeFont" },
-        rpm = { icon = "", name = "Rpm" },
-        woff = { icon = "", name = "WebOpenFontFormat" },
-        woff2 = { icon = "", name = "WebOpenFontFormat2" },
-        xz = { icon = "", name = "Xz" },
-        zip = { icon = "", name = "Zip" },
-      },
-    }
-  end,
-}
diff --git a/lua/astronvim/plugins/which-key.lua b/lua/astronvim/plugins/which-key.lua
deleted file mode 100644
index a73715c..0000000
--- a/lua/astronvim/plugins/which-key.lua
+++ /dev/null
@@ -1,11 +0,0 @@
-return {
-  "folke/which-key.nvim",
-  event = "VeryLazy",
-  opts = {
-    icons = {
-      group = vim.g.icons_enabled ~= false and "" or "+",
-      separator = "-",
-    },
-    disable = { filetypes = { "TelescopePrompt" } },
-  },
-}
diff --git a/lua/astronvim/plugins/window-picker.lua b/lua/astronvim/plugins/window-picker.lua
deleted file mode 100644
index 4a42cd6..0000000
--- a/lua/astronvim/plugins/window-picker.lua
+++ /dev/null
@@ -1,6 +0,0 @@
-return {
-  "s1n7ax/nvim-window-picker",
-  main = "window-picker",
-  lazy = true,
-  opts = { picker_config = { statusline_winbar_picker = { use_winbar = "smart" } } },
-}
diff --git a/lua/astronvim/utils/buffer.lua b/lua/astronvim/utils/buffer.lua
new file mode 100644
index 0000000..f440100
--- /dev/null
+++ b/lua/astronvim/utils/buffer.lua
@@ -0,0 +1,269 @@
+--- ### AstroNvim Buffer Utilities
+--
+-- Buffer management related utility functions
+--
+-- This module can be loaded with `local buffer_utils = require "astronvim.utils.buffer"`
+--
+-- @module astronvim.utils.buffer
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local utils = require "astronvim.utils"
+
+--- Placeholders for keeping track of most recent and previous buffer
+M.current_buf, M.last_buf = nil, nil
+
+-- TODO: Add user configuration table for this once resession is default
+--- Configuration table for controlling session options
+M.sessions = {
+  autosave = {
+    last = true, -- auto save last session
+    cwd = true, -- auto save session for each working directory
+  },
+  ignore = {
+    dirs = {}, -- working directories to ignore sessions in
+    filetypes = { "gitcommit", "gitrebase" }, -- filetypes to ignore sessions
+    buftypes = {}, -- buffer types to ignore sessions
+  },
+}
+
+--- Check if a buffer is valid
+---@param bufnr number? The buffer to check, default to current buffer
+---@return boolean # Whether the buffer is valid or not
+function M.is_valid(bufnr)
+  if not bufnr then bufnr = 0 end
+  return vim.api.nvim_buf_is_valid(bufnr) and vim.bo[bufnr].buflisted
+end
+
+--- Check if a buffer can be restored
+---@param bufnr number The buffer to check
+---@return boolean # Whether the buffer is restorable or not
+function M.is_restorable(bufnr)
+  if not M.is_valid(bufnr) or vim.api.nvim_get_option_value("bufhidden", { buf = bufnr }) ~= "" then return false end
+
+  local buftype = vim.api.nvim_get_option_value("buftype", { buf = bufnr })
+  if buftype == "" then
+    -- Normal buffer, check if it listed.
+    if not vim.api.nvim_get_option_value("buflisted", { buf = bufnr }) then return false end
+    -- Check if it has a filename.
+    if vim.api.nvim_buf_get_name(bufnr) == "" then return false end
+  end
+
+  if
+    vim.tbl_contains(M.sessions.ignore.filetypes, vim.api.nvim_get_option_value("filetype", { buf = bufnr }))
+    or vim.tbl_contains(M.sessions.ignore.buftypes, vim.api.nvim_get_option_value("buftype", { buf = bufnr }))
+  then
+    return false
+  end
+  return true
+end
+
+--- Check if the current buffers form a valid session
+---@return boolean # Whether the current session of buffers is a valid session
+function M.is_valid_session()
+  local cwd = vim.fn.getcwd()
+  for _, dir in ipairs(M.sessions.ignore.dirs) do
+    if vim.fn.expand(dir) == cwd then return false end
+  end
+  for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
+    if M.is_restorable(bufnr) then return true end
+  end
+  return false
+end
+
+--- Move the current buffer tab n places in the bufferline
+---@param n number The number of tabs to move the current buffer over by (positive = right, negative = left)
+function M.move(n)
+  if n == 0 then return end -- if n = 0 then no shifts are needed
+  local bufs = vim.t.bufs -- make temp variable
+  for i, bufnr in ipairs(bufs) do -- loop to find current buffer
+    if bufnr == vim.api.nvim_get_current_buf() then -- found index of current buffer
+      for _ = 0, (n % #bufs) - 1 do -- calculate number of right shifts
+        local new_i = i + 1 -- get next i
+        if i == #bufs then -- if at end, cycle to beginning
+          new_i = 1 -- next i is actually 1 if at the end
+          local val = bufs[i] -- save value
+          table.remove(bufs, i) -- remove from end
+          table.insert(bufs, new_i, val) -- insert at beginning
+        else -- if not at the end,then just do an in place swap
+          bufs[i], bufs[new_i] = bufs[new_i], bufs[i]
+        end
+        i = new_i -- iterate i to next value
+      end
+      break
+    end
+  end
+  vim.t.bufs = bufs -- set buffers
+  utils.event "BufsUpdated"
+  vim.cmd.redrawtabline() -- redraw tabline
+end
+
+--- Navigate left and right by n places in the bufferline
+-- @param n number The number of tabs to navigate to (positive = right, negative = left)
+function M.nav(n)
+  local current = vim.api.nvim_get_current_buf()
+  for i, v in ipairs(vim.t.bufs) do
+    if current == v then
+      vim.cmd.b(vim.t.bufs[(i + n - 1) % #vim.t.bufs + 1])
+      break
+    end
+  end
+end
+
+--- Navigate to a specific buffer by its position in the bufferline
+---@param tabnr number The position of the buffer to navigate to
+function M.nav_to(tabnr)
+  if tabnr > #vim.t.bufs or tabnr < 1 then
+    utils.notify(("No tab #%d"):format(tabnr), vim.log.levels.WARN)
+  else
+    vim.cmd.b(vim.t.bufs[tabnr])
+  end
+end
+
+--- Navigate to the previously used buffer
+function M.prev()
+  if vim.fn.bufnr() == M.current_buf then
+    if M.last_buf then
+      vim.cmd.b(M.last_buf)
+    else
+      utils.notify("No previous buffer found", vim.log.levels.WARN)
+    end
+  else
+    utils.notify("Must be in a main editor window to switch the window buffer", vim.log.levels.ERROR)
+  end
+end
+
+--- Close a given buffer
+---@param bufnr? number The buffer to close or the current buffer if not provided
+---@param force? boolean Whether or not to foce close the buffers or confirm changes (default: false)
+function M.close(bufnr, force)
+  if not bufnr or bufnr == 0 then bufnr = vim.api.nvim_get_current_buf() end
+  if utils.is_available "mini.bufremove" and M.is_valid(bufnr) and #vim.t.bufs > 1 then
+    if not force and vim.api.nvim_get_option_value("modified", { buf = bufnr }) then
+      local bufname = vim.fn.expand "%"
+      local empty = bufname == ""
+      if empty then bufname = "Untitled" end
+      local confirm = vim.fn.confirm(('Save changes to "%s"?'):format(bufname), "&Yes\n&No\n&Cancel", 1, "Question")
+      if confirm == 1 then
+        if empty then return end
+        vim.cmd.write()
+      elseif confirm == 2 then
+        force = true
+      else
+        return
+      end
+    end
+    require("mini.bufremove").delete(bufnr, force)
+  else
+    local buftype = vim.api.nvim_get_option_value("buftype", { buf = bufnr })
+    vim.cmd(("silent! %s %d"):format((force or buftype == "terminal") and "bdelete!" or "confirm bdelete", bufnr))
+  end
+end
+
+--- Close all buffers
+---@param keep_current? boolean Whether or not to keep the current buffer (default: false)
+---@param force? boolean Whether or not to foce close the buffers or confirm changes (default: false)
+function M.close_all(keep_current, force)
+  if keep_current == nil then keep_current = false end
+  local current = vim.api.nvim_get_current_buf()
+  for _, bufnr in ipairs(vim.t.bufs) do
+    if not keep_current or bufnr ~= current then M.close(bufnr, force) end
+  end
+end
+
+--- Close buffers to the left of the current buffer
+---@param force? boolean Whether or not to foce close the buffers or confirm changes (default: false)
+function M.close_left(force)
+  local current = vim.api.nvim_get_current_buf()
+  for _, bufnr in ipairs(vim.t.bufs) do
+    if bufnr == current then break end
+    M.close(bufnr, force)
+  end
+end
+
+--- Close buffers to the right of the current buffer
+---@param force? boolean Whether or not to foce close the buffers or confirm changes (default: false)
+function M.close_right(force)
+  local current = vim.api.nvim_get_current_buf()
+  local after_current = false
+  for _, bufnr in ipairs(vim.t.bufs) do
+    if after_current then M.close(bufnr, force) end
+    if bufnr == current then after_current = true end
+  end
+end
+
+--- Sort a the buffers in the current tab based on some comparator
+---@param compare_func string|function a string of a comparator defined in require("astronvim.utils.buffer").comparator or a custom comparator function
+---@param skip_autocmd boolean|nil whether or not to skip triggering AstroBufsUpdated autocmd event
+---@return boolean # Whether or not the buffers were sorted
+function M.sort(compare_func, skip_autocmd)
+  if type(compare_func) == "string" then compare_func = M.comparator[compare_func] end
+  if type(compare_func) == "function" then
+    local bufs = vim.t.bufs
+    table.sort(bufs, compare_func)
+    vim.t.bufs = bufs
+    if not skip_autocmd then utils.event "BufsUpdated" end
+    vim.cmd.redrawtabline()
+    return true
+  end
+  return false
+end
+
+--- Close a given tab
+---@param tabpage? integer The tabpage to close or the current tab if not provided
+function M.close_tab(tabpage)
+  if #vim.api.nvim_list_tabpages() > 1 then
+    tabpage = tabpage or vim.api.nvim_get_current_tabpage()
+    vim.t[tabpage].bufs = nil
+    utils.event "BufsUpdated"
+    vim.cmd.tabclose(vim.api.nvim_tabpage_get_number(tabpage))
+  end
+end
+
+--- A table of buffer comparator functions
+M.comparator = {}
+
+local fnamemodify = vim.fn.fnamemodify
+local function bufinfo(bufnr) return vim.fn.getbufinfo(bufnr)[1] end
+local function unique_path(bufnr)
+  return require("astronvim.utils.status.provider").unique_path() { bufnr = bufnr }
+    .. fnamemodify(bufinfo(bufnr).name, ":t")
+end
+
+--- Comparator of two buffer numbers
+---@param bufnr_a integer buffer number A
+---@param bufnr_b integer buffer number B
+---@return boolean comparison true if A is sorted before B, false if B should be sorted before A
+function M.comparator.bufnr(bufnr_a, bufnr_b) return bufnr_a < bufnr_b end
+
+--- Comparator of two buffer numbers based on the file extensions
+---@param bufnr_a integer buffer number A
+---@param bufnr_b integer buffer number B
+---@return boolean comparison true if A is sorted before B, false if B should be sorted before A
+function M.comparator.extension(bufnr_a, bufnr_b)
+  return fnamemodify(bufinfo(bufnr_a).name, ":e") < fnamemodify(bufinfo(bufnr_b).name, ":e")
+end
+
+--- Comparator of two buffer numbers based on the full path
+---@param bufnr_a integer buffer number A
+---@param bufnr_b integer buffer number B
+---@return boolean comparison true if A is sorted before B, false if B should be sorted before A
+function M.comparator.full_path(bufnr_a, bufnr_b)
+  return fnamemodify(bufinfo(bufnr_a).name, ":p") < fnamemodify(bufinfo(bufnr_b).name, ":p")
+end
+
+--- Comparator of two buffers based on their unique path
+---@param bufnr_a integer buffer number A
+---@param bufnr_b integer buffer number B
+---@return boolean comparison true if A is sorted before B, false if B should be sorted before A
+function M.comparator.unique_path(bufnr_a, bufnr_b) return unique_path(bufnr_a) < unique_path(bufnr_b) end
+
+--- Comparator of two buffers based on modification date
+---@param bufnr_a integer buffer number A
+---@param bufnr_b integer buffer number B
+---@return boolean comparison true if A is sorted before B, false if B should be sorted before A
+function M.comparator.modified(bufnr_a, bufnr_b) return bufinfo(bufnr_a).lastused > bufinfo(bufnr_b).lastused end
+
+return M
diff --git a/lua/astronvim/utils/ffi.lua b/lua/astronvim/utils/ffi.lua
new file mode 100644
index 0000000..3b1487d
--- /dev/null
+++ b/lua/astronvim/utils/ffi.lua
@@ -0,0 +1,20 @@
+-- ### AstroNvim C Extensions
+
+local ffi = require "ffi"
+
+-- Custom C extension to get direct fold information from Neovim
+ffi.cdef [[
+	typedef struct {} Error;
+	typedef struct {} win_T;
+	typedef struct {
+		int start;  // line number where deepest fold starts
+		int level;  // fold level, when zero other fields are N/A
+		int llevel; // lowest level that starts in v:lnum
+		int lines;  // number of lines from v:lnum to end of closed fold
+	} foldinfo_T;
+	foldinfo_T fold_info(win_T* wp, int lnum);
+	win_T *find_window_by_handle(int Window, Error *err);
+	int compute_foldcolumn(win_T *wp, int col);
+]]
+
+return ffi
diff --git a/lua/astronvim/utils/git.lua b/lua/astronvim/utils/git.lua
new file mode 100644
index 0000000..3f2a205
--- /dev/null
+++ b/lua/astronvim/utils/git.lua
@@ -0,0 +1,215 @@
+--- ### Git LUA API
+--
+-- This module can be loaded with `local git = require "astronvim.utils.git"`
+--
+-- @module astronvim.utils.git
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local git = { url = "https://github.com/" }
+
+local function trim_or_nil(str) return type(str) == "string" and vim.trim(str) or nil end
+
+--- Run a git command from the AstroNvim installation directory
+---@param args string|string[] the git arguments
+---@return string|nil # The result of the command or nil if unsuccessful
+function git.cmd(args, ...)
+  if type(args) == "string" then args = { args } end
+  return require("astronvim.utils").cmd(vim.list_extend({ "git", "-C", astronvim.install.home }, args), ...)
+end
+
+--- Get the first worktree that a file belongs to
+---@param file string? the file to check, defaults to the current file
+---@param worktrees table<string, string>[]? an array like table of worktrees with entries `toplevel` and `gitdir`, default retrieves from `vim.g.git_worktrees`
+---@return table<string, string>|nil # a table specifying the `toplevel` and `gitdir` of a worktree or nil if not found
+function git.file_worktree(file, worktrees)
+  worktrees = worktrees or vim.g.git_worktrees
+  if not worktrees then return end
+  file = file or vim.fn.expand "%"
+  for _, worktree in ipairs(worktrees) do
+    if
+      require("astronvim.utils").cmd({
+        "git",
+        "--work-tree",
+        worktree.toplevel,
+        "--git-dir",
+        worktree.gitdir,
+        "ls-files",
+        "--error-unmatch",
+        file,
+      }, false)
+    then
+      return worktree
+    end
+  end
+end
+
+--- Check if the AstroNvim is able to reach the `git` command
+---@return boolean # The result of running `git --help`
+function git.available() return vim.fn.executable "git" == 1 end
+
+--- Check the git client version number
+---@return table|nil # A table with version information or nil if there is an error
+function git.git_version()
+  local output = git.cmd({ "--version" }, false)
+  if output then
+    local version_str = output:match "%d+%.%d+%.%d"
+    local major, min, patch = unpack(vim.tbl_map(tonumber, vim.split(version_str, "%.")))
+    return { major = major, min = min, patch = patch, str = version_str }
+  end
+end
+
+--- Check if the AstroNvim home is a git repo
+---@return string|nil # The result of the command
+function git.is_repo() return git.cmd({ "rev-parse", "--is-inside-work-tree" }, false) end
+
+--- Fetch git remote
+---@param remote string the remote to fetch
+---@return string|nil # The result of the command
+function git.fetch(remote, ...) return git.cmd({ "fetch", remote }, ...) end
+
+--- Pull the git repo
+---@return string|nil # The result of the command
+function git.pull(...) return git.cmd({ "pull", "--rebase" }, ...) end
+
+--- Checkout git target
+---@param dest string the target to checkout
+---@return string|nil # The result of the command
+function git.checkout(dest, ...) return git.cmd({ "checkout", dest }, ...) end
+
+--- Hard reset to a git target
+-- @param dest the target to hard reset to
+---@return string|nil # The result of the command
+function git.hard_reset(dest, ...) return git.cmd({ "reset", "--hard", dest }, ...) end
+
+--- Check if a branch contains a commit
+---@param remote string the git remote to check
+---@param branch string the git branch to check
+---@param commit string the git commit to check for
+---@return boolean # The result of the command
+function git.branch_contains(remote, branch, commit, ...)
+  return git.cmd({ "merge-base", "--is-ancestor", commit, remote .. "/" .. branch }, ...) ~= nil
+end
+
+--- Get the remote name for a given branch
+---@param branch string the git branch to check
+---@return string|nil # The name of the remote for the given branch
+function git.branch_remote(branch, ...) return trim_or_nil(git.cmd({ "config", "branch." .. branch .. ".remote" }, ...)) end
+
+--- Add a git remote
+---@param remote string the remote to add
+---@param url string the url of the remote
+---@return string|nil # The result of the command
+function git.remote_add(remote, url, ...) return git.cmd({ "remote", "add", remote, url }, ...) end
+
+--- Update a git remote URL
+---@param remote string the remote to update
+---@param url string the new URL of the remote
+---@return string|nil # The result of the command
+function git.remote_update(remote, url, ...) return git.cmd({ "remote", "set-url", remote, url }, ...) end
+
+--- Get the URL of a given git remote
+---@param remote string the remote to get the URL of
+---@return string|nil # The url of the remote
+function git.remote_url(remote, ...) return trim_or_nil(git.cmd({ "remote", "get-url", remote }, ...)) end
+
+--- Get branches from a git remote
+---@param remote string the remote to setup branches for
+---@param branch string the branch to setup
+---@return string|nil # The result of the command
+function git.remote_set_branches(remote, branch, ...) return git.cmd({ "remote", "set-branches", remote, branch }, ...) end
+
+--- Get the current version with git describe including tags
+---@return string|nil # The current git describe string
+function git.current_version(...) return trim_or_nil(git.cmd({ "describe", "--tags" }, ...)) end
+
+--- Get the current branch
+---@return string|nil # The branch of the AstroNvim installation
+function git.current_branch(...) return trim_or_nil(git.cmd({ "rev-parse", "--abbrev-ref", "HEAD" }, ...)) end
+
+--- Verify a reference
+---@return string|nil # The referenced commit
+function git.ref_verify(ref, ...) return trim_or_nil(git.cmd({ "rev-parse", "--verify", ref }, ...)) end
+
+--- Get the current head of the git repo
+---@return string|nil # the head string
+function git.local_head(...) return trim_or_nil(git.cmd({ "rev-parse", "HEAD" }, ...)) end
+
+--- Get the current head of a git remote
+---@param remote string the remote to check
+---@param branch string the branch to check
+---@return string|nil # The head string of the remote branch
+function git.remote_head(remote, branch, ...)
+  return trim_or_nil(git.cmd({ "rev-list", "-n", "1", remote .. "/" .. branch }, ...))
+end
+
+--- Get the commit hash of a given tag
+---@param tag string the tag to resolve
+---@return string|nil # The commit hash of a git tag
+function git.tag_commit(tag, ...) return trim_or_nil(git.cmd({ "rev-list", "-n", "1", tag }, ...)) end
+
+--- Get the commit log between two commit hashes
+---@param start_hash? string the start commit hash
+---@param end_hash? string the end commit hash
+---@return string[] # An array like table of commit messages
+function git.get_commit_range(start_hash, end_hash, ...)
+  local range = start_hash and end_hash and start_hash .. ".." .. end_hash or nil
+  local log = git.cmd({ "log", "--no-merges", '--pretty="format:[%h] %s"', range }, ...)
+  return log and vim.fn.split(log, "\n") or {}
+end
+
+--- Get a list of all tags with a regex filter
+---@param search? string a regex to search the tags with (defaults to "v*" for version tags)
+---@return string[] # An array like table of tags that match the search
+function git.get_versions(search, ...)
+  local tags = git.cmd({ "tag", "-l", "--sort=version:refname", search == "latest" and "v*" or search }, ...)
+  return tags and vim.fn.split(tags, "\n") or {}
+end
+
+--- Get the latest version of a list of versions
+---@param versions? table a list of versions to search (defaults to all versions available)
+---@return string|nil # The latest version from the array
+function git.latest_version(versions, ...)
+  if not versions then versions = git.get_versions(...) end
+  return versions[#versions]
+end
+
+--- Parse a remote url
+---@param str string the remote to parse to a full git url
+---@return string # The full git url for the given remote string
+function git.parse_remote_url(str)
+  return vim.fn.match(str, require("astronvim.utils").url_matcher) == -1
+      and git.url .. str .. (vim.fn.match(str, "/") == -1 and "/AstroNvim.git" or ".git")
+    or str
+end
+
+--- Check if a Conventional Commit commit message is breaking or not
+---@param commit string a commit message
+---@return boolean true if the message is breaking, false if the commit message is not breaking
+function git.is_breaking(commit) return vim.fn.match(commit, "\\[.*\\]\\s\\+\\w\\+\\((\\w\\+)\\)\\?!:") ~= -1 end
+
+--- Get a list of breaking commits from commit messages using Conventional Commit standard
+---@param commits string[] an array like table of commit messages
+---@return string[] # An array like table of commits that are breaking
+function git.breaking_changes(commits) return vim.tbl_filter(git.is_breaking, commits) end
+
+--- Generate a table of commit messages for neovim's echo API with highlighting
+---@param commits string[] an array like table of commit messages
+---@return string[][] # An array like table of echo messages to provide to nvim_echo or astronvim.echo
+function git.pretty_changelog(commits)
+  local changelog = {}
+  for _, commit in ipairs(commits) do
+    local hash, type, msg = commit:match "(%[.*%])(.*:)(.*)"
+    if hash and type and msg then
+      vim.list_extend(changelog, {
+        { hash, "DiffText" },
+        { type, git.is_breaking(commit) and "DiffDelete" or "DiffChange" },
+        { msg },
+        { "\n" },
+      })
+    end
+  end
+  return changelog
+end
+
+return git
diff --git a/lua/astronvim/utils/init.lua b/lua/astronvim/utils/init.lua
new file mode 100644
index 0000000..fdcb7e6
--- /dev/null
+++ b/lua/astronvim/utils/init.lua
@@ -0,0 +1,361 @@
+--- ### AstroNvim Utilities
+--
+-- Various utility functions to use within AstroNvim and user configurations.
+--
+-- This module can be loaded with `local utils = require "astronvim.utils"`
+--
+-- @module astronvim.utils
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+--- Merge extended options with a default table of options
+---@param default? table The default table that you want to merge into
+---@param opts? table The new options that should be merged with the default table
+---@return table # The merged table
+function M.extend_tbl(default, opts)
+  opts = opts or {}
+  return default and vim.tbl_deep_extend("force", default, opts) or opts
+end
+
+--- Partially reload AstroNvim user settings. Includes core vim options, mappings, and highlights. This is an experimental feature and may lead to instabilities until restart.
+---@param quiet? boolean Whether or not to notify on completion of reloading
+---@return boolean # True if the reload was successful, False otherwise
+function M.reload(quiet)
+  local was_modifiable = vim.opt.modifiable:get()
+  if not was_modifiable then vim.opt.modifiable = true end
+  local core_modules = { "astronvim.bootstrap", "astronvim.options", "astronvim.mappings" }
+  local modules = vim.tbl_filter(function(module) return module:find "^user%." end, vim.tbl_keys(package.loaded))
+
+  vim.tbl_map(require("plenary.reload").reload_module, vim.list_extend(modules, core_modules))
+
+  local success = true
+  for _, module in ipairs(core_modules) do
+    local status_ok, fault = pcall(require, module)
+    if not status_ok then
+      vim.api.nvim_err_writeln("Failed to load " .. module .. "\n\n" .. fault)
+      success = false
+    end
+  end
+  if not was_modifiable then vim.opt.modifiable = false end
+  if not quiet then -- if not quiet, then notify of result
+    if success then
+      M.notify("AstroNvim successfully reloaded", vim.log.levels.INFO)
+    else
+      M.notify("Error reloading AstroNvim...", vim.log.levels.ERROR)
+    end
+  end
+  vim.cmd.doautocmd "ColorScheme"
+  return success
+end
+
+--- Insert one or more values into a list like table and maintain that you do not insert non-unique values (THIS MODIFIES `lst`)
+---@param lst any[]|nil The list like table that you want to insert into
+---@param vals any|any[] Either a list like table of values to be inserted or a single value to be inserted
+---@return any[] # The modified list like table
+function M.list_insert_unique(lst, vals)
+  if not lst then lst = {} end
+  assert(vim.tbl_islist(lst), "Provided table is not a list like table")
+  if not vim.tbl_islist(vals) then vals = { vals } end
+  local added = {}
+  vim.tbl_map(function(v) added[v] = true end, lst)
+  for _, val in ipairs(vals) do
+    if not added[val] then
+      table.insert(lst, val)
+      added[val] = true
+    end
+  end
+  return lst
+end
+
+--- Call function if a condition is met
+---@param func function The function to run
+---@param condition boolean # Whether to run the function or not
+---@return any|nil result # the result of the function running or nil
+function M.conditional_func(func, condition, ...)
+  -- if the condition is true or no condition is provided, evaluate the function with the rest of the parameters and return the result
+  if condition and type(func) == "function" then return func(...) end
+end
+
+--- Get an icon from the AstroNvim internal icons if it is available and return it
+---@param kind string The kind of icon in astronvim.icons to retrieve
+---@param padding? integer Padding to add to the end of the icon
+---@param no_fallback? boolean Whether or not to disable fallback to text icon
+---@return string icon
+function M.get_icon(kind, padding, no_fallback)
+  if not vim.g.icons_enabled and no_fallback then return "" end
+  local icon_pack = vim.g.icons_enabled and "icons" or "text_icons"
+  if not M[icon_pack] then
+    M.icons = astronvim.user_opts("icons", require "astronvim.icons.nerd_font")
+    M.text_icons = astronvim.user_opts("text_icons", require "astronvim.icons.text")
+  end
+  local icon = M[icon_pack] and M[icon_pack][kind]
+  return icon and icon .. string.rep(" ", padding or 0) or ""
+end
+
+--- Get a icon spinner table if it is available in the AstroNvim icons. Icons in format `kind1`,`kind2`, `kind3`, ...
+---@param kind string The kind of icon to check for sequential entries of
+---@return string[]|nil spinners # A collected table of spinning icons in sequential order or nil if none exist
+function M.get_spinner(kind, ...)
+  local spinner = {}
+  repeat
+    local icon = M.get_icon(("%s%d"):format(kind, #spinner + 1), ...)
+    if icon ~= "" then table.insert(spinner, icon) end
+  until not icon or icon == ""
+  if #spinner > 0 then return spinner end
+end
+
+--- Get highlight properties for a given highlight name
+---@param name string The highlight group name
+---@param fallback? table The fallback highlight properties
+---@return table properties # the highlight group properties
+function M.get_hlgroup(name, fallback)
+  if vim.fn.hlexists(name) == 1 then
+    local hl
+    if vim.api.nvim_get_hl then -- check for new neovim 0.9 API
+      hl = vim.api.nvim_get_hl(0, { name = name, link = false })
+      if not hl.fg then hl.fg = "NONE" end
+      if not hl.bg then hl.bg = "NONE" end
+    else
+      hl = vim.api.nvim_get_hl_by_name(name, vim.o.termguicolors)
+      if not hl.foreground then hl.foreground = "NONE" end
+      if not hl.background then hl.background = "NONE" end
+      hl.fg, hl.bg = hl.foreground, hl.background
+      hl.ctermfg, hl.ctermbg = hl.fg, hl.bg
+      hl.sp = hl.special
+    end
+    return hl
+  end
+  return fallback or {}
+end
+
+--- Serve a notification with a title of AstroNvim
+---@param msg string The notification body
+---@param type? number The type of the notification (:help vim.log.levels)
+---@param opts? table The nvim-notify options to use (:help notify-options)
+function M.notify(msg, type, opts)
+  vim.schedule(function() vim.notify(msg, type, M.extend_tbl({ title = "AstroNvim" }, opts)) end)
+end
+
+--- Trigger an AstroNvim user event
+---@param event string The event name to be appended to Astro
+---@param delay? boolean Whether or not to delay the event asynchronously (Default: true)
+function M.event(event, delay)
+  local emit_event = function() vim.api.nvim_exec_autocmds("User", { pattern = "Astro" .. event, modeline = false }) end
+  if delay == false then
+    emit_event()
+  else
+    vim.schedule(emit_event)
+  end
+end
+
+--- Open a URL under the cursor with the current operating system
+---@param path string The path of the file to open with the system opener
+function M.system_open(path)
+  -- TODO: REMOVE WHEN DROPPING NEOVIM <0.10
+  if vim.ui.open then return vim.ui.open(path) end
+  local cmd
+  if vim.fn.has "mac" == 1 then
+    cmd = { "open" }
+  elseif vim.fn.has "win32" == 1 then
+    if vim.fn.executable "rundll32" then
+      cmd = { "rundll32", "url.dll,FileProtocolHandler" }
+    else
+      cmd = { "cmd.exe", "/K", "explorer" }
+    end
+  elseif vim.fn.has "unix" == 1 then
+    if vim.fn.executable "explorer.exe" == 1 then -- available in WSL
+      cmd = { "explorer.exe" }
+    elseif vim.fn.executable "xdg-open" == 1 then
+      cmd = { "xdg-open" }
+    end
+  end
+  if not cmd then M.notify("Available system opening tool not found!", vim.log.levels.ERROR) end
+  if not path then
+    path = vim.fn.expand "<cfile>"
+  elseif not path:match "%w+:" then
+    path = vim.fn.expand(path)
+  end
+  vim.fn.jobstart(vim.list_extend(cmd, { path }), { detach = true })
+end
+
+--- Toggle a user terminal if it exists, if not then create a new one and save it
+---@param opts string|table A terminal command string or a table of options for Terminal:new() (Check toggleterm.nvim documentation for table format)
+function M.toggle_term_cmd(opts)
+  local terms = astronvim.user_terminals
+  -- if a command string is provided, create a basic table for Terminal:new() options
+  if type(opts) == "string" then opts = { cmd = opts, hidden = true } end
+  local num = vim.v.count > 0 and vim.v.count or 1
+  -- if terminal doesn't exist yet, create it
+  if not terms[opts.cmd] then terms[opts.cmd] = {} end
+  if not terms[opts.cmd][num] then
+    if not opts.count then opts.count = vim.tbl_count(terms) * 100 + num end
+    if not opts.on_exit then opts.on_exit = function() terms[opts.cmd][num] = nil end end
+    terms[opts.cmd][num] = require("toggleterm.terminal").Terminal:new(opts)
+  end
+  -- toggle the terminal
+  terms[opts.cmd][num]:toggle()
+end
+
+--- Create a button entity to use with the alpha dashboard
+---@param sc string The keybinding string to convert to a button
+---@param txt string The explanation text of what the keybinding does
+---@return table # A button entity table for an alpha configuration
+function M.alpha_button(sc, txt)
+  -- replace <leader> in shortcut text with LDR for nicer printing
+  local sc_ = sc:gsub("%s", ""):gsub("LDR", "<Leader>")
+  -- if the leader is set, replace the text with the actual leader key for nicer printing
+  if vim.g.mapleader then sc = sc:gsub("LDR", vim.g.mapleader == " " and "SPC" or vim.g.mapleader) end
+  -- return the button entity to display the correct text and send the correct keybinding on press
+  return {
+    type = "button",
+    val = txt,
+    on_press = function()
+      local key = vim.api.nvim_replace_termcodes(sc_, true, false, true)
+      vim.api.nvim_feedkeys(key, "normal", false)
+    end,
+    opts = {
+      position = "center",
+      text = txt,
+      shortcut = sc,
+      cursor = -2,
+      width = 36,
+      align_shortcut = "right",
+      hl = "DashboardCenter",
+      hl_shortcut = "DashboardShortcut",
+    },
+  }
+end
+
+--- Check if a plugin is defined in lazy. Useful with lazy loading when a plugin is not necessarily loaded yet
+---@param plugin string The plugin to search for
+---@return boolean available # Whether the plugin is available
+function M.is_available(plugin)
+  local lazy_config_avail, lazy_config = pcall(require, "lazy.core.config")
+  return lazy_config_avail and lazy_config.spec.plugins[plugin] ~= nil
+end
+
+--- Resolve the options table for a given plugin with lazy
+---@param plugin string The plugin to search for
+---@return table opts # The plugin options
+function M.plugin_opts(plugin)
+  local lazy_config_avail, lazy_config = pcall(require, "lazy.core.config")
+  local lazy_plugin_avail, lazy_plugin = pcall(require, "lazy.core.plugin")
+  local opts = {}
+  if lazy_config_avail and lazy_plugin_avail then
+    local spec = lazy_config.spec.plugins[plugin]
+    if spec then opts = lazy_plugin.values(spec, "opts") end
+  end
+  return opts
+end
+
+--- A helper function to wrap a module function to require a plugin before running
+---@param plugin string The plugin to call `require("lazy").load` with
+---@param module table The system module where the functions live (e.g. `vim.ui`)
+---@param func_names string|string[] The functions to wrap in the given module (e.g. `{ "ui", "select }`)
+function M.load_plugin_with_func(plugin, module, func_names)
+  if type(func_names) == "string" then func_names = { func_names } end
+  for _, func in ipairs(func_names) do
+    local old_func = module[func]
+    module[func] = function(...)
+      module[func] = old_func
+      require("lazy").load { plugins = { plugin } }
+      module[func](...)
+    end
+  end
+end
+
+--- Register queued which-key mappings
+function M.which_key_register()
+  if M.which_key_queue then
+    local wk_avail, wk = pcall(require, "which-key")
+    if wk_avail then
+      for mode, registration in pairs(M.which_key_queue) do
+        wk.register(registration, { mode = mode })
+      end
+      M.which_key_queue = nil
+    end
+  end
+end
+
+--- Get an empty table of mappings with a key for each map mode
+---@return table<string,table> # a table with entries for each map mode
+function M.empty_map_table()
+  local maps = {}
+  for _, mode in ipairs { "", "n", "v", "x", "s", "o", "!", "i", "l", "c", "t" } do
+    maps[mode] = {}
+  end
+  if vim.fn.has "nvim-0.10.0" == 1 then
+    for _, abbr_mode in ipairs { "ia", "ca", "!a" } do
+      maps[abbr_mode] = {}
+    end
+  end
+  return maps
+end
+
+--- Table based API for setting keybindings
+---@param map_table table A nested table where the first key is the vim mode, the second key is the key to map, and the value is the function to set the mapping to
+---@param base? table A base set of options to set on every keybinding
+function M.set_mappings(map_table, base)
+  -- iterate over the first keys for each mode
+  base = base or {}
+  for mode, maps in pairs(map_table) do
+    -- iterate over each keybinding set in the current mode
+    for keymap, options in pairs(maps) do
+      -- build the options for the command accordingly
+      if options then
+        local cmd = options
+        local keymap_opts = base
+        if type(options) == "table" then
+          cmd = options[1]
+          keymap_opts = vim.tbl_deep_extend("force", keymap_opts, options)
+          keymap_opts[1] = nil
+        end
+        if not cmd or keymap_opts.name then -- if which-key mapping, queue it
+          if not keymap_opts.name then keymap_opts.name = keymap_opts.desc end
+          if not M.which_key_queue then M.which_key_queue = {} end
+          if not M.which_key_queue[mode] then M.which_key_queue[mode] = {} end
+          M.which_key_queue[mode][keymap] = keymap_opts
+        else -- if not which-key mapping, set it
+          vim.keymap.set(mode, keymap, cmd, keymap_opts)
+        end
+      end
+    end
+  end
+  if package.loaded["which-key"] then M.which_key_register() end -- if which-key is loaded already, register
+end
+
+--- regex used for matching a valid URL/URI string
+M.url_matcher =
+  "\\v\\c%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)%([&:#*@~%_\\-=?!+;/0-9a-z]+%(%([.;/?]|[.][.]+)[&:#*@~%_\\-=?!+/0-9a-z]+|:\\d+|,%(%(%(h?ttps?|ftp|file|ssh|git)://|[a-z]+[@][a-z]+[.][a-z]+:)@![0-9a-z]+))*|\\([&:#*@~%_\\-=?!+;/.0-9a-z]*\\)|\\[[&:#*@~%_\\-=?!+;/.0-9a-z]*\\]|\\{%([&:#*@~%_\\-=?!+;/.0-9a-z]*|\\{[&:#*@~%_\\-=?!+;/.0-9a-z]*})\\})+"
+
+--- Delete the syntax matching rules for URLs/URIs if set
+function M.delete_url_match()
+  for _, match in ipairs(vim.fn.getmatches()) do
+    if match.group == "HighlightURL" then vim.fn.matchdelete(match.id) end
+  end
+end
+
+--- Add syntax matching rules for highlighting URLs/URIs
+function M.set_url_match()
+  M.delete_url_match()
+  if vim.g.highlighturl_enabled then vim.fn.matchadd("HighlightURL", M.url_matcher, 15) end
+end
+
+--- Run a shell command and capture the output and if the command succeeded or failed
+---@param cmd string|string[] The terminal command to execute
+---@param show_error? boolean Whether or not to show an unsuccessful command as an error to the user
+---@return string|nil # The result of a successfully executed command or nil
+function M.cmd(cmd, show_error)
+  if type(cmd) == "string" then cmd = { cmd } end
+  if vim.fn.has "win32" == 1 then cmd = vim.list_extend({ "cmd.exe", "/C" }, cmd) end
+  local result = vim.fn.system(cmd)
+  local success = vim.api.nvim_get_vvar "shell_error" == 0
+  if not success and (show_error == nil or show_error) then
+    vim.api.nvim_err_writeln(("Error running command %s\nError message:\n%s"):format(table.concat(cmd, " "), result))
+  end
+  return success and result:gsub("[\27\155][][()#;?%d]*[A-PRZcf-ntqry=><~]", "") or nil
+end
+
+return M
diff --git a/lua/astronvim/utils/lsp.lua b/lua/astronvim/utils/lsp.lua
new file mode 100644
index 0000000..7c184f7
--- /dev/null
+++ b/lua/astronvim/utils/lsp.lua
@@ -0,0 +1,447 @@
+--- ### AstroNvim LSP Utils
+--
+-- LSP related utility functions to use within AstroNvim and user configurations.
+--
+-- This module can be loaded with `local lsp_utils = require("astronvim.utils.lsp")`
+--
+-- @module astronvim.utils.lsp
+-- @see astronvim.utils
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local M = {}
+local tbl_contains = vim.tbl_contains
+local tbl_isempty = vim.tbl_isempty
+local user_opts = astronvim.user_opts
+
+local utils = require "astronvim.utils"
+local conditional_func = utils.conditional_func
+local is_available = utils.is_available
+local extend_tbl = utils.extend_tbl
+
+local server_config = "lsp.config."
+local setup_handlers = user_opts("lsp.setup_handlers", {
+  function(server, opts) require("lspconfig")[server].setup(opts) end,
+})
+
+M.diagnostics = { [0] = {}, {}, {}, {} }
+
+M.setup_diagnostics = function(signs)
+  local default_diagnostics = astronvim.user_opts("diagnostics", {
+    virtual_text = true,
+    signs = {
+      text = {
+        [vim.diagnostic.severity.ERROR] = utils.get_icon "DiagnosticError",
+        [vim.diagnostic.severity.HINT] = utils.get_icon "DiagnosticHint",
+        [vim.diagnostic.severity.WARN] = utils.get_icon "DiagnosticWarn",
+        [vim.diagnostic.severity.INFO] = utils.get_icon "DiagnosticInfo",
+      },
+      active = signs,
+    },
+    update_in_insert = true,
+    underline = true,
+    severity_sort = true,
+    float = {
+      focused = false,
+      style = "minimal",
+      border = "rounded",
+      source = "always",
+      header = "",
+      prefix = "",
+    },
+  })
+  M.diagnostics = {
+    -- diagnostics off
+    [0] = extend_tbl(
+      default_diagnostics,
+      { underline = false, virtual_text = false, signs = false, update_in_insert = false }
+    ),
+    -- status only
+    extend_tbl(default_diagnostics, { virtual_text = false, signs = false }),
+    -- virtual text off, signs on
+    extend_tbl(default_diagnostics, { virtual_text = false }),
+    -- all diagnostics on
+    default_diagnostics,
+  }
+
+  vim.diagnostic.config(M.diagnostics[vim.g.diagnostics_mode])
+end
+
+M.formatting = user_opts("lsp.formatting", { format_on_save = { enabled = true }, disabled = {} })
+if type(M.formatting.format_on_save) == "boolean" then
+  M.formatting.format_on_save = { enabled = M.formatting.format_on_save }
+end
+
+M.format_opts = vim.deepcopy(M.formatting)
+M.format_opts.timeout_ms = 7000
+M.format_opts.disabled = nil
+M.format_opts.format_on_save = nil
+M.format_opts.filter = function(client)
+  local filter = M.formatting.filter
+  local disabled = M.formatting.disabled or {}
+  -- check if client is fully disabled or filtered by function
+  return not (vim.tbl_contains(disabled, client.name) or (type(filter) == "function" and not filter(client)))
+end
+
+--- Helper function to set up a given server with the Neovim LSP clientM.formatting
+---@param server string The name of the server to be setup
+M.setup = function(server)
+  -- if server doesn't exist, set it up from user server definition
+  local config_avail, config = pcall(require, "lspconfig.server_configurations." .. server)
+  if not config_avail or not config.default_config then
+    local server_definition = user_opts(server_config .. server)
+    if server_definition.cmd then require("lspconfig.configs")[server] = { default_config = server_definition } end
+  end
+  local opts = M.config(server)
+  local setup_handler = setup_handlers[server] or setup_handlers[1]
+  if not vim.tbl_contains(astronvim.lsp.skip_setup, server) and setup_handler then setup_handler(server, opts) end
+end
+
+--- Helper function to check if any active LSP clients given a filter provide a specific capability
+---@param capability string The server capability to check for (example: "documentFormattingProvider")
+---@param filter vim.lsp.get_active_clients.filter|nil (table|nil) A table with
+---              key-value pairs used to filter the returned clients.
+---              The available keys are:
+---               - id (number): Only return clients with the given id
+---               - bufnr (number): Only return clients attached to this buffer
+---               - name (string): Only return clients with the given name
+---@return boolean # Whether or not any of the clients provide the capability
+function M.has_capability(capability, filter)
+  for _, client in ipairs(vim.lsp.get_active_clients(filter)) do
+    if client.supports_method(capability) then return true end
+  end
+  return false
+end
+
+local function add_buffer_autocmd(augroup, bufnr, autocmds)
+  if not vim.tbl_islist(autocmds) then autocmds = { autocmds } end
+  local cmds_found, cmds = pcall(vim.api.nvim_get_autocmds, { group = augroup, buffer = bufnr })
+  if not cmds_found or vim.tbl_isempty(cmds) then
+    vim.api.nvim_create_augroup(augroup, { clear = false })
+    for _, autocmd in ipairs(autocmds) do
+      local events = autocmd.events
+      autocmd.events = nil
+      autocmd.group = augroup
+      autocmd.buffer = bufnr
+      vim.api.nvim_create_autocmd(events, autocmd)
+    end
+  end
+end
+
+local function del_buffer_autocmd(augroup, bufnr)
+  local cmds_found, cmds = pcall(vim.api.nvim_get_autocmds, { group = augroup, buffer = bufnr })
+  if cmds_found then vim.tbl_map(function(cmd) vim.api.nvim_del_autocmd(cmd.id) end, cmds) end
+end
+
+--- The `on_attach` function used by AstroNvim
+---@param client table The LSP client details when attaching
+---@param bufnr number The buffer that the LSP client is attaching to
+M.on_attach = function(client, bufnr)
+  local lsp_mappings = require("astronvim.utils").empty_map_table()
+
+  lsp_mappings.n["<leader>ld"] = { function() vim.diagnostic.open_float() end, desc = "Hover diagnostics" }
+  lsp_mappings.n["[d"] = { function() vim.diagnostic.goto_prev() end, desc = "Previous diagnostic" }
+  lsp_mappings.n["]d"] = { function() vim.diagnostic.goto_next() end, desc = "Next diagnostic" }
+  lsp_mappings.n["gl"] = { function() vim.diagnostic.open_float() end, desc = "Hover diagnostics" }
+
+  if is_available "telescope.nvim" then
+    lsp_mappings.n["<leader>lD"] =
+      { function() require("telescope.builtin").diagnostics() end, desc = "Search diagnostics" }
+  end
+
+  if is_available "mason-lspconfig.nvim" then
+    lsp_mappings.n["<leader>li"] = { "<cmd>LspInfo<cr>", desc = "LSP information" }
+  end
+
+  if is_available "null-ls.nvim" then
+    lsp_mappings.n["<leader>lI"] = { "<cmd>NullLsInfo<cr>", desc = "Null-ls information" }
+  end
+
+  if client.supports_method "textDocument/codeAction" then
+    lsp_mappings.n["<leader>la"] = {
+      function() vim.lsp.buf.code_action() end,
+      desc = "LSP code action",
+    }
+    lsp_mappings.v["<leader>la"] = lsp_mappings.n["<leader>la"]
+  end
+
+  if client.supports_method "textDocument/codeLens" then
+    add_buffer_autocmd("lsp_codelens_refresh", bufnr, {
+      events = { "InsertLeave", "BufEnter" },
+      desc = "Refresh codelens",
+      callback = function()
+        if not M.has_capability("textDocument/codeLens", { bufnr = bufnr }) then
+          del_buffer_autocmd("lsp_codelens_refresh", bufnr)
+          return
+        end
+        if vim.g.codelens_enabled then vim.lsp.codelens.refresh() end
+      end,
+    })
+    if vim.g.codelens_enabled then vim.lsp.codelens.refresh() end
+    lsp_mappings.n["<leader>ll"] = {
+      function() vim.lsp.codelens.refresh() end,
+      desc = "LSP CodeLens refresh",
+    }
+    lsp_mappings.n["<leader>lL"] = {
+      function() vim.lsp.codelens.run() end,
+      desc = "LSP CodeLens run",
+    }
+  end
+
+  if client.supports_method "textDocument/declaration" then
+    lsp_mappings.n["gD"] = {
+      function() vim.lsp.buf.declaration() end,
+      desc = "Declaration of current symbol",
+    }
+  end
+
+  if client.supports_method "textDocument/definition" then
+    lsp_mappings.n["gd"] = {
+      function() vim.lsp.buf.definition() end,
+      desc = "Show the definition of current symbol",
+    }
+  end
+
+  if client.supports_method "textDocument/formatting" and not tbl_contains(M.formatting.disabled, client.name) then
+    lsp_mappings.n["<leader>lf"] = {
+      function() vim.lsp.buf.format(M.format_opts) end,
+      desc = "Format buffer",
+    }
+    lsp_mappings.v["<leader>lf"] = lsp_mappings.n["<leader>lf"]
+
+    vim.api.nvim_buf_create_user_command(
+      bufnr,
+      "Format",
+      function() vim.lsp.buf.format(M.format_opts) end,
+      { desc = "Format file with LSP" }
+    )
+    local autoformat = M.formatting.format_on_save
+    local filetype = vim.api.nvim_get_option_value("filetype", { buf = bufnr })
+    if
+      autoformat.enabled
+      and (tbl_isempty(autoformat.allow_filetypes or {}) or tbl_contains(autoformat.allow_filetypes, filetype))
+      and (tbl_isempty(autoformat.ignore_filetypes or {}) or not tbl_contains(autoformat.ignore_filetypes, filetype))
+    then
+      add_buffer_autocmd("lsp_auto_format", bufnr, {
+        events = "BufWritePre",
+        desc = "autoformat on save",
+        callback = function()
+          if not M.has_capability("textDocument/formatting", { bufnr = bufnr }) then
+            del_buffer_autocmd("lsp_auto_format", bufnr)
+            return
+          end
+          local autoformat_enabled = vim.b.autoformat_enabled
+          if autoformat_enabled == nil then autoformat_enabled = vim.g.autoformat_enabled end
+          if autoformat_enabled and ((not autoformat.filter) or autoformat.filter(bufnr)) then
+            vim.lsp.buf.format(extend_tbl(M.format_opts, { bufnr = bufnr }))
+          end
+        end,
+      })
+      lsp_mappings.n["<leader>uf"] = {
+        function() require("astronvim.utils.ui").toggle_buffer_autoformat() end,
+        desc = "Toggle autoformatting (buffer)",
+      }
+      lsp_mappings.n["<leader>uF"] = {
+        function() require("astronvim.utils.ui").toggle_autoformat() end,
+        desc = "Toggle autoformatting (global)",
+      }
+    end
+  end
+
+  if client.supports_method "textDocument/documentHighlight" then
+    add_buffer_autocmd("lsp_document_highlight", bufnr, {
+      {
+        events = { "CursorHold", "CursorHoldI" },
+        desc = "highlight references when cursor holds",
+        callback = function()
+          if not M.has_capability("textDocument/documentHighlight", { bufnr = bufnr }) then
+            del_buffer_autocmd("lsp_document_highlight", bufnr)
+            return
+          end
+          vim.lsp.buf.document_highlight()
+        end,
+      },
+      {
+        events = { "CursorMoved", "CursorMovedI", "BufLeave" },
+        desc = "clear references when cursor moves",
+        callback = function() vim.lsp.buf.clear_references() end,
+      },
+    })
+  end
+
+  if client.supports_method "textDocument/hover" then
+    -- TODO: Remove mapping after dropping support for Neovim v0.9, it's automatic
+    if vim.fn.has "nvim-0.10" == 0 then
+      lsp_mappings.n["K"] = {
+        function() vim.lsp.buf.hover() end,
+        desc = "Hover symbol details",
+      }
+    end
+  end
+
+  if client.supports_method "textDocument/implementation" then
+    lsp_mappings.n["gI"] = {
+      function() vim.lsp.buf.implementation() end,
+      desc = "Implementation of current symbol",
+    }
+  end
+
+  if client.supports_method "textDocument/inlayHint" then
+    if vim.b.inlay_hints_enabled == nil then vim.b.inlay_hints_enabled = vim.g.inlay_hints_enabled end
+    -- TODO: remove check after dropping support for Neovim v0.9
+    if vim.lsp.inlay_hint then
+      if vim.b.inlay_hints_enabled then vim.lsp.inlay_hint.enable(bufnr, true) end
+      lsp_mappings.n["<leader>uH"] = {
+        function() require("astronvim.utils.ui").toggle_buffer_inlay_hints(bufnr) end,
+        desc = "Toggle LSP inlay hints (buffer)",
+      }
+    end
+  end
+
+  if client.supports_method "textDocument/references" then
+    lsp_mappings.n["gr"] = {
+      function() vim.lsp.buf.references() end,
+      desc = "References of current symbol",
+    }
+    lsp_mappings.n["<leader>lR"] = {
+      function() vim.lsp.buf.references() end,
+      desc = "Search references",
+    }
+  end
+
+  if client.supports_method "textDocument/rename" then
+    lsp_mappings.n["<leader>lr"] = {
+      function() vim.lsp.buf.rename() end,
+      desc = "Rename current symbol",
+    }
+  end
+
+  if client.supports_method "textDocument/signatureHelp" then
+    lsp_mappings.n["<leader>lh"] = {
+      function() vim.lsp.buf.signature_help() end,
+      desc = "Signature help",
+    }
+  end
+
+  if client.supports_method "textDocument/typeDefinition" then
+    lsp_mappings.n["gy"] = {
+      function() vim.lsp.buf.type_definition() end,
+      desc = "Definition of current type",
+    }
+  end
+
+  if client.supports_method "workspace/symbol" then
+    lsp_mappings.n["<leader>lG"] = { function() vim.lsp.buf.workspace_symbol() end, desc = "Search workspace symbols" }
+  end
+
+  if client.supports_method "textDocument/semanticTokens/full" and vim.lsp.semantic_tokens then
+    if vim.g.semantic_tokens_enabled then
+      vim.b[bufnr].semantic_tokens_enabled = true
+      lsp_mappings.n["<leader>uY"] = {
+        function() require("astronvim.utils.ui").toggle_buffer_semantic_tokens(bufnr) end,
+        desc = "Toggle LSP semantic highlight (buffer)",
+      }
+    else
+      client.server_capabilities.semanticTokensProvider = nil
+    end
+  end
+
+  if is_available "telescope.nvim" then -- setup telescope mappings if available
+    if lsp_mappings.n.gd then lsp_mappings.n.gd[1] = function() require("telescope.builtin").lsp_definitions() end end
+    if lsp_mappings.n.gI then
+      lsp_mappings.n.gI[1] = function() require("telescope.builtin").lsp_implementations() end
+    end
+    if lsp_mappings.n.gr then lsp_mappings.n.gr[1] = function() require("telescope.builtin").lsp_references() end end
+    if lsp_mappings.n["<leader>lR"] then
+      lsp_mappings.n["<leader>lR"][1] = function() require("telescope.builtin").lsp_references() end
+    end
+    if lsp_mappings.n.gy then
+      lsp_mappings.n.gy[1] = function() require("telescope.builtin").lsp_type_definitions() end
+    end
+    if lsp_mappings.n["<leader>lG"] then
+      lsp_mappings.n["<leader>lG"][1] = function()
+        vim.ui.input({ prompt = "Symbol Query: (leave empty for word under cursor)" }, function(query)
+          if query then
+            -- word under cursor if given query is empty
+            if query == "" then query = vim.fn.expand "<cword>" end
+            require("telescope.builtin").lsp_workspace_symbols {
+              query = query,
+              prompt_title = ("Find word (%s)"):format(query),
+            }
+          end
+        end)
+      end
+    end
+  end
+
+  if not vim.tbl_isempty(lsp_mappings.v) then
+    lsp_mappings.v["<leader>l"] = { desc = utils.get_icon("ActiveLSP", 1, true) .. "LSP" }
+  end
+  utils.set_mappings(user_opts("lsp.mappings", lsp_mappings), { buffer = bufnr })
+
+  for id, _ in pairs(astronvim.lsp.progress) do -- clear lingering progress messages
+    if not next(vim.lsp.get_active_clients { id = tonumber(id:match "^%d+") }) then astronvim.lsp.progress[id] = nil end
+  end
+
+  local on_attach_override = user_opts("lsp.on_attach", nil, false)
+  conditional_func(on_attach_override, true, client, bufnr)
+end
+
+--- The default AstroNvim LSP capabilities
+M.capabilities = vim.lsp.protocol.make_client_capabilities()
+M.capabilities.textDocument.completion.completionItem.documentationFormat = { "markdown", "plaintext" }
+M.capabilities.textDocument.completion.completionItem.snippetSupport = true
+M.capabilities.textDocument.completion.completionItem.preselectSupport = true
+M.capabilities.textDocument.completion.completionItem.insertReplaceSupport = true
+M.capabilities.textDocument.completion.completionItem.labelDetailsSupport = true
+M.capabilities.textDocument.completion.completionItem.deprecatedSupport = true
+M.capabilities.textDocument.completion.completionItem.commitCharactersSupport = true
+M.capabilities.textDocument.completion.completionItem.tagSupport = { valueSet = { 1 } }
+M.capabilities.textDocument.completion.completionItem.resolveSupport =
+  { properties = { "documentation", "detail", "additionalTextEdits" } }
+M.capabilities.textDocument.foldingRange = { dynamicRegistration = false, lineFoldingOnly = true }
+M.capabilities = user_opts("lsp.capabilities", M.capabilities)
+M.flags = user_opts "lsp.flags"
+
+--- Get the server configuration for a given language server to be provided to the server's `setup()` call
+---@param server_name string The name of the server
+---@return table # The table of LSP options used when setting up the given language server
+function M.config(server_name)
+  local server = require("lspconfig")[server_name]
+  local lsp_opts = extend_tbl(server, { capabilities = M.capabilities, flags = M.flags })
+  if server_name == "jsonls" then -- by default add json schemas
+    local schemastore_avail, schemastore = pcall(require, "schemastore")
+    if schemastore_avail then
+      lsp_opts.settings = { json = { schemas = schemastore.json.schemas(), validate = { enable = true } } }
+    end
+  end
+  if server_name == "yamlls" then -- by default add yaml schemas
+    local schemastore_avail, schemastore = pcall(require, "schemastore")
+    if schemastore_avail then lsp_opts.settings = { yaml = { schemas = schemastore.yaml.schemas() } } end
+  end
+  if server_name == "lua_ls" then -- by default initialize neodev and disable third party checking
+    pcall(require, "neodev")
+    lsp_opts.before_init = function(param, config)
+      if vim.b.neodev_enabled then
+        for _, astronvim_config in ipairs(astronvim.supported_configs) do
+          if param.rootPath:match(astronvim_config) then
+            table.insert(config.settings.Lua.workspace.library, astronvim.install.home .. "/lua")
+            break
+          end
+        end
+      end
+    end
+    lsp_opts.settings = { Lua = { workspace = { checkThirdParty = false } } }
+  end
+  local opts = user_opts(server_config .. server_name, lsp_opts)
+  local old_on_attach = server.on_attach
+  local user_on_attach = opts.on_attach
+  opts.on_attach = function(client, bufnr)
+    conditional_func(old_on_attach, true, client, bufnr)
+    M.on_attach(client, bufnr)
+    conditional_func(user_on_attach, true, client, bufnr)
+  end
+  return opts
+end
+
+return M
diff --git a/lua/astronvim/utils/mason.lua b/lua/astronvim/utils/mason.lua
new file mode 100644
index 0000000..5cbd0e6
--- /dev/null
+++ b/lua/astronvim/utils/mason.lua
@@ -0,0 +1,119 @@
+--- ### Mason Utils
+--
+-- Mason related utility functions to use within AstroNvim and user configurations.
+--
+-- This module can be loaded with `local mason_utils = require("astronvim.utils.mason")`
+--
+-- @module astronvim.utils.mason
+-- @see astronvim.utils
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local utils = require "astronvim.utils"
+local astroevent = utils.event
+local function mason_notify(msg, type) utils.notify(msg, type, { title = "Mason" }) end
+
+--- Update specified mason packages, or just update the registries if no packages are listed
+---@param pkg_names? string|string[] The package names as defined in Mason (Not mason-lspconfig or mason-null-ls) if the value is nil then it will just update the registries
+---@param auto_install? boolean whether or not to install a package that is not currently installed (default: True)
+function M.update(pkg_names, auto_install)
+  pkg_names = pkg_names or {}
+  if type(pkg_names) == "string" then pkg_names = { pkg_names } end
+  if auto_install == nil then auto_install = true end
+  local registry_avail, registry = pcall(require, "mason-registry")
+  if not registry_avail then
+    vim.api.nvim_err_writeln "Unable to access mason registry"
+    return
+  end
+
+  registry.update(vim.schedule_wrap(function(success, updated_registries)
+    if success then
+      local count = #updated_registries
+      if vim.tbl_count(pkg_names) == 0 then
+        mason_notify(("Successfully updated %d %s."):format(count, count == 1 and "registry" or "registries"))
+      end
+      for _, pkg_name in ipairs(pkg_names) do
+        local pkg_avail, pkg = pcall(registry.get_package, pkg_name)
+        if not pkg_avail then
+          mason_notify(("`%s` is not available"):format(pkg_name), vim.log.levels.ERROR)
+        else
+          if not pkg:is_installed() then
+            if auto_install then
+              mason_notify(("Installing `%s`"):format(pkg.name))
+              pkg:install()
+            else
+              mason_notify(("`%s` not installed"):format(pkg.name), vim.log.levels.WARN)
+            end
+          else
+            pkg:check_new_version(function(update_available, version)
+              if update_available then
+                mason_notify(("Updating `%s` to %s"):format(pkg.name, version.latest_version))
+                pkg:install():on("closed", function() mason_notify(("Updated %s"):format(pkg.name)) end)
+              else
+                mason_notify(("No updates available for `%s`"):format(pkg.name))
+              end
+            end)
+          end
+        end
+      end
+    else
+      mason_notify(("Failed to update registries: %s"):format(updated_registries), vim.log.levels.ERROR)
+    end
+  end))
+end
+
+--- Update all packages in Mason
+function M.update_all()
+  local registry_avail, registry = pcall(require, "mason-registry")
+  if not registry_avail then
+    vim.api.nvim_err_writeln "Unable to access mason registry"
+    return
+  end
+
+  mason_notify "Checking for package updates..."
+  registry.update(vim.schedule_wrap(function(success, updated_registries)
+    if success then
+      local installed_pkgs = registry.get_installed_packages()
+      local running = #installed_pkgs
+      local no_pkgs = running == 0
+
+      if no_pkgs then
+        mason_notify "No updates available"
+        astroevent "MasonUpdateCompleted"
+      else
+        local updated = false
+        for _, pkg in ipairs(installed_pkgs) do
+          pkg:check_new_version(function(update_available, version)
+            if update_available then
+              updated = true
+              mason_notify(("Updating `%s` to %s"):format(pkg.name, version.latest_version))
+              pkg:install():on("closed", function()
+                running = running - 1
+                if running == 0 then
+                  mason_notify "Update Complete"
+                  astroevent "MasonUpdateCompleted"
+                end
+              end)
+            else
+              running = running - 1
+              if running == 0 then
+                if updated then
+                  mason_notify "Update Complete"
+                else
+                  mason_notify "No updates available"
+                end
+                astroevent "MasonUpdateCompleted"
+              end
+            end
+          end)
+        end
+      end
+    else
+      mason_notify(("Failed to update registries: %s"):format(updated_registries), vim.log.levels.ERROR)
+    end
+  end))
+end
+
+return M
diff --git a/lua/astronvim/utils/status.lua b/lua/astronvim/utils/status.lua
new file mode 100644
index 0000000..1e44fd3
--- /dev/null
+++ b/lua/astronvim/utils/status.lua
@@ -0,0 +1,10 @@
+return {
+  component = require "astronvim.utils.status.component",
+  condition = require "astronvim.utils.status.condition",
+  env = require "astronvim.utils.status.env",
+  heirline = require "astronvim.utils.status.heirline",
+  hl = require "astronvim.utils.status.hl",
+  init = require "astronvim.utils.status.init",
+  provider = require "astronvim.utils.status.provider",
+  utils = require "astronvim.utils.status.utils",
+}
diff --git a/lua/astronvim/utils/status/component.lua b/lua/astronvim/utils/status/component.lua
new file mode 100644
index 0000000..91b4476
--- /dev/null
+++ b/lua/astronvim/utils/status/component.lua
@@ -0,0 +1,436 @@
+--- ### AstroNvim Status Components
+--
+-- Statusline related component functions to use with Heirline
+--
+-- This module can be loaded with `local component = require "astronvim.utils.status.component"`
+--
+-- @module astronvim.utils.status.component
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local condition = require "astronvim.utils.status.condition"
+local env = require "astronvim.utils.status.env"
+local hl = require "astronvim.utils.status.hl"
+local init = require "astronvim.utils.status.init"
+local provider = require "astronvim.utils.status.provider"
+local status_utils = require "astronvim.utils.status.utils"
+
+local utils = require "astronvim.utils"
+local buffer_utils = require "astronvim.utils.buffer"
+local extend_tbl = utils.extend_tbl
+local get_icon = utils.get_icon
+local is_available = utils.is_available
+
+--- A Heirline component for filling in the empty space of the bar
+---@param opts? table options for configuring the other fields of the heirline component
+---@return table # The heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.fill()
+function M.fill(opts) return extend_tbl({ provider = provider.fill() }, opts) end
+
+--- A function to build a set of children components for an entire file information section
+---@param opts? table options for configuring file_icon, filename, filetype, file_modified, file_read_only, and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.file_info()
+function M.file_info(opts)
+  opts = extend_tbl({
+    file_icon = { hl = hl.file_icon "statusline", padding = { left = 1, right = 1 } },
+    filename = {},
+    file_modified = { padding = { left = 1 } },
+    file_read_only = { padding = { left = 1 } },
+    surround = { separator = "left", color = "file_info_bg", condition = condition.has_filetype },
+    hl = hl.get_attributes "file_info",
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, {
+    "file_icon",
+    "unique_path",
+    "filename",
+    "filetype",
+    "file_modified",
+    "file_read_only",
+    "close_button",
+  }))
+end
+
+--- A function with different file_info defaults specifically for use in the tabline
+---@param opts? table options for configuring file_icon, filename, filetype, file_modified, file_read_only, and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.tabline_file_info()
+function M.tabline_file_info(opts)
+  return M.file_info(extend_tbl({
+    file_icon = {
+      condition = function(self) return not self._show_picker end,
+      hl = hl.file_icon "tabline",
+    },
+    unique_path = {
+      hl = function(self) return hl.get_attributes(self.tab_type .. "_path") end,
+    },
+    close_button = {
+      hl = function(self) return hl.get_attributes(self.tab_type .. "_close") end,
+      padding = { left = 1, right = 1 },
+      on_click = {
+        callback = function(_, minwid) buffer_utils.close(minwid) end,
+        minwid = function(self) return self.bufnr end,
+        name = "heirline_tabline_close_buffer_callback",
+      },
+    },
+    padding = { left = 1, right = 1 },
+    hl = function(self)
+      local tab_type = self.tab_type
+      if self._show_picker and self.tab_type ~= "buffer_active" then tab_type = "buffer_visible" end
+      return hl.get_attributes(tab_type)
+    end,
+    surround = false,
+  }, opts))
+end
+
+--- A function to build a set of children components for an entire navigation section
+---@param opts? table options for configuring ruler, percentage, scrollbar, and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.nav()
+function M.nav(opts)
+  opts = extend_tbl({
+    ruler = {},
+    percentage = { padding = { left = 1 } },
+    scrollbar = { padding = { left = 1 }, hl = { fg = "scrollbar" } },
+    surround = { separator = "right", color = "nav_bg" },
+    hl = hl.get_attributes "nav",
+    update = { "CursorMoved", "CursorMovedI", "BufEnter" },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "ruler", "percentage", "scrollbar" }))
+end
+
+--- A function to build a set of children components for information shown in the cmdline
+---@param opts? table options for configuring macro recording, search count, and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.cmd_info()
+function M.cmd_info(opts)
+  opts = extend_tbl({
+    macro_recording = {
+      icon = { kind = "MacroRecording", padding = { right = 1 } },
+      condition = condition.is_macro_recording,
+      update = {
+        "RecordingEnter",
+        "RecordingLeave",
+        -- TODO: remove when dropping support for Neovim v0.8
+        callback = vim.fn.has "nvim-0.9" == 0 and vim.schedule_wrap(function() vim.cmd.redrawstatus() end) or nil,
+      },
+    },
+    search_count = {
+      icon = { kind = "Search", padding = { right = 1 } },
+      padding = { left = 1 },
+      condition = condition.is_hlsearch,
+    },
+    showcmd = {
+      padding = { left = 1 },
+      condition = condition.is_statusline_showcmd,
+    },
+    surround = {
+      separator = "center",
+      color = "cmd_info_bg",
+      condition = function()
+        return condition.is_hlsearch() or condition.is_macro_recording() or condition.is_statusline_showcmd()
+      end,
+    },
+    condition = function() return vim.opt.cmdheight:get() == 0 end,
+    hl = hl.get_attributes "cmd_info",
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "macro_recording", "search_count", "showcmd" }))
+end
+
+--- A function to build a set of children components for a mode section
+---@param opts? table options for configuring mode_text, paste, spell, and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.mode { mode_text = true }
+function M.mode(opts)
+  opts = extend_tbl({
+    mode_text = false,
+    paste = false,
+    spell = false,
+    surround = { separator = "left", color = hl.mode_bg },
+    hl = hl.get_attributes "mode",
+    update = {
+      "ModeChanged",
+      pattern = "*:*",
+      callback = vim.schedule_wrap(function() vim.cmd.redrawstatus() end),
+    },
+  }, opts)
+  if not opts["mode_text"] then opts.str = { str = " " } end
+  return M.builder(status_utils.setup_providers(opts, { "mode_text", "str", "paste", "spell" }))
+end
+
+--- A function to build a set of children components for an LSP breadcrumbs section
+---@param opts? table options for configuring breadcrumbs and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.breadcumbs()
+function M.breadcrumbs(opts)
+  opts = extend_tbl({ padding = { left = 1 }, condition = condition.aerial_available, update = "CursorMoved" }, opts)
+  opts.init = init.breadcrumbs(opts)
+  return opts
+end
+
+--- A function to build a set of children components for the current file path
+---@param opts? table options for configuring path and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.separated_path()
+function M.separated_path(opts)
+  opts = extend_tbl({ padding = { left = 1 }, update = { "BufEnter", "DirChanged" } }, opts)
+  opts.init = init.separated_path(opts)
+  return opts
+end
+
+--- A function to build a set of children components for a git branch section
+---@param opts? table options for configuring git branch and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.git_branch()
+function M.git_branch(opts)
+  opts = extend_tbl({
+    git_branch = { icon = { kind = "GitBranch", padding = { right = 1 } } },
+    surround = { separator = "left", color = "git_branch_bg", condition = condition.is_git_repo },
+    hl = hl.get_attributes "git_branch",
+    on_click = {
+      name = "heirline_branch",
+      callback = function()
+        if is_available "telescope.nvim" then
+          vim.defer_fn(function() require("telescope.builtin").git_branches { use_file_path = true } end, 100)
+        end
+      end,
+    },
+    update = { "User", pattern = "GitSignsUpdate" },
+    init = init.update_events { "BufEnter" },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "git_branch" }))
+end
+
+--- A function to build a set of children components for a git difference section
+---@param opts? table options for configuring git changes and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.git_diff()
+function M.git_diff(opts)
+  opts = extend_tbl({
+    added = { icon = { kind = "GitAdd", padding = { left = 1, right = 1 } } },
+    changed = { icon = { kind = "GitChange", padding = { left = 1, right = 1 } } },
+    removed = { icon = { kind = "GitDelete", padding = { left = 1, right = 1 } } },
+    hl = hl.get_attributes "git_diff",
+    on_click = {
+      name = "heirline_git",
+      callback = function()
+        if is_available "telescope.nvim" then
+          vim.defer_fn(function() require("telescope.builtin").git_status { use_file_path = true } end, 100)
+        end
+      end,
+    },
+    surround = { separator = "left", color = "git_diff_bg", condition = condition.git_changed },
+    update = { "User", pattern = "GitSignsUpdate" },
+    init = init.update_events { "BufEnter" },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "added", "changed", "removed" }, function(p_opts, p)
+    local out = status_utils.build_provider(p_opts, p)
+    if out then
+      out.provider = "git_diff"
+      out.opts.type = p
+      if out.hl == nil then out.hl = { fg = "git_" .. p } end
+    end
+    return out
+  end))
+end
+
+--- A function to build a set of children components for a diagnostics section
+---@param opts? table options for configuring diagnostic providers and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.diagnostics()
+function M.diagnostics(opts)
+  opts = extend_tbl({
+    ERROR = { icon = { kind = "DiagnosticError", padding = { left = 1, right = 1 } } },
+    WARN = { icon = { kind = "DiagnosticWarn", padding = { left = 1, right = 1 } } },
+    INFO = { icon = { kind = "DiagnosticInfo", padding = { left = 1, right = 1 } } },
+    HINT = { icon = { kind = "DiagnosticHint", padding = { left = 1, right = 1 } } },
+    surround = { separator = "left", color = "diagnostics_bg", condition = condition.has_diagnostics },
+    hl = hl.get_attributes "diagnostics",
+    on_click = {
+      name = "heirline_diagnostic",
+      callback = function()
+        if is_available "telescope.nvim" then
+          vim.defer_fn(function() require("telescope.builtin").diagnostics() end, 100)
+        end
+      end,
+    },
+    update = { "DiagnosticChanged", "BufEnter" },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "ERROR", "WARN", "INFO", "HINT" }, function(p_opts, p)
+    local out = status_utils.build_provider(p_opts, p)
+    if out then
+      out.provider = "diagnostics"
+      out.opts.severity = p
+      if out.hl == nil then out.hl = { fg = "diag_" .. p } end
+    end
+    return out
+  end))
+end
+
+--- A function to build a set of children components for a Treesitter section
+---@param opts? table options for configuring diagnostic providers and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.treesitter()
+function M.treesitter(opts)
+  opts = extend_tbl({
+    str = { str = "TS", icon = { kind = "ActiveTS", padding = { right = 1 } } },
+    surround = {
+      separator = "right",
+      color = "treesitter_bg",
+      condition = condition.treesitter_available,
+    },
+    hl = hl.get_attributes "treesitter",
+    update = { "OptionSet", pattern = "syntax" },
+    init = init.update_events { "BufEnter" },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "str" }))
+end
+
+--- A function to build a set of children components for an LSP section
+---@param opts? table options for configuring lsp progress and client_name providers and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.lsp()
+function M.lsp(opts)
+  opts = extend_tbl({
+    lsp_progress = {
+      str = "",
+      padding = { right = 1 },
+      update = {
+        "User",
+        pattern = "AstroLspProgress",
+        callback = vim.schedule_wrap(function() vim.cmd.redrawstatus() end),
+      },
+    },
+    lsp_client_names = {
+      str = "LSP",
+      update = {
+        "LspAttach",
+        "LspDetach",
+        "BufEnter",
+        callback = vim.schedule_wrap(function() vim.cmd.redrawstatus() end),
+      },
+      icon = { kind = "ActiveLSP", padding = { right = 2 } },
+    },
+    hl = hl.get_attributes "lsp",
+    surround = { separator = "right", color = "lsp_bg", condition = condition.lsp_attached },
+    on_click = {
+      name = "heirline_lsp",
+      callback = function()
+        vim.defer_fn(function() vim.cmd.LspInfo() end, 100)
+      end,
+    },
+  }, opts)
+  return M.builder(status_utils.setup_providers(
+    opts,
+    { "lsp_progress", "lsp_client_names" },
+    function(p_opts, p, i)
+      return p_opts
+          and {
+            flexible = i,
+            status_utils.build_provider(p_opts, provider[p](p_opts)),
+            status_utils.build_provider(p_opts, provider.str(p_opts)),
+          }
+        or false
+    end
+  ))
+end
+
+--- A function to build a set of components for a foldcolumn section in a statuscolumn
+---@param opts? table options for configuring foldcolumn and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.foldcolumn()
+function M.foldcolumn(opts)
+  opts = extend_tbl({
+    foldcolumn = { padding = { right = 1 } },
+    condition = condition.foldcolumn_enabled,
+    on_click = {
+      name = "fold_click",
+      callback = function(...)
+        local char = status_utils.statuscolumn_clickargs(...).char
+        local fillchars = vim.opt_local.fillchars:get()
+        if char == (fillchars.foldopen or get_icon "FoldOpened") then
+          vim.cmd "norm! zc"
+        elseif char == (fillchars.foldclose or get_icon "FoldClosed") then
+          vim.cmd "norm! zo"
+        end
+      end,
+    },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "foldcolumn" }))
+end
+
+--- A function to build a set of components for a numbercolumn section in statuscolumn
+---@param opts? table options for configuring numbercolumn and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.numbercolumn()
+function M.numbercolumn(opts)
+  opts = extend_tbl({
+    numbercolumn = { padding = { right = 1 } },
+    condition = condition.numbercolumn_enabled,
+    on_click = {
+      name = "line_click",
+      callback = function(...)
+        local args = status_utils.statuscolumn_clickargs(...)
+        if args.mods:find "c" then
+          local dap_avail, dap = pcall(require, "dap")
+          if dap_avail then vim.schedule(dap.toggle_breakpoint) end
+        end
+      end,
+    },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "numbercolumn" }))
+end
+
+--- A function to build a set of components for a signcolumn section in statuscolumn
+---@param opts? table options for configuring signcolumn and the overall padding
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").component.signcolumn()
+function M.signcolumn(opts)
+  opts = extend_tbl({
+    signcolumn = {},
+    condition = condition.signcolumn_enabled,
+    on_click = {
+      name = "sign_click",
+      callback = function(...)
+        local args = status_utils.statuscolumn_clickargs(...)
+        if args.sign and args.sign.name and env.sign_handlers[args.sign.name] then
+          env.sign_handlers[args.sign.name](args)
+        end
+      end,
+    },
+  }, opts)
+  return M.builder(status_utils.setup_providers(opts, { "signcolumn" }))
+end
+
+--- A general function to build a section of astronvim status providers with highlights, conditions, and section surrounding
+---@param opts? table a list of components to build into a section
+---@return table # The Heirline component table
+-- @usage local heirline_component = require("astronvim.utils.status").components.builder({ { provider = "file_icon", opts = { padding = { right = 1 } } }, { provider = "filename" } })
+function M.builder(opts)
+  opts = extend_tbl({ padding = { left = 0, right = 0 } }, opts)
+  local children = {}
+  if opts.padding.left > 0 then -- add left padding
+    table.insert(children, { provider = status_utils.pad_string(" ", { left = opts.padding.left - 1 }) })
+  end
+  for key, entry in pairs(opts) do
+    if
+      type(key) == "number"
+      and type(entry) == "table"
+      and provider[entry.provider]
+      and (entry.opts == nil or type(entry.opts) == "table")
+    then
+      entry.provider = provider[entry.provider](entry.opts)
+    end
+    children[key] = entry
+  end
+  if opts.padding.right > 0 then -- add right padding
+    table.insert(children, { provider = status_utils.pad_string(" ", { right = opts.padding.right - 1 }) })
+  end
+  return opts.surround
+      and status_utils.surround(opts.surround.separator, opts.surround.color, children, opts.surround.condition)
+    or children
+end
+
+return M
diff --git a/lua/astronvim/utils/status/condition.lua b/lua/astronvim/utils/status/condition.lua
new file mode 100644
index 0000000..3f289b9
--- /dev/null
+++ b/lua/astronvim/utils/status/condition.lua
@@ -0,0 +1,142 @@
+--- ### AstroNvim Status Conditions
+--
+-- Statusline related condition functions to use with Heirline
+--
+-- This module can be loaded with `local condition = require "astronvim.utils.status.condition"`
+--
+-- @module astronvim.utils.status.condition
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local env = require "astronvim.utils.status.env"
+
+--- A condition function if the window is currently active
+---@return boolean # whether or not the window is currently actie
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.is_active }
+function M.is_active() return vim.api.nvim_get_current_win() == tonumber(vim.g.actual_curwin) end
+
+--- A condition function if the buffer filetype,buftype,bufname match a pattern
+---@param patterns table the table of patterns to match
+---@param bufnr number of the buffer to match (Default: 0 [current])
+---@return boolean # whether or not LSP is attached
+-- @usage local heirline_component = { provider = "Example Provider", condition = function() return require("astronvim.utils.status").condition.buffer_matches { buftype = { "terminal" } } end }
+function M.buffer_matches(patterns, bufnr)
+  for kind, pattern_list in pairs(patterns) do
+    if env.buf_matchers[kind](pattern_list, bufnr) then return true end
+  end
+  return false
+end
+
+--- A condition function if a macro is being recorded
+---@return boolean # whether or not a macro is currently being recorded
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.is_macro_recording }
+function M.is_macro_recording() return vim.fn.reg_recording() ~= "" end
+
+--- A condition function if search is visible
+---@return boolean # whether or not searching is currently visible
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.is_hlsearch }
+function M.is_hlsearch() return vim.v.hlsearch ~= 0 end
+
+--- A condition function if showcmdloc is set to statusline
+---@return boolean # whether or not statusline showcmd is enabled
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.is_statusline_showcmd }
+function M.is_statusline_showcmd() return vim.fn.has "nvim-0.9" == 1 and vim.opt.showcmdloc:get() == "statusline" end
+
+--- A condition function if the current file is in a git repo
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not the current file is in a git repo
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.is_git_repo }
+function M.is_git_repo(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  return vim.b[bufnr or 0].gitsigns_head or vim.b[bufnr or 0].gitsigns_status_dict
+end
+
+--- A condition function if there are any git changes
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not there are any git changes
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.git_changed }
+function M.git_changed(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  local git_status = vim.b[bufnr or 0].gitsigns_status_dict
+  return git_status and (git_status.added or 0) + (git_status.removed or 0) + (git_status.changed or 0) > 0
+end
+
+--- A condition function if the current buffer is modified
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not the current buffer is modified
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.file_modified }
+function M.file_modified(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  return vim.bo[bufnr or 0].modified
+end
+
+--- A condition function if the current buffer is read only
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not the current buffer is read only or not modifiable
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.file_read_only }
+function M.file_read_only(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  local buffer = vim.bo[bufnr or 0]
+  return not buffer.modifiable or buffer.readonly
+end
+
+--- A condition function if the current file has any diagnostics
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not the current file has any diagnostics
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.has_diagnostics }
+function M.has_diagnostics(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  return vim.g.diagnostics_mode > 0 and #vim.diagnostic.get(bufnr or 0) > 0
+end
+
+--- A condition function if there is a defined filetype
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not there is a filetype
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.has_filetype }
+function M.has_filetype(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  return vim.bo[bufnr or 0].filetype and vim.bo[bufnr or 0].filetype ~= ""
+end
+
+--- A condition function if Aerial is available
+---@return boolean # whether or not aerial plugin is installed
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.aerial_available }
+-- function M.aerial_available() return is_available "aerial.nvim" end
+function M.aerial_available() return package.loaded["aerial"] end
+
+--- A condition function if LSP is attached
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not LSP is attached
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.lsp_attached }
+function M.lsp_attached(bufnr)
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  -- HACK: Check for lsp utilities loaded first, get_active_clients seems to have a bug if called too early (tokyonight colorscheme seems to be a good way to expose this for some reason)
+  return package.loaded["astronvim.utils.lsp"] and next(vim.lsp.get_active_clients { bufnr = bufnr or 0 }) ~= nil
+end
+
+--- A condition function if treesitter is in use
+---@param bufnr table|integer a buffer number to check the condition for, a table with bufnr property, or nil to get the current buffer
+---@return boolean # whether or not treesitter is active
+-- @usage local heirline_component = { provider = "Example Provider", condition = require("astronvim.utils.status").condition.treesitter_available }
+function M.treesitter_available(bufnr)
+  if not package.loaded["nvim-treesitter"] then return false end
+  if type(bufnr) == "table" then bufnr = bufnr.bufnr end
+  local parsers = require "nvim-treesitter.parsers"
+  return parsers.has_parser(parsers.get_buf_lang(bufnr or vim.api.nvim_get_current_buf()))
+end
+
+--- A condition function if the foldcolumn is enabled
+---@return boolean # true if vim.opt.foldcolumn > 0, false if vim.opt.foldcolumn == 0
+function M.foldcolumn_enabled() return vim.opt.foldcolumn:get() ~= "0" end
+
+--- A condition function if the number column is enabled
+---@return boolean # true if vim.opt.number or vim.opt.relativenumber, false if neither
+function M.numbercolumn_enabled() return vim.opt.number:get() or vim.opt.relativenumber:get() end
+
+--- A condition function if the signcolumn is enabled
+---@return boolean # false if vim.opt.signcolumn == "no", true otherwise
+function M.signcolumn_enabled() return vim.opt.signcolumn:get() ~= "no" end
+
+return M
diff --git a/lua/astronvim/utils/status/env.lua b/lua/astronvim/utils/status/env.lua
new file mode 100644
index 0000000..257abae
--- /dev/null
+++ b/lua/astronvim/utils/status/env.lua
@@ -0,0 +1,143 @@
+--- ### AstroNvim Status Environment
+--
+-- Statusline related environment variables shared between components/providers/etc.
+--
+-- This module can be loaded with `local env = require "astronvim.utils.status.env"`
+--
+-- @module astronvim.utils.status.env
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+M.fallback_colors = {
+  none = "NONE",
+  fg = "#abb2bf",
+  bg = "#1e222a",
+  dark_bg = "#2c323c",
+  blue = "#61afef",
+  green = "#98c379",
+  grey = "#5c6370",
+  bright_grey = "#777d86",
+  dark_grey = "#5c5c5c",
+  orange = "#ff9640",
+  purple = "#c678dd",
+  bright_purple = "#a9a1e1",
+  red = "#e06c75",
+  bright_red = "#ec5f67",
+  white = "#c9c9c9",
+  yellow = "#e5c07b",
+  bright_yellow = "#ebae34",
+}
+
+M.modes = {
+  ["n"] = { "NORMAL", "normal" },
+  ["no"] = { "OP", "normal" },
+  ["nov"] = { "OP", "normal" },
+  ["noV"] = { "OP", "normal" },
+  ["no"] = { "OP", "normal" },
+  ["niI"] = { "NORMAL", "normal" },
+  ["niR"] = { "NORMAL", "normal" },
+  ["niV"] = { "NORMAL", "normal" },
+  ["i"] = { "INSERT", "insert" },
+  ["ic"] = { "INSERT", "insert" },
+  ["ix"] = { "INSERT", "insert" },
+  ["t"] = { "TERM", "terminal" },
+  ["nt"] = { "TERM", "terminal" },
+  ["v"] = { "VISUAL", "visual" },
+  ["vs"] = { "VISUAL", "visual" },
+  ["V"] = { "LINES", "visual" },
+  ["Vs"] = { "LINES", "visual" },
+  [""] = { "BLOCK", "visual" },
+  ["s"] = { "BLOCK", "visual" },
+  ["R"] = { "REPLACE", "replace" },
+  ["Rc"] = { "REPLACE", "replace" },
+  ["Rx"] = { "REPLACE", "replace" },
+  ["Rv"] = { "V-REPLACE", "replace" },
+  ["s"] = { "SELECT", "visual" },
+  ["S"] = { "SELECT", "visual" },
+  [""] = { "BLOCK", "visual" },
+  ["c"] = { "COMMAND", "command" },
+  ["cv"] = { "COMMAND", "command" },
+  ["ce"] = { "COMMAND", "command" },
+  ["r"] = { "PROMPT", "inactive" },
+  ["rm"] = { "MORE", "inactive" },
+  ["r?"] = { "CONFIRM", "inactive" },
+  ["!"] = { "SHELL", "inactive" },
+  ["null"] = { "null", "inactive" },
+}
+
+M.separators = astronvim.user_opts("heirline.separators", {
+  none = { "", "" },
+  left = { "", "  " },
+  right = { "  ", "" },
+  center = { "  ", "  " },
+  tab = { "", " " },
+  breadcrumbs = "  ",
+  path = "  ",
+})
+
+M.attributes = astronvim.user_opts("heirline.attributes", {
+  buffer_active = { bold = true, italic = true },
+  buffer_picker = { bold = true },
+  macro_recording = { bold = true },
+  git_branch = { bold = true },
+  git_diff = { bold = true },
+})
+
+M.icon_highlights = astronvim.user_opts("heirline.icon_highlights", {
+  file_icon = {
+    tabline = function(self) return self.is_active or self.is_visible end,
+    statusline = true,
+  },
+})
+
+local function pattern_match(str, pattern_list)
+  for _, pattern in ipairs(pattern_list) do
+    if str:find(pattern) then return true end
+  end
+  return false
+end
+
+M.buf_matchers = {
+  filetype = function(pattern_list, bufnr) return pattern_match(vim.bo[bufnr or 0].filetype, pattern_list) end,
+  buftype = function(pattern_list, bufnr) return pattern_match(vim.bo[bufnr or 0].buftype, pattern_list) end,
+  bufname = function(pattern_list, bufnr)
+    return pattern_match(vim.fn.fnamemodify(vim.api.nvim_buf_get_name(bufnr or 0), ":t"), pattern_list)
+  end,
+}
+
+M.sign_handlers = {}
+-- gitsigns handlers
+local gitsigns = function(_)
+  local gitsigns_avail, gitsigns = pcall(require, "gitsigns")
+  if gitsigns_avail then vim.schedule(gitsigns.preview_hunk) end
+end
+for _, sign in ipairs { "Topdelete", "Untracked", "Add", "Changedelete", "Delete" } do
+  local name = "GitSigns" .. sign
+  if not M.sign_handlers[name] then M.sign_handlers[name] = gitsigns end
+end
+-- diagnostic handlers
+local diagnostics = function(args)
+  if args.mods:find "c" then
+    vim.schedule(vim.lsp.buf.code_action)
+  else
+    vim.schedule(vim.diagnostic.open_float)
+  end
+end
+for _, sign in ipairs { "Error", "Hint", "Info", "Warn" } do
+  local name = "DiagnosticSign" .. sign
+  if not M.sign_handlers[name] then M.sign_handlers[name] = diagnostics end
+end
+-- DAP handlers
+local dap_breakpoint = function(_)
+  local dap_avail, dap = pcall(require, "dap")
+  if dap_avail then vim.schedule(dap.toggle_breakpoint) end
+end
+for _, sign in ipairs { "", "Rejected", "Condition" } do
+  local name = "DapBreakpoint" .. sign
+  if not M.sign_handlers[name] then M.sign_handlers[name] = dap_breakpoint end
+end
+M.sign_handlers = astronvim.user_opts("heirline.sign_handlers", M.sign_handlers)
+
+return M
diff --git a/lua/astronvim/utils/status/heirline.lua b/lua/astronvim/utils/status/heirline.lua
new file mode 100644
index 0000000..7d924ad
--- /dev/null
+++ b/lua/astronvim/utils/status/heirline.lua
@@ -0,0 +1,115 @@
+--- ### AstroNvim Status Heirline Extensions
+--
+-- Statusline related heirline specific extensions
+--
+-- This module can be loaded with `local astro_heirline = require "astronvim.utils.status.heirline"`
+--
+-- @module astronvim.utils.status.heirline
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local hl = require "astronvim.utils.status.hl"
+local provider = require "astronvim.utils.status.provider"
+local status_utils = require "astronvim.utils.status.utils"
+
+local utils = require "astronvim.utils"
+local buffer_utils = require "astronvim.utils.buffer"
+local get_icon = utils.get_icon
+
+--- A helper function to get the type a tab or buffer is
+---@param self table the self table from a heirline component function
+---@param prefix? string the prefix of the type, either "tab" or "buffer" (Default: "buffer")
+---@return string # the string of prefix with the type (i.e. "_active" or "_visible")
+function M.tab_type(self, prefix)
+  local tab_type = ""
+  if self.is_active then
+    tab_type = "_active"
+  elseif self.is_visible then
+    tab_type = "_visible"
+  end
+  return (prefix or "buffer") .. tab_type
+end
+
+--- Make a list of buffers, rendering each buffer with the provided component
+---@param component table
+---@return table
+M.make_buflist = function(component)
+  local overflow_hl = hl.get_attributes("buffer_overflow", true)
+  return require("heirline.utils").make_buflist(
+    status_utils.surround(
+      "tab",
+      function(self)
+        return {
+          main = M.tab_type(self) .. "_bg",
+          left = "tabline_bg",
+          right = "tabline_bg",
+        }
+      end,
+      { -- bufferlist
+        init = function(self) self.tab_type = M.tab_type(self) end,
+        on_click = { -- add clickable component to each buffer
+          callback = function(_, minwid) vim.api.nvim_win_set_buf(0, minwid) end,
+          minwid = function(self) return self.bufnr end,
+          name = "heirline_tabline_buffer_callback",
+        },
+        { -- add buffer picker functionality to each buffer
+          condition = function(self) return self._show_picker end,
+          update = false,
+          init = function(self)
+            if not (self.label and self._picker_labels[self.label]) then
+              local bufname = provider.filename()(self)
+              local label = bufname:sub(1, 1)
+              local i = 2
+              while label ~= " " and self._picker_labels[label] do
+                if i > #bufname then break end
+                label = bufname:sub(i, i)
+                i = i + 1
+              end
+              self._picker_labels[label] = self.bufnr
+              self.label = label
+            end
+          end,
+          provider = function(self) return provider.str { str = self.label, padding = { left = 1, right = 1 } } end,
+          hl = hl.get_attributes "buffer_picker",
+        },
+        component, -- create buffer component
+      },
+      function(self) return buffer_utils.is_valid(self.bufnr) end -- disable surrounding
+    ),
+    { provider = get_icon "ArrowLeft" .. " ", hl = overflow_hl },
+    { provider = get_icon "ArrowRight" .. " ", hl = overflow_hl },
+    function() return vim.t.bufs or {} end, -- use astronvim bufs variable
+    false -- disable internal caching
+  )
+end
+
+--- Alias to require("heirline.utils").make_tablist
+function M.make_tablist(...) return require("heirline.utils").make_tablist(...) end
+
+--- Run the buffer picker and execute the callback function on the selected buffer
+---@param callback function with a single parameter of the buffer number
+function M.buffer_picker(callback)
+  local tabline = require("heirline").tabline
+  -- if buflist then
+  local prev_showtabline = vim.opt.showtabline:get()
+  if prev_showtabline ~= 2 then vim.opt.showtabline = 2 end
+  vim.cmd.redrawtabline()
+  ---@diagnostic disable-next-line: undefined-field
+  local buflist = tabline and tabline._buflist and tabline._buflist[1]
+  if buflist then
+    buflist._picker_labels = {}
+    buflist._show_picker = true
+    vim.cmd.redrawtabline()
+    local char = vim.fn.getcharstr()
+    local bufnr = buflist._picker_labels[char]
+    if bufnr then callback(bufnr) end
+    buflist._show_picker = false
+  end
+  if prev_showtabline ~= 2 then vim.opt.showtabline = prev_showtabline end
+  vim.cmd.redrawtabline()
+  -- end
+end
+
+return M
diff --git a/lua/astronvim/utils/status/hl.lua b/lua/astronvim/utils/status/hl.lua
new file mode 100644
index 0000000..91dab18
--- /dev/null
+++ b/lua/astronvim/utils/status/hl.lua
@@ -0,0 +1,76 @@
+--- ### AstroNvim Status Highlighting
+--
+-- Statusline related highlighting utilities
+--
+-- This module can be loaded with `local hl = require "astronvim.utils.status.hl"`
+--
+-- @module astronvim.utils.status.hl
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local env = require "astronvim.utils.status.env"
+
+--- Get the highlight background color of the lualine theme for the current colorscheme
+---@param mode string the neovim mode to get the color of
+---@param fallback string the color to fallback on if a lualine theme is not present
+---@return string # The background color of the lualine theme or the fallback parameter if one doesn't exist
+function M.lualine_mode(mode, fallback)
+  if not vim.g.colors_name then return fallback end
+  local lualine_avail, lualine = pcall(require, "lualine.themes." .. vim.g.colors_name)
+  local lualine_opts = lualine_avail and lualine[mode]
+  return lualine_opts and type(lualine_opts.a) == "table" and lualine_opts.a.bg or fallback
+end
+
+--- Get the highlight for the current mode
+---@return table # the highlight group for the current mode
+-- @usage local heirline_component = { provider = "Example Provider", hl = require("astronvim.utils.status").hl.mode },
+function M.mode() return { bg = M.mode_bg() } end
+
+--- Get the foreground color group for the current mode, good for usage with Heirline surround utility
+---@return string # the highlight group for the current mode foreground
+-- @usage local heirline_component = require("heirline.utils").surround({ "|", "|" }, require("astronvim.utils.status").hl.mode_bg, heirline_component),
+
+function M.mode_bg() return env.modes[vim.fn.mode()][2] end
+
+--- Get the foreground color group for the current filetype
+---@return table # the highlight group for the current filetype foreground
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.fileicon(), hl = require("astronvim.utils.status").hl.filetype_color },
+function M.filetype_color(self)
+  local devicons_avail, devicons = pcall(require, "nvim-web-devicons")
+  if not devicons_avail then return {} end
+  local _, color = devicons.get_icon_color(
+    vim.fn.fnamemodify(vim.api.nvim_buf_get_name(self and self.bufnr or 0), ":t"),
+    nil,
+    { default = true }
+  )
+  return { fg = color }
+end
+
+--- Merge the color and attributes from user settings for a given name
+---@param name string, the name of the element to get the attributes and colors for
+---@param include_bg? boolean whether or not to include background color (Default: false)
+---@return table # a table of highlight information
+-- @usage local heirline_component = { provider = "Example Provider", hl = require("astronvim.utils.status").hl.get_attributes("treesitter") },
+function M.get_attributes(name, include_bg)
+  local hl = env.attributes[name] or {}
+  hl.fg = name .. "_fg"
+  if include_bg then hl.bg = name .. "_bg" end
+  return hl
+end
+
+--- Enable filetype color highlight if enabled in icon_highlights.file_icon options
+---@param name string the icon_highlights.file_icon table element
+---@return function # for setting hl property in a component
+-- @usage local heirline_component = { provider = "Example Provider", hl = require("astronvim.utils.status").hl.file_icon("winbar") },
+function M.file_icon(name)
+  local hl_enabled = env.icon_highlights.file_icon[name]
+  return function(self)
+    if hl_enabled == true or (type(hl_enabled) == "function" and hl_enabled(self)) then
+      return M.filetype_color(self)
+    end
+  end
+end
+
+return M
diff --git a/lua/astronvim/utils/status/init.lua b/lua/astronvim/utils/status/init.lua
new file mode 100644
index 0000000..3f5cb0b
--- /dev/null
+++ b/lua/astronvim/utils/status/init.lua
@@ -0,0 +1,155 @@
+--- ### AstroNvim Status Initializers
+--
+-- Statusline related init functions for building dynamic statusline components
+--
+-- This module can be loaded with `local init = require "astronvim.utils.status.init"`
+--
+-- @module astronvim.utils.status.init
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local env = require "astronvim.utils.status.env"
+local provider = require "astronvim.utils.status.provider"
+local status_utils = require "astronvim.utils.status.utils"
+
+local utils = require "astronvim.utils"
+local extend_tbl = utils.extend_tbl
+
+--- An `init` function to build a set of children components for LSP breadcrumbs
+---@param opts? table # options for configuring the breadcrumbs (default: `{ max_depth = 5, separator = "  ", icon = { enabled = true, hl = false }, padding = { left = 0, right = 0 } }`)
+---@return function # The Heirline init function
+-- @usage local heirline_component = { init = require("astronvim.utils.status").init.breadcrumbs { padding = { left = 1 } } }
+function M.breadcrumbs(opts)
+  opts = extend_tbl({
+    max_depth = 5,
+    separator = env.separators.breadcrumbs or "  ",
+    icon = { enabled = true, hl = env.icon_highlights.breadcrumbs },
+    padding = { left = 0, right = 0 },
+  }, opts)
+  return function(self)
+    local data = require("aerial").get_location(true) or {}
+    local children = {}
+    -- add prefix if needed, use the separator if true, or use the provided character
+    if opts.prefix and not vim.tbl_isempty(data) then
+      table.insert(children, { provider = opts.prefix == true and opts.separator or opts.prefix })
+    end
+    local start_idx = 0
+    if opts.max_depth and opts.max_depth > 0 then
+      start_idx = #data - opts.max_depth
+      if start_idx > 0 then
+        table.insert(children, { provider = require("astronvim.utils").get_icon "Ellipsis" .. opts.separator })
+      end
+    end
+    -- create a child for each level
+    for i, d in ipairs(data) do
+      if i > start_idx then
+        local child = {
+          { provider = string.gsub(d.name, "%%", "%%%%"):gsub("%s*->%s*", "") }, -- add symbol name
+          on_click = { -- add on click function
+            minwid = status_utils.encode_pos(d.lnum, d.col, self.winnr),
+            callback = function(_, minwid)
+              local lnum, col, winnr = status_utils.decode_pos(minwid)
+              vim.api.nvim_win_set_cursor(vim.fn.win_getid(winnr), { lnum, col })
+            end,
+            name = "heirline_breadcrumbs",
+          },
+        }
+        if opts.icon.enabled then -- add icon and highlight if enabled
+          local hl = opts.icon.hl
+          if type(hl) == "function" then hl = hl(self) end
+          local hlgroup = string.format("Aerial%sIcon", d.kind)
+          table.insert(child, 1, {
+            provider = string.format("%s ", d.icon),
+            hl = (hl and vim.fn.hlexists(hlgroup) == 1) and hlgroup or nil,
+          })
+        end
+        if #data > 1 and i < #data then table.insert(child, { provider = opts.separator }) end -- add a separator only if needed
+        table.insert(children, child)
+      end
+    end
+    if opts.padding.left > 0 then -- add left padding
+      table.insert(children, 1, { provider = status_utils.pad_string(" ", { left = opts.padding.left - 1 }) })
+    end
+    if opts.padding.right > 0 then -- add right padding
+      table.insert(children, { provider = status_utils.pad_string(" ", { right = opts.padding.right - 1 }) })
+    end
+    -- instantiate the new child
+    self[1] = self:new(children, 1)
+  end
+end
+
+--- An `init` function to build a set of children components for a separated path to file
+---@param opts? table options for configuring the breadcrumbs (default: `{ max_depth = 3, path_func = provider.unique_path(), separator = "  ", suffix = true, padding = { left = 0, right = 0 } }`)
+---@return function # The Heirline init function
+-- @usage local heirline_component = { init = require("astronvim.utils.status").init.separated_path { padding = { left = 1 } } }
+function M.separated_path(opts)
+  opts = extend_tbl({
+    max_depth = 3,
+    path_func = provider.unique_path(),
+    separator = env.separators.path or "  ",
+    suffix = true,
+    padding = { left = 0, right = 0 },
+  }, opts)
+  if opts.suffix == true then opts.suffix = opts.separator end
+  return function(self)
+    local path = opts.path_func(self)
+    if path == "." then path = "" end -- if there is no path, just replace with empty string
+    local data = vim.fn.split(path, "/")
+    local children = {}
+    -- add prefix if needed, use the separator if true, or use the provided character
+    if opts.prefix and not vim.tbl_isempty(data) then
+      table.insert(children, { provider = opts.prefix == true and opts.separator or opts.prefix })
+    end
+    local start_idx = 0
+    if opts.max_depth and opts.max_depth > 0 then
+      start_idx = #data - opts.max_depth
+      if start_idx > 0 then
+        table.insert(children, { provider = require("astronvim.utils").get_icon "Ellipsis" .. opts.separator })
+      end
+    end
+    -- create a child for each level
+    for i, d in ipairs(data) do
+      if i > start_idx then
+        local child = { { provider = d } }
+        local separator = i < #data and opts.separator or opts.suffix
+        if separator then table.insert(child, { provider = separator }) end
+        table.insert(children, child)
+      end
+    end
+    if opts.padding.left > 0 then -- add left padding
+      table.insert(children, 1, { provider = status_utils.pad_string(" ", { left = opts.padding.left - 1 }) })
+    end
+    if opts.padding.right > 0 then -- add right padding
+      table.insert(children, { provider = status_utils.pad_string(" ", { right = opts.padding.right - 1 }) })
+    end
+    -- instantiate the new child
+    self[1] = self:new(children, 1)
+  end
+end
+
+--- An `init` function to build multiple update events which is not supported yet by Heirline's update field
+---@param opts any[] an array like table of autocmd events as either just a string or a table with custom patterns and callbacks.
+---@return function # The Heirline init function
+-- @usage local heirline_component = { init = require("astronvim.utils.status").init.update_events { "BufEnter", { "User", pattern = "LspProgressUpdate" } } }
+function M.update_events(opts)
+  return function(self)
+    if not rawget(self, "once") then
+      local clear_cache = function() self._win_cache = nil end
+      for _, event in ipairs(opts) do
+        local event_opts = { callback = clear_cache }
+        if type(event) == "table" then
+          event_opts.pattern = event.pattern
+          event_opts.callback = event.callback or clear_cache
+          event.pattern = nil
+          event.callback = nil
+        end
+        vim.api.nvim_create_autocmd(event, event_opts)
+      end
+      self.once = true
+    end
+  end
+end
+
+return M
diff --git a/lua/astronvim/utils/status/provider.lua b/lua/astronvim/utils/status/provider.lua
new file mode 100644
index 0000000..64ba65a
--- /dev/null
+++ b/lua/astronvim/utils/status/provider.lua
@@ -0,0 +1,527 @@
+--- ### AstroNvim Status Providers
+--
+-- Statusline related provider functions for building statusline components
+--
+-- This module can be loaded with `local provider = require "astronvim.utils.status.provider"`
+--
+-- @module astronvim.utils.status.provider
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local condition = require "astronvim.utils.status.condition"
+local env = require "astronvim.utils.status.env"
+local status_utils = require "astronvim.utils.status.utils"
+
+local utils = require "astronvim.utils"
+local extend_tbl = utils.extend_tbl
+local get_icon = utils.get_icon
+local luv = vim.uv or vim.loop -- TODO: REMOVE WHEN DROPPING SUPPORT FOR Neovim v0.9
+
+--- A provider function for the fill string
+---@return string # the statusline string for filling the empty space
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.fill }
+function M.fill() return "%=" end
+
+--- A provider function for the signcolumn string
+---@param opts? table options passed to the stylize function
+---@return string # the statuscolumn string for adding the signcolumn
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.signcolumn }
+-- @see astronvim.utils.status.utils.stylize
+function M.signcolumn(opts)
+  opts = extend_tbl({ escape = false }, opts)
+  return status_utils.stylize("%s", opts)
+end
+
+--- A provider function for the numbercolumn string
+---@param opts? table options passed to the stylize function
+---@return function # the statuscolumn string for adding the numbercolumn
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.numbercolumn }
+-- @see astronvim.utils.status.utils.stylize
+function M.numbercolumn(opts)
+  opts = extend_tbl({ thousands = false, culright = true, escape = false }, opts)
+  return function(self)
+    local lnum, rnum, virtnum = vim.v.lnum, vim.v.relnum, vim.v.virtnum
+    local num, relnum = vim.opt.number:get(), vim.opt.relativenumber:get()
+    local signs = vim.opt.signcolumn:get():find "nu"
+      and vim.fn.sign_getplaced(self.bufnr or vim.api.nvim_get_current_buf(), { group = "*", lnum = lnum })[1].signs
+    local str
+    if virtnum ~= 0 then
+      str = "%="
+    elseif signs and #signs > 0 then
+      local sign = vim.fn.sign_getdefined(signs[1].name)[1]
+      str = "%=%#" .. sign.texthl .. "#" .. sign.text .. "%*"
+    elseif not num and not relnum then
+      str = "%="
+    else
+      local cur = relnum and (rnum > 0 and rnum or (num and lnum or 0)) or lnum
+      if opts.thousands and cur > 999 then
+        cur = string.reverse(cur):gsub("%d%d%d", "%1" .. opts.thousands):reverse():gsub("^%" .. opts.thousands, "")
+      end
+      str = (rnum == 0 and not opts.culright and relnum) and cur .. "%=" or "%=" .. cur
+    end
+    return status_utils.stylize(str, opts)
+  end
+end
+
+--- A provider function for building a foldcolumn
+---@param opts? table options passed to the stylize function
+---@return function # a custom foldcolumn function for the statuscolumn that doesn't show the nest levels
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.foldcolumn }
+-- @see astronvim.utils.status.utils.stylize
+function M.foldcolumn(opts)
+  opts = extend_tbl({ escape = false }, opts)
+  local ffi = require "astronvim.utils.ffi" -- get AstroNvim C extensions
+  local fillchars = vim.opt.fillchars:get()
+  local foldopen = fillchars.foldopen or get_icon "FoldOpened"
+  local foldclosed = fillchars.foldclose or get_icon "FoldClosed"
+  local foldsep = fillchars.foldsep or get_icon "FoldSeparator"
+  return function() -- move to M.fold_indicator
+    local wp = ffi.C.find_window_by_handle(0, ffi.new "Error") -- get window handler
+    local width = ffi.C.compute_foldcolumn(wp, 0) -- get foldcolumn width
+    -- get fold info of current line
+    local foldinfo = width > 0 and ffi.C.fold_info(wp, vim.v.lnum) or { start = 0, level = 0, llevel = 0, lines = 0 }
+
+    local str = ""
+    if width ~= 0 then
+      str = vim.v.relnum > 0 and "%#FoldColumn#" or "%#CursorLineFold#"
+      if foldinfo.level == 0 then
+        str = str .. (" "):rep(width)
+      else
+        local closed = foldinfo.lines > 0
+        local first_level = foldinfo.level - width - (closed and 1 or 0) + 1
+        if first_level < 1 then first_level = 1 end
+
+        for col = 1, width do
+          str = str
+            .. (
+              (vim.v.virtnum ~= 0 and foldsep)
+              or ((closed and (col == foldinfo.level or col == width)) and foldclosed)
+              or ((foldinfo.start == vim.v.lnum and first_level + col > foldinfo.llevel) and foldopen)
+              or foldsep
+            )
+          if col == foldinfo.level then
+            str = str .. (" "):rep(width - col)
+            break
+          end
+        end
+      end
+    end
+    return status_utils.stylize(str .. "%*", opts)
+  end
+end
+
+--- A provider function for the current tab numbre
+---@return function # the statusline function to return a string for a tab number
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.tabnr() }
+function M.tabnr()
+  return function(self) return (self and self.tabnr) and "%" .. self.tabnr .. "T " .. self.tabnr .. " %T" or "" end
+end
+
+--- A provider function for showing if spellcheck is on
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting if spell is enabled
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.spell() }
+-- @see astronvim.utils.status.utils.stylize
+function M.spell(opts)
+  opts = extend_tbl({ str = "", icon = { kind = "Spellcheck" }, show_empty = true }, opts)
+  return function() return status_utils.stylize(vim.wo.spell and opts.str or nil, opts) end
+end
+
+--- A provider function for showing if paste is enabled
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting if paste is enabled
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.paste() }
+-- @see astronvim.utils.status.utils.stylize
+function M.paste(opts)
+  opts = extend_tbl({ str = "", icon = { kind = "Paste" }, show_empty = true }, opts)
+  local paste = vim.opt.paste
+  if type(paste) ~= "boolean" then paste = paste:get() end
+  return function() return status_utils.stylize(paste and opts.str or nil, opts) end
+end
+
+--- A provider function for displaying if a macro is currently being recorded
+---@param opts? table a prefix before the recording register and options passed to the stylize function
+---@return function # a function that returns a string of the current recording status
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.macro_recording() }
+-- @see astronvim.utils.status.utils.stylize
+function M.macro_recording(opts)
+  opts = extend_tbl({ prefix = "@" }, opts)
+  return function()
+    local register = vim.fn.reg_recording()
+    if register ~= "" then register = opts.prefix .. register end
+    return status_utils.stylize(register, opts)
+  end
+end
+
+--- A provider function for displaying the current command
+---@param opts? table of options passed to the stylize function
+---@return string # the statusline string for showing the current command
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.showcmd() }
+-- @see astronvim.utils.status.utils.stylize
+function M.showcmd(opts)
+  opts = extend_tbl({ minwid = 0, maxwid = 5, escape = false }, opts)
+  return status_utils.stylize(("%%%d.%d(%%S%%)"):format(opts.minwid, opts.maxwid), opts)
+end
+
+--- A provider function for displaying the current search count
+---@param opts? table options for `vim.fn.searchcount` and options passed to the stylize function
+---@return function # a function that returns a string of the current search location
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.search_count() }
+-- @see astronvim.utils.status.utils.stylize
+function M.search_count(opts)
+  local search_func = vim.tbl_isempty(opts or {}) and function() return vim.fn.searchcount() end
+    or function() return vim.fn.searchcount(opts) end
+  return function()
+    local search_ok, search = pcall(search_func)
+    if search_ok and type(search) == "table" and search.total then
+      return status_utils.stylize(
+        string.format(
+          "%s%d/%s%d",
+          search.current > search.maxcount and ">" or "",
+          math.min(search.current, search.maxcount),
+          search.incomplete == 2 and ">" or "",
+          math.min(search.total, search.maxcount)
+        ),
+        opts
+      )
+    end
+  end
+end
+
+--- A provider function for showing the text of the current vim mode
+---@param opts? table options for padding the text and options passed to the stylize function
+---@return function # the function for displaying the text of the current vim mode
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.mode_text() }
+-- @see astronvim.utils.status.utils.stylize
+function M.mode_text(opts)
+  local max_length = math.max(unpack(vim.tbl_map(function(str) return #str[1] end, vim.tbl_values(env.modes))))
+  return function()
+    local text = env.modes[vim.fn.mode()][1]
+    if opts and opts.pad_text then
+      local padding = max_length - #text
+      if opts.pad_text == "right" then
+        text = string.rep(" ", padding) .. text
+      elseif opts.pad_text == "left" then
+        text = text .. string.rep(" ", padding)
+      elseif opts.pad_text == "center" then
+        text = string.rep(" ", math.floor(padding / 2)) .. text .. string.rep(" ", math.ceil(padding / 2))
+      end
+    end
+    return status_utils.stylize(text, opts)
+  end
+end
+
+--- A provider function for showing the percentage of the current location in a document
+---@param opts? table options for Top/Bot text, fixed width, and options passed to the stylize function
+---@return function # the statusline string for displaying the percentage of current document location
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.percentage() }
+-- @see astronvim.utils.status.utils.stylize
+function M.percentage(opts)
+  opts = extend_tbl({ escape = false, fixed_width = true, edge_text = true }, opts)
+  return function()
+    local text = "%" .. (opts.fixed_width and (opts.edge_text and "2" or "3") or "") .. "p%%"
+    if opts.edge_text then
+      local current_line = vim.fn.line "."
+      if current_line == 1 then
+        text = "Top"
+      elseif current_line == vim.fn.line "$" then
+        text = "Bot"
+      end
+    end
+    return status_utils.stylize(text, opts)
+  end
+end
+
+--- A provider function for showing the current line and character in a document
+---@param opts? table options for padding the line and character locations and options passed to the stylize function
+---@return function # the statusline string for showing location in document line_num:char_num
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.ruler({ pad_ruler = { line = 3, char = 2 } }) }
+-- @see astronvim.utils.status.utils.stylize
+function M.ruler(opts)
+  opts = extend_tbl({ pad_ruler = { line = 3, char = 2 } }, opts)
+  local padding_str = string.format("%%%dd:%%-%dd", opts.pad_ruler.line, opts.pad_ruler.char)
+  return function()
+    local line = vim.fn.line "."
+    local char = vim.fn.virtcol "."
+    return status_utils.stylize(string.format(padding_str, line, char), opts)
+  end
+end
+
+--- A provider function for showing the current location as a scrollbar
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting the scrollbar
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.scrollbar() }
+-- @see astronvim.utils.status.utils.stylize
+function M.scrollbar(opts)
+  local sbar = { "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█" }
+  return function()
+    local curr_line = vim.api.nvim_win_get_cursor(0)[1]
+    local lines = vim.api.nvim_buf_line_count(0)
+    local i = math.floor((curr_line - 1) / lines * #sbar) + 1
+    if sbar[i] then return status_utils.stylize(string.rep(sbar[i], 2), opts) end
+  end
+end
+
+--- A provider to simply show a close button icon
+---@param opts? table options passed to the stylize function and the kind of icon to use
+---@return string # the stylized icon
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.close_button() }
+-- @see astronvim.utils.status.utils.stylize
+function M.close_button(opts)
+  opts = extend_tbl({ kind = "BufferClose" }, opts)
+  return status_utils.stylize(get_icon(opts.kind), opts)
+end
+
+--- A provider function for showing the current filetype
+---@param opts? table options passed to the stylize function
+---@return function  # the function for outputting the filetype
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.filetype() }
+-- @see astronvim.utils.status.utils.stylize
+function M.filetype(opts)
+  return function(self)
+    local buffer = vim.bo[self and self.bufnr or 0]
+    return status_utils.stylize(string.lower(buffer.filetype), opts)
+  end
+end
+
+--- A provider function for showing the current filename
+---@param opts? table options for argument to fnamemodify to format filename and options passed to the stylize function
+---@return function # the function for outputting the filename
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.filename() }
+-- @see astronvim.utils.status.utils.stylize
+function M.filename(opts)
+  opts = extend_tbl({
+    fallback = "Untitled",
+    fname = function(nr) return vim.api.nvim_buf_get_name(nr) end,
+    modify = ":t",
+  }, opts)
+  return function(self)
+    local path = opts.fname(self and self.bufnr or 0)
+    local filename = vim.fn.fnamemodify(path, opts.modify)
+    return status_utils.stylize((path == "" and opts.fallback or filename), opts)
+  end
+end
+
+--- A provider function for showing the current file encoding
+---@param opts? table options passed to the stylize function
+---@return function  # the function for outputting the file encoding
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.file_encoding() }
+-- @see astronvim.utils.status.utils.stylize
+function M.file_encoding(opts)
+  return function(self)
+    local buf_enc = vim.bo[self and self.bufnr or 0].fenc
+    return status_utils.stylize(string.upper(buf_enc ~= "" and buf_enc or vim.o.enc), opts)
+  end
+end
+
+--- A provider function for showing the current file format
+---@param opts? table options passed to the stylize function
+---@return function  # the function for outputting the file format
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.file_format() }
+-- @see astronvim.utils.status.utils.stylize
+function M.file_format(opts)
+  return function(self)
+    local buf_format = vim.bo[self and self.bufnr or 0].fileformat
+    return status_utils.stylize(string.upper(buf_format ~= "" and buf_format or vim.o.fileformat), opts)
+  end
+end
+
+--- Get a unique filepath between all buffers
+---@param opts? table options for function to get the buffer name, a buffer number, max length, and options passed to the stylize function
+---@return function # path to file that uniquely identifies each buffer
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.unique_path() }
+-- @see astronvim.utils.status.utils.stylize
+function M.unique_path(opts)
+  opts = extend_tbl({
+    buf_name = function(bufnr) return vim.fn.fnamemodify(vim.api.nvim_buf_get_name(bufnr), ":t") end,
+    bufnr = 0,
+    max_length = 16,
+  }, opts)
+  local function path_parts(bufnr)
+    local parts = {}
+    for match in (vim.api.nvim_buf_get_name(bufnr) .. "/"):gmatch("(.-)" .. "/") do
+      table.insert(parts, match)
+    end
+    return parts
+  end
+  return function(self)
+    opts.bufnr = self and self.bufnr or opts.bufnr
+    local name = opts.buf_name(opts.bufnr)
+    local unique_path = ""
+    -- check for same buffer names under different dirs
+    local current
+    for _, value in ipairs(vim.t.bufs or {}) do
+      if name == opts.buf_name(value) and value ~= opts.bufnr then
+        if not current then current = path_parts(opts.bufnr) end
+        local other = path_parts(value)
+
+        for i = #current - 1, 1, -1 do
+          if current[i] ~= other[i] then
+            unique_path = current[i] .. "/"
+            break
+          end
+        end
+      end
+    end
+    return status_utils.stylize(
+      (
+        opts.max_length > 0
+        and #unique_path > opts.max_length
+        and string.sub(unique_path, 1, opts.max_length - 2) .. get_icon "Ellipsis" .. "/"
+      ) or unique_path,
+      opts
+    )
+  end
+end
+
+--- A provider function for showing if the current file is modifiable
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting the indicator if the file is modified
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.file_modified() }
+-- @see astronvim.utils.status.utils.stylize
+function M.file_modified(opts)
+  opts = extend_tbl({ str = "", icon = { kind = "FileModified" }, show_empty = true }, opts)
+  return function(self)
+    return status_utils.stylize(condition.file_modified((self or {}).bufnr) and opts.str or nil, opts)
+  end
+end
+
+--- A provider function for showing if the current file is read-only
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting the indicator if the file is read-only
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.file_read_only() }
+-- @see astronvim.utils.status.utils.stylize
+function M.file_read_only(opts)
+  opts = extend_tbl({ str = "", icon = { kind = "FileReadOnly" }, show_empty = true }, opts)
+  return function(self)
+    return status_utils.stylize(condition.file_read_only((self or {}).bufnr) and opts.str or nil, opts)
+  end
+end
+
+--- A provider function for showing the current filetype icon
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting the filetype icon
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.file_icon() }
+-- @see astronvim.utils.status.utils.stylize
+function M.file_icon(opts)
+  return function(self)
+    local devicons_avail, devicons = pcall(require, "nvim-web-devicons")
+    if not devicons_avail then return "" end
+    local bufnr = self and self.bufnr or 0
+    local ft_icon, _ = devicons.get_icon(vim.fn.fnamemodify(vim.api.nvim_buf_get_name(bufnr), ":t"))
+    if not ft_icon then
+      ft_icon, _ = devicons.get_icon_by_filetype(vim.bo[bufnr].filetype, { default = true })
+    end
+    return status_utils.stylize(ft_icon, opts)
+  end
+end
+
+--- A provider function for showing the current git branch
+---@param opts table options passed to the stylize function
+---@return function # the function for outputting the git branch
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.git_branch() }
+-- @see astronvim.utils.status.utils.stylize
+function M.git_branch(opts)
+  return function(self) return status_utils.stylize(vim.b[self and self.bufnr or 0].gitsigns_head or "", opts) end
+end
+
+--- A provider function for showing the current git diff count of a specific type
+---@param opts? table options for type of git diff and options passed to the stylize function
+---@return function|nil # the function for outputting the git diff
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.git_diff({ type = "added" }) }
+-- @see astronvim.utils.status.utils.stylize
+function M.git_diff(opts)
+  if not opts or not opts.type then return end
+  return function(self)
+    local status = vim.b[self and self.bufnr or 0].gitsigns_status_dict
+    return status_utils.stylize(
+      status and status[opts.type] and status[opts.type] > 0 and tostring(status[opts.type]) or "",
+      opts
+    )
+  end
+end
+
+--- A provider function for showing the current diagnostic count of a specific severity
+---@param opts table options for severity of diagnostic and options passed to the stylize function
+---@return function|nil # the function for outputting the diagnostic count
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.diagnostics({ severity = "ERROR" }) }
+-- @see astronvim.utils.status.utils.stylize
+function M.diagnostics(opts)
+  if not opts or not opts.severity then return end
+  return function(self)
+    local bufnr = self and self.bufnr or 0
+    local count = #vim.diagnostic.get(bufnr, opts.severity and { severity = vim.diagnostic.severity[opts.severity] })
+    return status_utils.stylize(count ~= 0 and tostring(count) or "", opts)
+  end
+end
+
+--- A provider function for showing the current progress of loading language servers
+---@param opts? table options passed to the stylize function
+---@return function # the function for outputting the LSP progress
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.lsp_progress() }
+-- @see astronvim.utils.status.utils.stylize
+function M.lsp_progress(opts)
+  local spinner = utils.get_spinner("LSPLoading", 1) or { "" }
+  return function()
+    local _, Lsp = next(astronvim.lsp.progress)
+    return status_utils.stylize(Lsp and (spinner[math.floor(luv.hrtime() / 12e7) % #spinner + 1] .. table.concat({
+      Lsp.title or "",
+      Lsp.message or "",
+      Lsp.percentage and "(" .. Lsp.percentage .. "%)" or "",
+    }, " ")), opts)
+  end
+end
+
+--- A provider function for showing the connected LSP client names
+---@param opts? table options for explanding null_ls clients, max width percentage, and options passed to the stylize function
+---@return function # the function for outputting the LSP client names
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.lsp_client_names({ expand_null_ls = true, truncate = 0.25 }) }
+-- @see astronvim.utils.status.utils.stylize
+function M.lsp_client_names(opts)
+  opts = extend_tbl({ expand_null_ls = true, truncate = 0.25 }, opts)
+  return function(self)
+    local buf_client_names = {}
+    for _, client in pairs(vim.lsp.get_active_clients { bufnr = self and self.bufnr or 0 }) do
+      if client.name == "null-ls" and opts.expand_null_ls then
+        local null_ls_sources = {}
+        for _, type in ipairs { "FORMATTING", "DIAGNOSTICS" } do
+          for _, source in ipairs(status_utils.null_ls_sources(vim.bo.filetype, type)) do
+            null_ls_sources[source] = true
+          end
+        end
+        vim.list_extend(buf_client_names, vim.tbl_keys(null_ls_sources))
+      else
+        table.insert(buf_client_names, client.name)
+      end
+    end
+    local str = table.concat(buf_client_names, ", ")
+    if type(opts.truncate) == "number" then
+      local max_width = math.floor(status_utils.width() * opts.truncate)
+      if #str > max_width then str = string.sub(str, 0, max_width) .. "…" end
+    end
+    return status_utils.stylize(str, opts)
+  end
+end
+
+--- A provider function for showing if treesitter is connected
+---@param opts? table options passed to the stylize function
+---@return function # function for outputting TS if treesitter is connected
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.treesitter_status() }
+-- @see astronvim.utils.status.utils.stylize
+function M.treesitter_status(opts)
+  return function() return status_utils.stylize(require("nvim-treesitter.parser").has_parser() and "TS" or "", opts) end
+end
+
+--- A provider function for displaying a single string
+---@param opts? table options passed to the stylize function
+---@return string # the stylized statusline string
+-- @usage local heirline_component = { provider = require("astronvim.utils.status").provider.str({ str = "Hello" }) }
+-- @see astronvim.utils.status.utils.stylize
+function M.str(opts)
+  opts = extend_tbl({ str = " " }, opts)
+  return status_utils.stylize(opts.str, opts)
+end
+
+return M
diff --git a/lua/astronvim/utils/status/utils.lua b/lua/astronvim/utils/status/utils.lua
new file mode 100644
index 0000000..6af81ca
--- /dev/null
+++ b/lua/astronvim/utils/status/utils.lua
@@ -0,0 +1,202 @@
+--- ### AstroNvim Status Utilities
+--
+-- Statusline related uitility functions
+--
+-- This module can be loaded with `local status_utils = require "astronvim.utils.status.utils"`
+--
+-- @module astronvim.utils.status.utils
+-- @copyright 2023
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local env = require "astronvim.utils.status.env"
+
+local utils = require "astronvim.utils"
+local extend_tbl = utils.extend_tbl
+local get_icon = utils.get_icon
+
+--- Convert a component parameter table to a table that can be used with the component builder
+---@param opts? table a table of provider options
+---@param provider? function|string a provider in `M.providers`
+---@return table|false # the provider table that can be used in `M.component.builder`
+function M.build_provider(opts, provider, _)
+  return opts
+      and {
+        provider = provider,
+        opts = opts,
+        condition = opts.condition,
+        on_click = opts.on_click,
+        update = opts.update,
+        hl = opts.hl,
+      }
+    or false
+end
+
+--- Convert key/value table of options to an array of providers for the component builder
+---@param opts table the table of options for the components
+---@param providers string[] an ordered list like array of providers that are configured in the options table
+---@param setup? function a function that takes provider options table, provider name, provider index and returns the setup provider table, optional, default is `M.build_provider`
+---@return table # the fully setup options table with the appropriately ordered providers
+function M.setup_providers(opts, providers, setup)
+  setup = setup or M.build_provider
+  for i, provider in ipairs(providers) do
+    opts[i] = setup(opts[provider], provider, i)
+  end
+  return opts
+end
+
+--- A utility function to get the width of the bar
+---@param is_winbar? boolean true if you want the width of the winbar, false if you want the statusline width
+---@return integer # the width of the specified bar
+function M.width(is_winbar)
+  return vim.o.laststatus == 3 and not is_winbar and vim.o.columns or vim.api.nvim_win_get_width(0)
+end
+
+--- Add left and/or right padding to a string
+---@param str string the string to add padding to
+---@param padding table a table of the format `{ left = 0, right = 0}` that defines the number of spaces to include to the left and the right of the string
+---@return string # the padded string
+function M.pad_string(str, padding)
+  padding = padding or {}
+  return str and str ~= "" and string.rep(" ", padding.left or 0) .. str .. string.rep(" ", padding.right or 0) or ""
+end
+
+local function escape(str) return str:gsub("%%", "%%%%") end
+
+--- A utility function to stylize a string with an icon from lspkind, separators, and left/right padding
+---@param str? string the string to stylize
+---@param opts? table options of `{ padding = { left = 0, right = 0 }, separator = { left = "|", right = "|" }, escape = true, show_empty = false, icon = { kind = "NONE", padding = { left = 0, right = 0 } } }`
+---@return string # the stylized string
+-- @usage local string = require("astronvim.utils.status").utils.stylize("Hello", { padding = { left = 1, right = 1 }, icon = { kind = "String" } })
+function M.stylize(str, opts)
+  opts = extend_tbl({
+    padding = { left = 0, right = 0 },
+    separator = { left = "", right = "" },
+    show_empty = false,
+    escape = true,
+    icon = { kind = "NONE", padding = { left = 0, right = 0 } },
+  }, opts)
+  local icon = M.pad_string(get_icon(opts.icon.kind), opts.icon.padding)
+  return str
+      and (str ~= "" or opts.show_empty)
+      and opts.separator.left .. M.pad_string(icon .. (opts.escape and escape(str) or str), opts.padding) .. opts.separator.right
+    or ""
+end
+
+--- Surround component with separator and color adjustment
+---@param separator string|string[] the separator index to use in `env.separators`
+---@param color function|string|table the color to use as the separator foreground/component background
+---@param component table the component to surround
+---@param condition boolean|function the condition for displaying the surrounded component
+---@return table # the new surrounded component
+function M.surround(separator, color, component, condition)
+  local function surround_color(self)
+    local colors = type(color) == "function" and color(self) or color
+    return type(colors) == "string" and { main = colors } or colors
+  end
+
+  separator = type(separator) == "string" and env.separators[separator] or separator
+  local surrounded = { condition = condition }
+  if separator[1] ~= "" then
+    table.insert(surrounded, {
+      provider = separator[1],
+      hl = function(self)
+        local s_color = surround_color(self)
+        if s_color then return { fg = s_color.main, bg = s_color.left } end
+      end,
+    })
+  end
+  table.insert(surrounded, {
+    hl = function(self)
+      local s_color = surround_color(self)
+      if s_color then return { bg = s_color.main } end
+    end,
+    extend_tbl(component, {}),
+  })
+  if separator[2] ~= "" then
+    table.insert(surrounded, {
+      provider = separator[2],
+      hl = function(self)
+        local s_color = surround_color(self)
+        if s_color then return { fg = s_color.main, bg = s_color.right } end
+      end,
+    })
+  end
+  return surrounded
+end
+
+--- Encode a position to a single value that can be decoded later
+---@param line integer line number of position
+---@param col integer column number of position
+---@param winnr integer a window number
+---@return integer the encoded position
+function M.encode_pos(line, col, winnr) return bit.bor(bit.lshift(line, 16), bit.lshift(col, 6), winnr) end
+
+--- Decode a previously encoded position to it's sub parts
+---@param c integer the encoded position
+---@return integer line, integer column, integer window
+function M.decode_pos(c) return bit.rshift(c, 16), bit.band(bit.rshift(c, 6), 1023), bit.band(c, 63) end
+
+--- Get a list of registered null-ls providers for a given filetype
+---@param filetype string the filetype to search null-ls for
+---@return table # a table of null-ls sources
+function M.null_ls_providers(filetype)
+  local registered = {}
+  -- try to load null-ls
+  local sources_avail, sources = pcall(require, "null-ls.sources")
+  if sources_avail then
+    -- get the available sources of a given filetype
+    for _, source in ipairs(sources.get_available(filetype)) do
+      -- get each source name
+      for method in pairs(source.methods) do
+        registered[method] = registered[method] or {}
+        table.insert(registered[method], source.name)
+      end
+    end
+  end
+  -- return the found null-ls sources
+  return registered
+end
+
+--- Get the null-ls sources for a given null-ls method
+---@param filetype string the filetype to search null-ls for
+---@param method string the null-ls method (check null-ls documentation for available methods)
+---@return string[] # the available sources for the given filetype and method
+function M.null_ls_sources(filetype, method)
+  local methods_avail, methods = pcall(require, "null-ls.methods")
+  return methods_avail and M.null_ls_providers(filetype)[methods.internal[method]] or {}
+end
+
+--- A helper function for decoding statuscolumn click events with mouse click pressed, modifier keys, as well as which signcolumn sign was clicked if any
+---@param self any the self parameter from Heirline component on_click.callback function call
+---@param minwid any the minwid parameter from Heirline component on_click.callback function call
+---@param clicks any the clicks parameter from Heirline component on_click.callback function call
+---@param button any the button parameter from Heirline component on_click.callback function call
+---@param mods any the button parameter from Heirline component on_click.callback function call
+---@return table # the argument table with the decoded mouse information and signcolumn signs information
+-- @usage local heirline_component = { on_click = { callback = function(...) local args = require("astronvim.utils.status").utils.statuscolumn_clickargs(...) end } }
+function M.statuscolumn_clickargs(self, minwid, clicks, button, mods)
+  local args = {
+    minwid = minwid,
+    clicks = clicks,
+    button = button,
+    mods = mods,
+    mousepos = vim.fn.getmousepos(),
+  }
+  if not self.signs then self.signs = {} end
+  args.char = vim.fn.screenstring(args.mousepos.screenrow, args.mousepos.screencol)
+  if args.char == " " then args.char = vim.fn.screenstring(args.mousepos.screenrow, args.mousepos.screencol - 1) end
+  args.sign = self.signs[args.char]
+  if not args.sign then -- update signs if not found on first click
+    for _, sign_def in ipairs(vim.fn.sign_getdefined()) do
+      if sign_def.text then self.signs[sign_def.text:gsub("%s", "")] = sign_def end
+    end
+    args.sign = self.signs[args.char]
+  end
+  vim.api.nvim_set_current_win(args.mousepos.winid)
+  vim.api.nvim_win_set_cursor(0, { args.mousepos.line, 0 })
+  return args
+end
+
+return M
diff --git a/lua/astronvim/utils/ui.lua b/lua/astronvim/utils/ui.lua
new file mode 100644
index 0000000..3bf3cc2
--- /dev/null
+++ b/lua/astronvim/utils/ui.lua
@@ -0,0 +1,271 @@
+--- ### AstroNvim UI Options
+--
+--  Utility functions for easy UI toggles.
+--
+-- This module can be loaded with `local ui = require("astronvim.utils.ui")`
+--
+-- @module astronvim.utils.ui
+-- @see astronvim.utils
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local M = {}
+
+local function bool2str(bool) return bool and "on" or "off" end
+local function ui_notify(silent, ...) return not silent and require("astronvim.utils").notify(...) end
+
+--- Toggle notifications for UI toggles
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_ui_notifications(silent) -- TODO: rename to toggle_notifications in AstroNvim v4
+  vim.g.ui_notifications_enabled = not vim.g.ui_notifications_enabled
+  ui_notify(silent, string.format("Notifications %s", bool2str(vim.g.ui_notifications_enabled)))
+end
+
+--- Toggle autopairs
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_autopairs(silent)
+  local ok, autopairs = pcall(require, "nvim-autopairs")
+  if ok then
+    if autopairs.state.disabled then
+      autopairs.enable()
+    else
+      autopairs.disable()
+    end
+    vim.g.autopairs_enabled = autopairs.state.disabled
+    ui_notify(silent, string.format("autopairs %s", bool2str(not autopairs.state.disabled)))
+  else
+    ui_notify(silent, "autopairs not available")
+  end
+end
+
+--- Toggle diagnostics
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_diagnostics(silent)
+  vim.g.diagnostics_mode = (vim.g.diagnostics_mode - 1) % 4
+  vim.diagnostic.config(require("astronvim.utils.lsp").diagnostics[vim.g.diagnostics_mode])
+  if vim.g.diagnostics_mode == 0 then
+    ui_notify(silent, "diagnostics off")
+  elseif vim.g.diagnostics_mode == 1 then
+    ui_notify(silent, "only status diagnostics")
+  elseif vim.g.diagnostics_mode == 2 then
+    ui_notify(silent, "virtual text off")
+  else
+    ui_notify(silent, "all diagnostics on")
+  end
+end
+
+--- Toggle background="dark"|"light"
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_background(silent)
+  vim.go.background = vim.go.background == "light" and "dark" or "light"
+  ui_notify(silent, string.format("background=%s", vim.go.background))
+end
+
+--- Toggle cmp entrirely
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_cmp(silent)
+  vim.g.cmp_enabled = not vim.g.cmp_enabled
+  local ok, _ = pcall(require, "cmp")
+  ui_notify(silent, ok and string.format("completion %s", bool2str(vim.g.cmp_enabled)) or "completion not available")
+end
+
+--- Toggle auto format
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_autoformat(silent)
+  vim.g.autoformat_enabled = not vim.g.autoformat_enabled
+  ui_notify(silent, string.format("Global autoformatting %s", bool2str(vim.g.autoformat_enabled)))
+end
+
+--- Toggle buffer local auto format
+---@param bufnr? number the buffer to toggle syntax on
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_buffer_autoformat(bufnr, silent)
+  bufnr = bufnr or 0
+  local old_val = vim.b[bufnr].autoformat_enabled
+  if old_val == nil then old_val = vim.g.autoformat_enabled end
+  vim.b[bufnr].autoformat_enabled = not old_val
+  ui_notify(silent, string.format("Buffer autoformatting %s", bool2str(vim.b[bufnr].autoformat_enabled)))
+end
+
+--- Toggle buffer semantic token highlighting for all language servers that support it
+---@param bufnr? number the buffer to toggle the clients on
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_buffer_semantic_tokens(bufnr, silent)
+  bufnr = bufnr or 0
+  vim.b[bufnr].semantic_tokens_enabled = not vim.b[bufnr].semantic_tokens_enabled
+  local toggled = false
+  for _, client in ipairs(vim.lsp.get_active_clients { bufnr = bufnr }) do
+    if client.server_capabilities.semanticTokensProvider then
+      vim.lsp.semantic_tokens[vim.b[bufnr].semantic_tokens_enabled and "start" or "stop"](bufnr, client.id)
+      toggled = true
+    end
+  end
+  ui_notify(
+    not toggled or silent,
+    string.format("Buffer lsp semantic highlighting %s", bool2str(vim.b[bufnr].semantic_tokens_enabled))
+  )
+end
+
+--- Toggle buffer LSP inlay hints
+---@param bufnr? number the buffer to toggle the clients on
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_buffer_inlay_hints(bufnr, silent)
+  bufnr = bufnr or 0
+  vim.b[bufnr].inlay_hints_enabled = not vim.b[bufnr].inlay_hints_enabled
+  -- TODO: remove check after dropping support for Neovim v0.9
+  if vim.lsp.inlay_hint then
+    vim.lsp.inlay_hint.enable(bufnr, vim.b[bufnr].inlay_hints_enabled)
+    ui_notify(silent, string.format("Inlay hints %s", bool2str(vim.b[bufnr].inlay_hints_enabled)))
+  end
+end
+
+--- Toggle codelens
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_codelens(silent)
+  vim.g.codelens_enabled = not vim.g.codelens_enabled
+  if not vim.g.codelens_enabled then vim.lsp.codelens.clear() end
+  ui_notify(silent, string.format("CodeLens %s", bool2str(vim.g.codelens_enabled)))
+end
+
+--- Toggle showtabline=2|0
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_tabline(silent)
+  vim.opt.showtabline = vim.opt.showtabline:get() == 0 and 2 or 0
+  ui_notify(silent, string.format("tabline %s", bool2str(vim.opt.showtabline:get() == 2)))
+end
+
+--- Toggle conceal=2|0
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_conceal(silent)
+  vim.opt.conceallevel = vim.opt.conceallevel:get() == 0 and 2 or 0
+  ui_notify(silent, string.format("conceal %s", bool2str(vim.opt.conceallevel:get() == 2)))
+end
+
+--- Toggle laststatus=3|2|0
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_statusline(silent)
+  local laststatus = vim.opt.laststatus:get()
+  local status
+  if laststatus == 0 then
+    vim.opt.laststatus = 2
+    status = "local"
+  elseif laststatus == 2 then
+    vim.opt.laststatus = 3
+    status = "global"
+  elseif laststatus == 3 then
+    vim.opt.laststatus = 0
+    status = "off"
+  end
+  ui_notify(silent, string.format("statusline %s", status))
+end
+
+--- Toggle signcolumn="auto"|"no"
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_signcolumn(silent)
+  if vim.wo.signcolumn == "no" then
+    vim.wo.signcolumn = "yes"
+  elseif vim.wo.signcolumn == "yes" then
+    vim.wo.signcolumn = "auto"
+  else
+    vim.wo.signcolumn = "no"
+  end
+  ui_notify(silent, string.format("signcolumn=%s", vim.wo.signcolumn))
+end
+
+--- Set the indent and tab related numbers
+---@param silent? boolean if true then don't sent a notification
+function M.set_indent(silent)
+  local input_avail, input = pcall(vim.fn.input, "Set indent value (>0 expandtab, <=0 noexpandtab): ")
+  if input_avail then
+    local indent = tonumber(input)
+    if not indent or indent == 0 then return end
+    vim.bo.expandtab = (indent > 0) -- local to buffer
+    indent = math.abs(indent)
+    vim.bo.tabstop = indent -- local to buffer
+    vim.bo.softtabstop = indent -- local to buffer
+    vim.bo.shiftwidth = indent -- local to buffer
+    ui_notify(silent, string.format("indent=%d %s", indent, vim.bo.expandtab and "expandtab" or "noexpandtab"))
+  end
+end
+
+--- Change the number display modes
+---@param silent? boolean if true then don't sent a notification
+function M.change_number(silent)
+  local number = vim.wo.number -- local to window
+  local relativenumber = vim.wo.relativenumber -- local to window
+  if not number and not relativenumber then
+    vim.wo.number = true
+  elseif number and not relativenumber then
+    vim.wo.relativenumber = true
+  elseif number and relativenumber then
+    vim.wo.number = false
+  else -- not number and relativenumber
+    vim.wo.relativenumber = false
+  end
+  ui_notify(
+    silent,
+    string.format("number %s, relativenumber %s", bool2str(vim.wo.number), bool2str(vim.wo.relativenumber))
+  )
+end
+
+--- Toggle spell
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_spell(silent)
+  vim.wo.spell = not vim.wo.spell -- local to window
+  ui_notify(silent, string.format("spell %s", bool2str(vim.wo.spell)))
+end
+
+--- Toggle paste
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_paste(silent)
+  vim.opt.paste = not vim.opt.paste:get() -- local to window
+  ui_notify(silent, string.format("paste %s", bool2str(vim.opt.paste:get())))
+end
+
+--- Toggle wrap
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_wrap(silent)
+  vim.wo.wrap = not vim.wo.wrap -- local to window
+  ui_notify(silent, string.format("wrap %s", bool2str(vim.wo.wrap)))
+end
+
+--- Toggle syntax highlighting and treesitter
+---@param bufnr? number the buffer to toggle syntax on
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_buffer_syntax(bufnr, silent)
+  -- HACK: this should just be `bufnr = bufnr or 0` but it looks like `vim.treesitter.stop` has a bug with `0` being current
+  bufnr = (bufnr and bufnr ~= 0) and bufnr or vim.api.nvim_win_get_buf(0)
+  local ts_avail, parsers = pcall(require, "nvim-treesitter.parsers")
+  if vim.bo[bufnr].syntax == "off" then
+    if ts_avail and parsers.has_parser() then vim.treesitter.start(bufnr) end
+    vim.bo[bufnr].syntax = "on"
+    if not vim.b[bufnr].semantic_tokens_enabled then M.toggle_buffer_semantic_tokens(bufnr, true) end
+  else
+    if ts_avail and parsers.has_parser() then vim.treesitter.stop(bufnr) end
+    vim.bo[bufnr].syntax = "off"
+    if vim.b[bufnr].semantic_tokens_enabled then M.toggle_buffer_semantic_tokens(bufnr, true) end
+  end
+  ui_notify(silent, string.format("syntax %s", vim.bo[bufnr].syntax))
+end
+-- TODO: remove old function name in AstroNvim v4
+M.toggle_syntax = M.toggle_buffer_syntax
+
+--- Toggle URL/URI syntax highlighting rules
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_url_match(silent)
+  vim.g.highlighturl_enabled = not vim.g.highlighturl_enabled
+  require("astronvim.utils").set_url_match()
+  ui_notify(silent, string.format("URL highlighting %s", bool2str(vim.g.highlighturl_enabled)))
+end
+
+local last_active_foldcolumn
+--- Toggle foldcolumn=0|1
+---@param silent? boolean if true then don't sent a notification
+function M.toggle_foldcolumn(silent)
+  local curr_foldcolumn = vim.wo.foldcolumn
+  if curr_foldcolumn ~= "0" then last_active_foldcolumn = curr_foldcolumn end
+  vim.wo.foldcolumn = curr_foldcolumn == "0" and (last_active_foldcolumn or "1") or "0"
+  ui_notify(silent, string.format("foldcolumn=%s", vim.wo.foldcolumn))
+end
+
+return M
diff --git a/lua/astronvim/utils/updater.lua b/lua/astronvim/utils/updater.lua
new file mode 100644
index 0000000..826ef20
--- /dev/null
+++ b/lua/astronvim/utils/updater.lua
@@ -0,0 +1,340 @@
+--- ### AstroNvim Updater
+--
+-- AstroNvim Updater utilities to use within AstroNvim and user configurations.
+--
+-- This module can also loaded with `local updater = require("astronvim.utils.updater")`
+--
+-- @module astronvim.utils.updater
+-- @see astronvim.utils
+-- @copyright 2022
+-- @license GNU General Public License v3.0
+
+local git = require "astronvim.utils.git"
+
+local M = {}
+
+local utils = require "astronvim.utils"
+local notify = utils.notify
+
+local function echo(messages)
+  -- if no parameter provided, echo a new line
+  messages = messages or { { "\n" } }
+  if type(messages) == "table" then vim.api.nvim_echo(messages, false, {}) end
+end
+
+local function confirm_prompt(messages, type)
+  return vim.fn.confirm(messages, "&Yes\n&No", (type == "Error" or type == "Warning") and 2 or 1, type or "Question")
+    == 1
+end
+
+--- Helper function to generate AstroNvim snapshots (For internal use only)
+---@param write? boolean Whether or not to write to the snapshot file (default: false)
+---@return table # The plugin specification table of the snapshot
+function M.generate_snapshot(write)
+  local file
+  local prev_snapshot = require(astronvim.updater.snapshot.module)
+  for _, plugin in ipairs(prev_snapshot) do
+    prev_snapshot[plugin[1]] = plugin
+  end
+  local plugins = assert(require("lazy").plugins())
+  table.sort(plugins, function(l, r) return l[1] < r[1] end)
+  local function git_commit(dir)
+    local commit = assert(utils.cmd({ "git", "-C", dir, "rev-parse", "HEAD" }, false))
+    if commit then return vim.trim(commit) end
+  end
+  if write == true then
+    file = assert(io.open(astronvim.updater.snapshot.path, "w"))
+    file:write "return {\n"
+  end
+  local snapshot = vim.tbl_map(function(plugin)
+    plugin = { plugin[1], commit = git_commit(plugin.dir), version = plugin.version }
+    if prev_snapshot[plugin[1]] and prev_snapshot[plugin[1]].version then
+      plugin.version = prev_snapshot[plugin[1]].version
+    end
+    if file then
+      file:write(("  { %q, "):format(plugin[1]))
+      if plugin.version then
+        file:write(("version = %q"):format(plugin.version))
+      else
+        file:write(
+          ( -- add hard code for neovim 0.8 support
+            plugin[1] == "nvim-treesitter/nvim-treesitter"
+              and 'vim.fn.has "nvim-0.9" ~= 1 and "63260da18bf273c76b8e2ea0db84eb901cab49ce" or %q'
+            or "commit = %q"
+          ):format(plugin.commit)
+        )
+      end
+      file:write ", optional = true },\n"
+    end
+    return plugin
+  end, plugins)
+  if file then
+    file:write "}\n"
+    file:close()
+  end
+  return snapshot
+end
+
+--- Get the current AstroNvim version
+---@param quiet? boolean Whether to quietly execute or send a notification
+---@return string # The current AstroNvim version string
+function M.version(quiet)
+  local version = astronvim.install.version or git.current_version(false) or "unknown"
+  if astronvim.updater.options.channel ~= "stable" then version = ("nightly (%s)"):format(version) end
+  if version and not quiet then notify(("Version: *%s*"):format(version)) end
+  return version
+end
+
+--- Get the full AstroNvim changelog
+---@param quiet? boolean Whether to quietly execute or display the changelog
+---@return table # The current AstroNvim changelog table of commit messages
+function M.changelog(quiet)
+  local summary = {}
+  vim.list_extend(summary, git.pretty_changelog(git.get_commit_range()))
+  if not quiet then echo(summary) end
+  return summary
+end
+
+--- Attempt an update of AstroNvim
+---@param target string The target if checking out a specific tag or commit or nil if just pulling
+local function attempt_update(target, opts)
+  -- if updating to a new stable version or a specific commit checkout the provided target
+  if opts.channel == "stable" or opts.commit then
+    return git.checkout(target, false)
+  -- if no target, pull the latest
+  else
+    return git.pull(false)
+  end
+end
+
+--- Cancelled update message
+local cancelled_message = { { "Update cancelled", "WarningMsg" } }
+
+--- Sync Lazy and then update Mason
+function M.update_packages()
+  require("lazy").sync { wait = true }
+  require("astronvim.utils.mason").update_all()
+end
+
+--- Create a table of options for the currently installed AstroNvim version
+---@param write? boolean Whether or not to write to the rollback file (default: false)
+---@return table # The table of updater options
+function M.create_rollback(write)
+  local snapshot = { branch = git.current_branch(), commit = git.local_head() }
+  if snapshot.branch == "HEAD" then snapshot.branch = "main" end
+  snapshot.remote = git.branch_remote(snapshot.branch, false) or "origin"
+  snapshot.remotes = { [snapshot.remote] = git.remote_url(snapshot.remote) }
+
+  if write == true then
+    local file = assert(io.open(astronvim.updater.rollback_file, "w"))
+    file:write("return " .. vim.inspect(snapshot, { newline = " ", indent = "" }))
+    file:close()
+  end
+
+  return snapshot
+end
+
+--- AstroNvim's rollback to saved previous version function
+function M.rollback()
+  local rollback_avail, rollback_opts = pcall(dofile, astronvim.updater.rollback_file)
+  if not rollback_avail then
+    notify("No rollback file available", vim.log.levels.ERROR)
+    return
+  end
+  M.update(rollback_opts)
+end
+
+--- Check if an update is available
+---@param opts? table the settings to use for checking for an update
+---@return table|boolean? # The information of an available update (`{ source = string, target = string }`), false if no update is available, or nil if there is an error
+function M.update_available(opts)
+  if not opts then opts = astronvim.updater.options end
+  opts = require("astronvim.utils").extend_tbl({ remote = "origin" }, opts)
+  -- if the git command is not available, then throw an error
+  if not git.available() then
+    notify(
+      "`git` command is not available, please verify it is accessible in a command line. This may be an issue with your `PATH`",
+      vim.log.levels.ERROR
+    )
+    return
+  end
+
+  -- if installed with an external package manager, disable the internal updater
+  if not git.is_repo() then
+    notify("Updater not available for non-git installations", vim.log.levels.ERROR)
+    return
+  end
+  -- set up any remotes defined by the user if they do not exist
+  for remote, entry in pairs(opts.remotes and opts.remotes or {}) do
+    local url = git.parse_remote_url(entry)
+    local current_url = git.remote_url(remote, false)
+    local check_needed = false
+    if not current_url then
+      git.remote_add(remote, url)
+      check_needed = true
+    elseif
+      current_url ~= url
+      and confirm_prompt(
+        ("Remote %s is currently: %s\n" .. "Would you like us to set it to %s ?"):format(remote, current_url, url)
+      )
+    then
+      git.remote_update(remote, url)
+      check_needed = true
+    end
+    if check_needed and git.remote_url(remote, false) ~= url then
+      vim.api.nvim_err_writeln("Error setting up remote " .. remote .. " to " .. url)
+      return
+    end
+  end
+  local is_stable = opts.channel == "stable"
+  if is_stable then
+    opts.branch = "main"
+  elseif not opts.branch then
+    opts.branch = "nightly"
+  end
+  -- setup branch if missing
+  if not git.ref_verify(opts.remote .. "/" .. opts.branch, false) then
+    git.remote_set_branches(opts.remote, opts.branch, false)
+  end
+  -- fetch the latest remote
+  if not git.fetch(opts.remote) then
+    vim.api.nvim_err_writeln("Error fetching remote: " .. opts.remote)
+    return
+  end
+  -- switch to the necessary branch only if not on the stable channel
+  if not is_stable then
+    local local_branch = (opts.remote == "origin" and "" or (opts.remote .. "_")) .. opts.branch
+    if git.current_branch() ~= local_branch then
+      echo {
+        { "Switching to branch: " },
+        { opts.remote .. "/" .. opts.branch .. "\n\n", "String" },
+      }
+      if not git.checkout(local_branch, false) then
+        git.checkout("-b " .. local_branch .. " " .. opts.remote .. "/" .. opts.branch, false)
+      end
+    end
+    -- check if the branch was switched to successfully
+    if git.current_branch() ~= local_branch then
+      vim.api.nvim_err_writeln("Error checking out branch: " .. opts.remote .. "/" .. opts.branch)
+      return
+    end
+  end
+  local update = { source = git.local_head() }
+  if is_stable then -- if stable get tag commit
+    local version_search = opts.version or "latest"
+    update.version = git.latest_version(git.get_versions(version_search))
+    if not update.version then -- continue only if stable version is found
+      vim.api.nvim_err_writeln("Error finding version: " .. version_search)
+      return
+    end
+    update.target = git.tag_commit(update.version)
+  elseif opts.commit then -- if commit specified use it
+    update.target = git.branch_contains(opts.remote, opts.branch, opts.commit) and opts.commit or nil
+  else -- get most recent commit
+    update.target = git.remote_head(opts.remote, opts.branch)
+  end
+
+  if not update.source or not update.target then -- continue if current and target commits were found
+    vim.api.nvim_err_writeln "Error checking for updates"
+    return
+  elseif update.source ~= update.target then
+    -- update available
+    return update
+  else
+    return false
+  end
+end
+
+--- AstroNvim's updater function
+---@param opts? table the settings to use for the update
+function M.update(opts)
+  if not opts then opts = astronvim.updater.options end
+  opts = require("astronvim.utils").extend_tbl(
+    { remote = "origin", show_changelog = true, sync_plugins = true, auto_quit = false },
+    opts
+  )
+  local available_update = M.update_available(opts)
+  if available_update == nil then
+    return
+  elseif not available_update then -- continue if current and target commits were found
+    notify "No updates available"
+  elseif -- prompt user if they want to accept update
+    not opts.skip_prompts
+    and not confirm_prompt(
+      ("Update available to %s\nUpdating requires a restart, continue?"):format(
+        available_update.version or available_update.target
+      )
+    )
+  then
+    echo(cancelled_message)
+    return
+  else -- perform update
+    local source, target = available_update.source, available_update.target
+    M.create_rollback(true) -- create rollback file before updating
+    -- calculate and print the changelog
+    local changelog = git.get_commit_range(source, target)
+    local breaking = git.breaking_changes(changelog)
+    if #breaking > 0 then
+      echo {
+        { "Cannot update to AstroNvim v4 due to changes in the installation and management\n", "ErrorMsg" },
+        { "Please check the documentation for update instructions: ", "Title" },
+        { "https://docs.astronvim.com", "String" },
+      }
+      return
+    end
+    -- attempt an update
+    local updated = attempt_update(target, opts)
+    -- check for local file conflicts and prompt user to continue or abort
+    if
+      not updated
+      and not opts.skip_prompts
+      and not confirm_prompt(
+        "Unable to pull due to local modifications to base files.\nReset local files and continue?",
+        "Error"
+      )
+    then
+      echo(cancelled_message)
+      return
+    -- if continued and there were errors reset the base config and attempt another update
+    elseif not updated then
+      git.hard_reset(source)
+      updated = attempt_update(target, opts)
+    end
+    -- if update was unsuccessful throw an error
+    if not updated then
+      vim.api.nvim_err_writeln "Error occurred performing update"
+      return
+    end
+    -- print a summary of the update with the changelog
+    local summary = {
+      { "AstroNvim updated successfully to ", "Title" },
+      { git.current_version(), "String" },
+      { "!\n", "Title" },
+      {
+        opts.auto_quit and "AstroNvim will now update plugins and quit.\n\n"
+          or "After plugins update, please restart.\n\n",
+        "WarningMsg",
+      },
+    }
+    if opts.show_changelog and #changelog > 0 then
+      vim.list_extend(summary, { { "Changelog:\n", "Title" } })
+      vim.list_extend(summary, git.pretty_changelog(changelog))
+    end
+    echo(summary)
+
+    -- if the user wants to auto quit, create an autocommand to quit AstroNvim on the update completing
+    if opts.auto_quit then
+      vim.api.nvim_create_autocmd("User", {
+        desc = "Auto quit AstroNvim after update completes",
+        pattern = "AstroUpdateComplete",
+        command = "quitall",
+      })
+    end
+
+    require("lazy.core.plugin").load() -- force immediate reload of lazy
+    if opts.sync_plugins then require("lazy").sync { wait = true } end
+    utils.event "UpdateComplete"
+  end
+end
+
+return M
diff --git a/lua/astronvim/lazy_snapshot.lua b/lua/lazy_snapshot.lua
similarity index 58%
rename from lua/astronvim/lazy_snapshot.lua
rename to lua/lazy_snapshot.lua
index 9b9c895..1c795e8 100644
--- a/lua/astronvim/lazy_snapshot.lua
+++ b/lua/lazy_snapshot.lua
@@ -1,59 +1,54 @@
 return {
-  { "AstroNvim/astrocore", version = "^1.1.1", optional = true },
-  { "AstroNvim/astrolsp", version = "^1", optional = true },
   { "AstroNvim/astrotheme", version = "^3", optional = true },
-  { "AstroNvim/astroui", version = "^1", optional = true },
-  { "JoosepAlviste/nvim-ts-context-commentstring", commit = "a6382f744f584bbf71d0a563af789af7190aabda", optional = true },
+  { "JoosepAlviste/nvim-ts-context-commentstring", commit = "6c30f3c8915d7b31c3decdfe6c7672432da1809d", optional = true },
   { "L3MON4D3/LuaSnip", version = "^2", optional = true },
-  { "MunifTanjim/nui.nvim", version = "^0.3", optional = true },
+  { "MunifTanjim/nui.nvim", version = "^0.2", optional = true },
   { "NMAC427/guess-indent.nvim", commit = "b8ae749fce17aa4c267eec80a6984130b94f80b2", optional = true },
   { "NvChad/nvim-colorizer.lua", commit = "85855b38011114929f4058efc97af1059ab3e41d", optional = true },
-  { "RRethy/vim-illuminate", commit = "e522e0dd742a83506db0a72e1ced68c9c130f185", optional = true },
+  { "Shatur/neovim-session-manager", commit = "d8e1ba3bbcf3fdc6a887bcfbd94c48ae4707b457", optional = true },
   { "akinsho/toggleterm.nvim", version = "^2", optional = true },
-  { "echasnovski/mini.bufremove", version = "^0.12", optional = true },
+  { "b0o/SchemaStore.nvim", commit = "adaca44ad56bd74ae0e4e500320a7dd6f216650a", optional = true },
+  { "echasnovski/mini.bufremove", commit = "931a3bb514147d9e812767275c4beba6b779b1d3", optional = true },
   { "folke/lazy.nvim", version = "^10", optional = true },
   { "folke/neoconf.nvim", version = "^1", optional = true },
   { "folke/neodev.nvim", version = "^2", optional = true },
-  { "folke/todo-comments.nvim", version = "^1", optional = true },
   { "folke/which-key.nvim", version = "^1", optional = true },
-  { "goolord/alpha-nvim", commit = "41283fb402713fc8b327e60907f74e46166f4cfd", optional = true },
+  { "goolord/alpha-nvim", commit = "1356b9ef31b985d541d94314f2cf73c61124bf1d", optional = true },
   { "hrsh7th/cmp-buffer", commit = "3022dbc9166796b644a841a02de8dd1cc1d311fa", optional = true },
   { "hrsh7th/cmp-nvim-lsp", commit = "5af77f54de1b16c34b23cba810150689a3a90312", optional = true },
   { "hrsh7th/cmp-path", commit = "91ff86cd9c29299a64f968ebb45846c485725f23", optional = true },
-  { "hrsh7th/nvim-cmp", commit = "8f3c541407e691af6163e2447f3af1bd6e17f9a3", optional = true },
+  { "hrsh7th/nvim-cmp", commit = "04e0ca376d6abdbfc8b52180f8ea236cbfddf782", optional = true },
   { "jay-babu/mason-null-ls.nvim", version = "^2", optional = true },
   { "jay-babu/mason-nvim-dap.nvim", version = "^2", optional = true },
+  { "jose-elias-alvarez/null-ls.nvim", commit = "0010ea927ab7c09ef0ce9bf28c2b573fc302f5a7", optional = true },
   { "kevinhwang91/nvim-ufo", version = "^1", optional = true },
   { "kevinhwang91/promise-async", version = "^1", optional = true },
-  { "lewis6991/gitsigns.nvim", version = "^0.8", optional = true },
+  { "lewis6991/gitsigns.nvim", version = "^0.7", optional = true },
   { "lukas-reineke/indent-blankline.nvim", version = "^3", optional = true },
   { "max397574/better-escape.nvim", commit = "7e86edafb8c7e73699e0320f225464a298b96d12", optional = true },
   { "mfussenegger/nvim-dap", version = "^0.7", optional = true },
   { "mrjones2014/smart-splits.nvim", version = "^1", optional = true },
-  { "neovim/nvim-lspconfig", commit = "aa5f4f4ee10b2688fb37fa46215672441d5cd5d9", optional = true },
+  { "neovim/nvim-lspconfig", commit = "aa199c5bbdbb7fd28b56212a89206f13db02799e", optional = true },
   { "numToStr/Comment.nvim", commit = "0236521ea582747b58869cb72f70ccfa967d2e89", optional = true },
   { "nvim-lua/plenary.nvim", version = "^0.1", optional = true },
   { "nvim-neo-tree/neo-tree.nvim", version = "^3", optional = true },
-  { "nvim-neotest/nvim-nio", version = "^1", optional = true },
-  { "nvim-telescope/telescope-fzf-native.nvim", commit = "9ef21b2e6bb6ebeaf349a0781745549bbb870d27", optional = true },
+  { "nvim-telescope/telescope-fzf-native.nvim", commit = "6c921ca12321edaa773e324ef64ea301a1d0da62", optional = true },
   { "nvim-telescope/telescope.nvim", version = "^0.1", optional = true },
-  { "nvim-tree/nvim-web-devicons", commit = "794bba734ec95eaff9bb82fbd112473be2087283", optional = true },
-  { "nvim-treesitter/nvim-treesitter", commit = "99d3e799b46f5c2a1fc0d7a42d7ab452de48c067", optional = true },
-  { "nvim-treesitter/nvim-treesitter-textobjects", commit = "23b820146956b3b681c19e10d3a8bc0cbd9a1d4c", optional = true },
-  { "nvimtools/none-ls.nvim", commit = "f5632db2491fbe02b54f1a321a98548a8ba2bd15", optional = true },
+  { "nvim-tree/nvim-web-devicons", commit = "14ac5887110b06b89a96881d534230dac3ed134d", optional = true },
+  { "nvim-treesitter/nvim-treesitter", vim.fn.has "nvim-0.9" ~= 1 and "63260da18bf273c76b8e2ea0db84eb901cab49ce" or "977d94975d352ae4a37ac99605876cbe41707c81", optional = true },
+  { "nvim-treesitter/nvim-treesitter-textobjects", commit = "7f00d94543f1fd37cab2afa2e9a6cd54e1c6b9ef", optional = true },
   { "onsails/lspkind.nvim", commit = "1735dd5a5054c1fb7feaf8e8658dbab925f4f0cf", optional = true },
-  { "rafamadriz/friendly-snippets", commit = "d5f74ce4dfdd82848f3f4eac65fe6e29ac5df4c2", optional = true },
+  { "rafamadriz/friendly-snippets", commit = "dbd45e9ba76d535e4cba88afa1b7aa43bb765336", optional = true },
   { "rcarriga/cmp-dap", commit = "ea92773e84c0ad3288c3bc5e452ac91559669087", optional = true },
-  { "rcarriga/nvim-dap-ui", commit = "5934302d63d1ede12c0b22b6f23518bb183fc972", optional = true },
+  { "rcarriga/nvim-dap-ui", version = "^3", optional = true },
   { "rcarriga/nvim-notify", version = "^3", optional = true },
   { "rebelot/heirline.nvim", version = "^1", optional = true },
   { "s1n7ax/nvim-window-picker", version = "^2", optional = true },
   { "saadparwaiz1/cmp_luasnip", commit = "05a9ab28b53f71d1aece421ef32fee2cb857a843", optional = true },
   { "stevearc/aerial.nvim", version = "^1.5", optional = true },
   { "stevearc/dressing.nvim", version = "^2", optional = true },
-  { "stevearc/resession.nvim", version = "^1", optional = true },
   { "williamboman/mason-lspconfig.nvim", version = "^1", optional = true },
   { "williamboman/mason.nvim", version = "^1", optional = true },
-  { "windwp/nvim-autopairs", commit = "4f41e5940bc0443fdbe5f995e2a596847215cd2a", optional = true },
+  { "windwp/nvim-autopairs", commit = "90f824d37c0cb079d2764927e73af77faa9ba0ef", optional = true },
   { "windwp/nvim-ts-autotag", commit = "531f48334c422222aebc888fd36e7d109cb354cd", optional = true },
 }
diff --git a/lua/plugins/alpha.lua b/lua/plugins/alpha.lua
new file mode 100644
index 0000000..dcb2938
--- /dev/null
+++ b/lua/plugins/alpha.lua
@@ -0,0 +1,44 @@
+return {
+  "goolord/alpha-nvim",
+  cmd = "Alpha",
+  opts = function()
+    local dashboard = require "alpha.themes.dashboard"
+    dashboard.section.header.val = {
+      " █████  ███████ ████████ ██████   ██████",
+      "██   ██ ██         ██    ██   ██ ██    ██",
+      "███████ ███████    ██    ██████  ██    ██",
+      "██   ██      ██    ██    ██   ██ ██    ██",
+      "██   ██ ███████    ██    ██   ██  ██████",
+      " ",
+      "    ███    ██ ██    ██ ██ ███    ███",
+      "    ████   ██ ██    ██ ██ ████  ████",
+      "    ██ ██  ██ ██    ██ ██ ██ ████ ██",
+      "    ██  ██ ██  ██  ██  ██ ██  ██  ██",
+      "    ██   ████   ████   ██ ██      ██",
+    }
+    dashboard.section.header.opts.hl = "DashboardHeader"
+    dashboard.section.footer.opts.hl = "DashboardFooter"
+
+    local button, get_icon = require("astronvim.utils").alpha_button, require("astronvim.utils").get_icon
+    dashboard.section.buttons.val = {
+      button("LDR n  ", get_icon("FileNew", 2, true) .. "New File  "),
+      button("LDR f f", get_icon("Search", 2, true) .. "Find File  "),
+      button("LDR f o", get_icon("DefaultFile", 2, true) .. "Recents  "),
+      button("LDR f w", get_icon("WordFile", 2, true) .. "Find Word  "),
+      button("LDR f '", get_icon("Bookmarks", 2, true) .. "Bookmarks  "),
+      button("LDR r  ", get_icon("Refresh", 2, true) .. "Sessions  "),
+    }
+
+    dashboard.config.layout = {
+      { type = "padding", val = vim.fn.max { 1, vim.fn.floor(vim.fn.winheight(0) * 0.2) } },
+      dashboard.section.header,
+      { type = "padding", val = 2 },
+      dashboard.section.buttons,
+      { type = "padding", val = 2 },
+      dashboard.section.footer,
+    }
+    dashboard.config.opts.noautocmd = true
+    return dashboard
+  end,
+  config = require "plugins.configs.alpha",
+}
diff --git a/lua/plugins/cmp.lua b/lua/plugins/cmp.lua
new file mode 100644
index 0000000..6d10526
--- /dev/null
+++ b/lua/plugins/cmp.lua
@@ -0,0 +1,117 @@
+return {
+  {
+    "L3MON4D3/LuaSnip",
+    lazy = true,
+    build = vim.fn.has "win32" == 0
+        and "echo 'NOTE: jsregexp is optional, so not a big deal if it fails to build\n'; make install_jsregexp"
+      or nil,
+    dependencies = { "rafamadriz/friendly-snippets" },
+    opts = {
+      history = true,
+      delete_check_events = "TextChanged",
+      region_check_events = "CursorMoved",
+    },
+    config = require "plugins.configs.luasnip",
+  },
+  {
+    "hrsh7th/nvim-cmp",
+    dependencies = {
+      "saadparwaiz1/cmp_luasnip",
+      "hrsh7th/cmp-buffer",
+      "hrsh7th/cmp-path",
+      "hrsh7th/cmp-nvim-lsp",
+    },
+    event = "InsertEnter",
+    opts = function()
+      local cmp = require "cmp"
+      local snip_status_ok, luasnip = pcall(require, "luasnip")
+      local lspkind_status_ok, lspkind = pcall(require, "lspkind")
+      local utils = require "astronvim.utils"
+      if not snip_status_ok then return end
+      local border_opts = {
+        border = "rounded",
+        winhighlight = "Normal:NormalFloat,FloatBorder:FloatBorder,CursorLine:PmenuSel,Search:None",
+      }
+
+      local function has_words_before()
+        local line, col = (unpack or table.unpack)(vim.api.nvim_win_get_cursor(0))
+        return col ~= 0 and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]:sub(col, col):match "%s" == nil
+      end
+
+      return {
+        enabled = function()
+          local dap_prompt = utils.is_available "cmp-dap" -- add interoperability with cmp-dap
+            and vim.tbl_contains(
+              { "dap-repl", "dapui_watches", "dapui_hover" },
+              vim.api.nvim_get_option_value("filetype", { buf = 0 })
+            )
+          if vim.api.nvim_get_option_value("buftype", { buf = 0 }) == "prompt" and not dap_prompt then return false end
+          return vim.g.cmp_enabled
+        end,
+        preselect = cmp.PreselectMode.None,
+        formatting = {
+          fields = { "kind", "abbr", "menu" },
+          format = lspkind_status_ok and lspkind.cmp_format(utils.plugin_opts "lspkind.nvim") or nil,
+        },
+        snippet = {
+          expand = function(args) luasnip.lsp_expand(args.body) end,
+        },
+        duplicates = {
+          nvim_lsp = 1,
+          luasnip = 1,
+          cmp_tabnine = 1,
+          buffer = 1,
+          path = 1,
+        },
+        confirm_opts = {
+          behavior = cmp.ConfirmBehavior.Replace,
+          select = false,
+        },
+        window = {
+          completion = cmp.config.window.bordered(border_opts),
+          documentation = cmp.config.window.bordered(border_opts),
+        },
+        mapping = {
+          ["<Up>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Select },
+          ["<Down>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Select },
+          ["<C-p>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
+          ["<C-n>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
+          ["<C-k>"] = cmp.mapping.select_prev_item { behavior = cmp.SelectBehavior.Insert },
+          ["<C-j>"] = cmp.mapping.select_next_item { behavior = cmp.SelectBehavior.Insert },
+          ["<C-u>"] = cmp.mapping(cmp.mapping.scroll_docs(-4), { "i", "c" }),
+          ["<C-d>"] = cmp.mapping(cmp.mapping.scroll_docs(4), { "i", "c" }),
+          ["<C-Space>"] = cmp.mapping(cmp.mapping.complete(), { "i", "c" }),
+          ["<C-y>"] = cmp.config.disable,
+          ["<C-e>"] = cmp.mapping { i = cmp.mapping.abort(), c = cmp.mapping.close() },
+          ["<CR>"] = cmp.mapping.confirm { select = false },
+          ["<Tab>"] = cmp.mapping(function(fallback)
+            if cmp.visible() then
+              cmp.select_next_item()
+            elseif luasnip.expand_or_locally_jumpable() then
+              luasnip.expand_or_jump()
+            elseif has_words_before() then
+              cmp.complete()
+            else
+              fallback()
+            end
+          end, { "i", "s" }),
+          ["<S-Tab>"] = cmp.mapping(function(fallback)
+            if cmp.visible() then
+              cmp.select_prev_item()
+            elseif luasnip.jumpable(-1) then
+              luasnip.jump(-1)
+            else
+              fallback()
+            end
+          end, { "i", "s" }),
+        },
+        sources = cmp.config.sources {
+          { name = "nvim_lsp", priority = 1000 },
+          { name = "luasnip", priority = 750 },
+          { name = "buffer", priority = 500 },
+          { name = "path", priority = 250 },
+        },
+      }
+    end,
+  },
+}
diff --git a/lua/astronvim/plugins/configs/alpha.lua b/lua/plugins/configs/alpha.lua
similarity index 73%
rename from lua/astronvim/plugins/configs/alpha.lua
rename to lua/plugins/configs/alpha.lua
index 0102f3f..021808b 100644
--- a/lua/astronvim/plugins/configs/alpha.lua
+++ b/lua/plugins/configs/alpha.lua
@@ -8,8 +8,7 @@ return function(_, opts)
     callback = function()
       local stats = require("lazy").stats()
       local ms = math.floor(stats.startuptime * 100 + 0.5) / 100
-      opts.section.footer.val =
-        { "AstroNvim loaded " .. stats.loaded .. "/" .. stats.count .. " plugins  in " .. ms .. "ms" }
+      opts.section.footer.val = { "AstroNvim loaded " .. stats.count .. " plugins  in " .. ms .. "ms" }
       pcall(vim.cmd.AlphaRedraw)
     end,
   })
diff --git a/lua/astronvim/plugins/configs/cmp-dap.lua b/lua/plugins/configs/cmp-dap.lua
similarity index 86%
rename from lua/astronvim/plugins/configs/cmp-dap.lua
rename to lua/plugins/configs/cmp-dap.lua
index f98c224..cb4f048 100644
--- a/lua/astronvim/plugins/configs/cmp-dap.lua
+++ b/lua/plugins/configs/cmp-dap.lua
@@ -1,4 +1,4 @@
-return function(_, _)
+return function()
   require("cmp").setup.filetype({ "dap-repl", "dapui_watches", "dapui_hover" }, {
     sources = {
       { name = "dap" },
diff --git a/lua/astronvim/plugins/configs/guess-indent.lua b/lua/plugins/configs/guess-indent.lua
similarity index 100%
rename from lua/astronvim/plugins/configs/guess-indent.lua
rename to lua/plugins/configs/guess-indent.lua
diff --git a/lua/plugins/configs/heirline.lua b/lua/plugins/configs/heirline.lua
new file mode 100644
index 0000000..60d5e6a
--- /dev/null
+++ b/lua/plugins/configs/heirline.lua
@@ -0,0 +1,117 @@
+return function(_, opts)
+  local heirline = require "heirline"
+  local C = require("astronvim.utils.status.env").fallback_colors
+  local get_hlgroup = require("astronvim.utils").get_hlgroup
+  local lualine_mode = require("astronvim.utils.status.hl").lualine_mode
+  local function resolve_lualine(orig, ...) return (not orig or orig == "NONE") and lualine_mode(...) or orig end
+
+  local function setup_colors()
+    local Normal = get_hlgroup("Normal", { fg = C.fg, bg = C.bg })
+    local Comment = get_hlgroup("Comment", { fg = C.bright_grey, bg = C.bg })
+    local Error = get_hlgroup("Error", { fg = C.red, bg = C.bg })
+    local StatusLine = get_hlgroup("StatusLine", { fg = C.fg, bg = C.dark_bg })
+    local TabLine = get_hlgroup("TabLine", { fg = C.grey, bg = C.none })
+    local TabLineFill = get_hlgroup("TabLineFill", { fg = C.fg, bg = C.dark_bg })
+    local TabLineSel = get_hlgroup("TabLineSel", { fg = C.fg, bg = C.none })
+    local WinBar = get_hlgroup("WinBar", { fg = C.bright_grey, bg = C.bg })
+    local WinBarNC = get_hlgroup("WinBarNC", { fg = C.grey, bg = C.bg })
+    local Conditional = get_hlgroup("Conditional", { fg = C.bright_purple, bg = C.dark_bg })
+    local String = get_hlgroup("String", { fg = C.green, bg = C.dark_bg })
+    local TypeDef = get_hlgroup("TypeDef", { fg = C.yellow, bg = C.dark_bg })
+    local GitSignsAdd = get_hlgroup("GitSignsAdd", { fg = C.green, bg = C.dark_bg })
+    local GitSignsChange = get_hlgroup("GitSignsChange", { fg = C.orange, bg = C.dark_bg })
+    local GitSignsDelete = get_hlgroup("GitSignsDelete", { fg = C.bright_red, bg = C.dark_bg })
+    local DiagnosticError = get_hlgroup("DiagnosticError", { fg = C.bright_red, bg = C.dark_bg })
+    local DiagnosticWarn = get_hlgroup("DiagnosticWarn", { fg = C.orange, bg = C.dark_bg })
+    local DiagnosticInfo = get_hlgroup("DiagnosticInfo", { fg = C.white, bg = C.dark_bg })
+    local DiagnosticHint = get_hlgroup("DiagnosticHint", { fg = C.bright_yellow, bg = C.dark_bg })
+    local HeirlineInactive = resolve_lualine(get_hlgroup("HeirlineInactive", { bg = nil }).bg, "inactive", C.dark_grey)
+    local HeirlineNormal = resolve_lualine(get_hlgroup("HeirlineNormal", { bg = nil }).bg, "normal", C.blue)
+    local HeirlineInsert = resolve_lualine(get_hlgroup("HeirlineInsert", { bg = nil }).bg, "insert", C.green)
+    local HeirlineVisual = resolve_lualine(get_hlgroup("HeirlineVisual", { bg = nil }).bg, "visual", C.purple)
+    local HeirlineReplace = resolve_lualine(get_hlgroup("HeirlineReplace", { bg = nil }).bg, "replace", C.bright_red)
+    local HeirlineCommand = resolve_lualine(get_hlgroup("HeirlineCommand", { bg = nil }).bg, "command", C.bright_yellow)
+    local HeirlineTerminal = resolve_lualine(get_hlgroup("HeirlineTerminal", { bg = nil }).bg, "insert", HeirlineInsert)
+
+    local colors = astronvim.user_opts("heirline.colors", {
+      close_fg = Error.fg,
+      fg = StatusLine.fg,
+      bg = StatusLine.bg,
+      section_fg = StatusLine.fg,
+      section_bg = StatusLine.bg,
+      git_branch_fg = Conditional.fg,
+      mode_fg = StatusLine.bg,
+      treesitter_fg = String.fg,
+      scrollbar = TypeDef.fg,
+      git_added = GitSignsAdd.fg,
+      git_changed = GitSignsChange.fg,
+      git_removed = GitSignsDelete.fg,
+      diag_ERROR = DiagnosticError.fg,
+      diag_WARN = DiagnosticWarn.fg,
+      diag_INFO = DiagnosticInfo.fg,
+      diag_HINT = DiagnosticHint.fg,
+      winbar_fg = WinBar.fg,
+      winbar_bg = WinBar.bg,
+      winbarnc_fg = WinBarNC.fg,
+      winbarnc_bg = WinBarNC.bg,
+      tabline_bg = TabLineFill.bg,
+      tabline_fg = TabLineFill.bg,
+      buffer_fg = Comment.fg,
+      buffer_path_fg = WinBarNC.fg,
+      buffer_close_fg = Comment.fg,
+      buffer_bg = TabLineFill.bg,
+      buffer_active_fg = Normal.fg,
+      buffer_active_path_fg = WinBarNC.fg,
+      buffer_active_close_fg = Error.fg,
+      buffer_active_bg = Normal.bg,
+      buffer_visible_fg = Normal.fg,
+      buffer_visible_path_fg = WinBarNC.fg,
+      buffer_visible_close_fg = Error.fg,
+      buffer_visible_bg = Normal.bg,
+      buffer_overflow_fg = Comment.fg,
+      buffer_overflow_bg = TabLineFill.bg,
+      buffer_picker_fg = Error.fg,
+      tab_close_fg = Error.fg,
+      tab_close_bg = TabLineFill.bg,
+      tab_fg = TabLine.fg,
+      tab_bg = TabLine.bg,
+      tab_active_fg = TabLineSel.fg,
+      tab_active_bg = TabLineSel.bg,
+      inactive = HeirlineInactive,
+      normal = HeirlineNormal,
+      insert = HeirlineInsert,
+      visual = HeirlineVisual,
+      replace = HeirlineReplace,
+      command = HeirlineCommand,
+      terminal = HeirlineTerminal,
+    })
+
+    for _, section in ipairs {
+      "git_branch",
+      "file_info",
+      "git_diff",
+      "diagnostics",
+      "lsp",
+      "macro_recording",
+      "mode",
+      "cmd_info",
+      "treesitter",
+      "nav",
+    } do
+      if not colors[section .. "_bg"] then colors[section .. "_bg"] = colors["section_bg"] end
+      if not colors[section .. "_fg"] then colors[section .. "_fg"] = colors["section_fg"] end
+    end
+    return colors
+  end
+
+  heirline.load_colors(setup_colors())
+  heirline.setup(opts)
+
+  local augroup = vim.api.nvim_create_augroup("Heirline", { clear = true })
+  vim.api.nvim_create_autocmd("User", {
+    pattern = "AstroColorScheme",
+    group = augroup,
+    desc = "Refresh heirline colors",
+    callback = function() require("heirline.utils").on_colorscheme(setup_colors()) end,
+  })
+end
diff --git a/lua/plugins/configs/lspconfig.lua b/lua/plugins/configs/lspconfig.lua
new file mode 100644
index 0000000..ff74274
--- /dev/null
+++ b/lua/plugins/configs/lspconfig.lua
@@ -0,0 +1,56 @@
+return function(_, _)
+  local lsp = require "astronvim.utils.lsp"
+  local utils = require "astronvim.utils"
+  local get_icon = utils.get_icon
+  local signs = {
+    { name = "DiagnosticSignError", text = get_icon "DiagnosticError", texthl = "DiagnosticSignError" },
+    { name = "DiagnosticSignWarn", text = get_icon "DiagnosticWarn", texthl = "DiagnosticSignWarn" },
+    { name = "DiagnosticSignHint", text = get_icon "DiagnosticHint", texthl = "DiagnosticSignHint" },
+    { name = "DiagnosticSignInfo", text = get_icon "DiagnosticInfo", texthl = "DiagnosticSignInfo" },
+    { name = "DapStopped", text = get_icon "DapStopped", texthl = "DiagnosticWarn" },
+    { name = "DapBreakpoint", text = get_icon "DapBreakpoint", texthl = "DiagnosticInfo" },
+    { name = "DapBreakpointRejected", text = get_icon "DapBreakpointRejected", texthl = "DiagnosticError" },
+    { name = "DapBreakpointCondition", text = get_icon "DapBreakpointCondition", texthl = "DiagnosticInfo" },
+    { name = "DapLogPoint", text = get_icon "DapLogPoint", texthl = "DiagnosticInfo" },
+  }
+
+  for _, sign in ipairs(signs) do
+    vim.fn.sign_define(sign.name, sign)
+  end
+  lsp.setup_diagnostics(signs)
+
+  local orig_handler = vim.lsp.handlers["$/progress"]
+  vim.lsp.handlers["$/progress"] = function(_, msg, info)
+    local progress, id = astronvim.lsp.progress, ("%s.%s"):format(info.client_id, msg.token)
+    progress[id] = progress[id] and utils.extend_tbl(progress[id], msg.value) or msg.value
+    if progress[id].kind == "end" then
+      vim.defer_fn(function()
+        progress[id] = nil
+        utils.event "LspProgress"
+      end, 100)
+    end
+    utils.event "LspProgress"
+    orig_handler(_, msg, info)
+  end
+
+  if vim.g.lsp_handlers_enabled then
+    vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, { border = "rounded", silent = true })
+    vim.lsp.handlers["textDocument/signatureHelp"] =
+      vim.lsp.with(vim.lsp.handlers.signature_help, { border = "rounded", silent = true })
+  end
+  local setup_servers = function()
+    vim.tbl_map(require("astronvim.utils.lsp").setup, astronvim.user_opts "lsp.servers")
+    vim.api.nvim_exec_autocmds("FileType", { modeline = false })
+    require("astronvim.utils").event "LspSetup"
+  end
+  if require("astronvim.utils").is_available "mason-lspconfig.nvim" then
+    vim.api.nvim_create_autocmd("User", {
+      desc = "set up LSP servers after mason-lspconfig",
+      pattern = "AstroMasonLspSetup",
+      once = true,
+      callback = setup_servers,
+    })
+  else
+    setup_servers()
+  end
+end
diff --git a/lua/astronvim/plugins/configs/lspkind.lua b/lua/plugins/configs/lspkind.lua
similarity index 100%
rename from lua/astronvim/plugins/configs/lspkind.lua
rename to lua/plugins/configs/lspkind.lua
diff --git a/lua/astronvim/plugins/configs/luasnip.lua b/lua/plugins/configs/luasnip.lua
similarity index 100%
rename from lua/astronvim/plugins/configs/luasnip.lua
rename to lua/plugins/configs/luasnip.lua
diff --git a/lua/plugins/configs/mason-lspconfig.lua b/lua/plugins/configs/mason-lspconfig.lua
new file mode 100644
index 0000000..019874e
--- /dev/null
+++ b/lua/plugins/configs/mason-lspconfig.lua
@@ -0,0 +1,4 @@
+return function(_, opts)
+  require("mason-lspconfig").setup(opts)
+  require("astronvim.utils").event "MasonLspSetup"
+end
diff --git a/lua/plugins/configs/mason-null-ls.lua b/lua/plugins/configs/mason-null-ls.lua
new file mode 100644
index 0000000..e693a3e
--- /dev/null
+++ b/lua/plugins/configs/mason-null-ls.lua
@@ -0,0 +1,5 @@
+-- TODO: REMOVE THIS UNNECESSARY FILE
+return function(_, opts)
+  local mason_null_ls = require "mason-null-ls"
+  mason_null_ls.setup(opts)
+end
diff --git a/lua/plugins/configs/mason-nvim-dap.lua b/lua/plugins/configs/mason-nvim-dap.lua
new file mode 100644
index 0000000..d2b6ed5
--- /dev/null
+++ b/lua/plugins/configs/mason-nvim-dap.lua
@@ -0,0 +1,5 @@
+-- TODO: remove unnecessary file in AstroNvim v4
+return function(_, opts)
+  local mason_nvim_dap = require "mason-nvim-dap"
+  mason_nvim_dap.setup(opts)
+end
diff --git a/lua/plugins/configs/mason.lua b/lua/plugins/configs/mason.lua
new file mode 100644
index 0000000..21739d0
--- /dev/null
+++ b/lua/plugins/configs/mason.lua
@@ -0,0 +1,26 @@
+return function(_, opts)
+  require("mason").setup(opts)
+
+  -- TODO: AstroNvim v4: change these auto command names to not conflict with core Mason commands
+  local cmd = vim.api.nvim_create_user_command
+  cmd("MasonUpdate", function(options) require("astronvim.utils.mason").update(options.fargs) end, {
+    nargs = "*",
+    desc = "Update Mason Package",
+    complete = function(arg_lead)
+      local _ = require "mason-core.functional"
+      return _.sort_by(
+        _.identity,
+        _.filter(_.starts_with(arg_lead), require("mason-registry").get_installed_package_names())
+      )
+    end,
+  })
+  cmd(
+    "MasonUpdateAll",
+    function() require("astronvim.utils.mason").update_all() end,
+    { desc = "Update Mason Packages" }
+  )
+
+  for _, plugin in ipairs { "mason-lspconfig", "mason-null-ls", "mason-nvim-dap" } do
+    pcall(require, plugin)
+  end
+end
diff --git a/lua/astronvim/plugins/configs/notify.lua b/lua/plugins/configs/notify.lua
similarity index 100%
rename from lua/astronvim/plugins/configs/notify.lua
rename to lua/plugins/configs/notify.lua
diff --git a/lua/plugins/configs/nvim-autopairs.lua b/lua/plugins/configs/nvim-autopairs.lua
new file mode 100644
index 0000000..823f017
--- /dev/null
+++ b/lua/plugins/configs/nvim-autopairs.lua
@@ -0,0 +1,10 @@
+return function(_, opts)
+  local npairs = require "nvim-autopairs"
+  npairs.setup(opts)
+
+  if not vim.g.autopairs_enabled then npairs.disable() end
+  local cmp_status_ok, cmp = pcall(require, "cmp")
+  if cmp_status_ok then
+    cmp.event:on("confirm_done", require("nvim-autopairs.completion.cmp").on_confirm_done { tex = false })
+  end
+end
diff --git a/lua/astronvim/plugins/configs/nvim-dap-ui.lua b/lua/plugins/configs/nvim-dap-ui.lua
similarity index 100%
rename from lua/astronvim/plugins/configs/nvim-dap-ui.lua
rename to lua/plugins/configs/nvim-dap-ui.lua
diff --git a/lua/plugins/configs/nvim-treesitter.lua b/lua/plugins/configs/nvim-treesitter.lua
new file mode 100644
index 0000000..f8df042
--- /dev/null
+++ b/lua/plugins/configs/nvim-treesitter.lua
@@ -0,0 +1,11 @@
+return function(_, opts)
+  if type(opts.ensure_installed) == "table" then
+    local added = {}
+    opts.ensure_installed = vim.tbl_filter(function(parser)
+      if added[parser] then return false end
+      added[parser] = true
+      return true
+    end, opts.ensure_installed)
+  end
+  require("nvim-treesitter.configs").setup(opts)
+end
diff --git a/lua/plugins/configs/nvim-web-devicons.lua b/lua/plugins/configs/nvim-web-devicons.lua
new file mode 100644
index 0000000..bc6cad3
--- /dev/null
+++ b/lua/plugins/configs/nvim-web-devicons.lua
@@ -0,0 +1,5 @@
+-- TODO: remove unnecessary file in AstroNvim v4
+return function(_, opts)
+  require("nvim-web-devicons").set_default_icon(require("astronvim.utils").get_icon "DefaultFile", "#6d8086", "66")
+  require("nvim-web-devicons").set_icon(opts)
+end
diff --git a/lua/plugins/configs/telescope.lua b/lua/plugins/configs/telescope.lua
new file mode 100644
index 0000000..18d3e86
--- /dev/null
+++ b/lua/plugins/configs/telescope.lua
@@ -0,0 +1,9 @@
+return function(_, opts)
+  local telescope = require "telescope"
+  telescope.setup(opts)
+  local utils = require "astronvim.utils"
+  local conditional_func = utils.conditional_func
+  conditional_func(telescope.load_extension, pcall(require, "notify"), "notify")
+  conditional_func(telescope.load_extension, pcall(require, "aerial"), "aerial")
+  conditional_func(telescope.load_extension, utils.is_available "telescope-fzf-native.nvim", "fzf")
+end
diff --git a/lua/plugins/configs/which-key.lua b/lua/plugins/configs/which-key.lua
new file mode 100644
index 0000000..1c4da7a
--- /dev/null
+++ b/lua/plugins/configs/which-key.lua
@@ -0,0 +1,4 @@
+return function(_, opts)
+  require("which-key").setup(opts)
+  require("astronvim.utils").which_key_register()
+end
diff --git a/lua/plugins/core.lua b/lua/plugins/core.lua
new file mode 100644
index 0000000..238b1db
--- /dev/null
+++ b/lua/plugins/core.lua
@@ -0,0 +1,134 @@
+return {
+  { "nvim-lua/plenary.nvim", lazy = true },
+  { "echasnovski/mini.bufremove", lazy = true },
+  { "AstroNvim/astrotheme", lazy = true, opts = { plugins = { ["dashboard-nvim"] = true } } },
+  { "max397574/better-escape.nvim", event = "InsertCharPre", opts = { timeout = 300 } },
+  { "NMAC427/guess-indent.nvim", event = "User AstroFile", config = require "plugins.configs.guess-indent" },
+  { -- TODO: REMOVE neovim-session-manager with AstroNvim v4
+    "Shatur/neovim-session-manager",
+    event = "BufWritePost",
+    cmd = "SessionManager",
+    enabled = vim.g.resession_enabled ~= true,
+  },
+  {
+    "stevearc/resession.nvim",
+    enabled = vim.g.resession_enabled == true,
+    lazy = true,
+    opts = {
+      buf_filter = function(bufnr) return require("astronvim.utils.buffer").is_restorable(bufnr) end,
+      tab_buf_filter = function(tabpage, bufnr) return vim.tbl_contains(vim.t[tabpage].bufs, bufnr) end,
+      extensions = { astronvim = {} },
+    },
+  },
+  {
+    "s1n7ax/nvim-window-picker",
+    lazy = true,
+    main = "window-picker",
+    opts = { picker_config = { statusline_winbar_picker = { use_winbar = "smart" } } },
+  },
+  {
+    "mrjones2014/smart-splits.nvim",
+    lazy = true,
+    opts = { ignored_filetypes = { "nofile", "quickfix", "qf", "prompt" }, ignored_buftypes = { "nofile" } },
+  },
+  {
+    "windwp/nvim-autopairs",
+    event = "User AstroFile",
+    opts = {
+      check_ts = true,
+      ts_config = { java = false },
+      fast_wrap = {
+        map = "<M-e>",
+        chars = { "{", "[", "(", '"', "'" },
+        pattern = string.gsub([[ [%'%"%)%>%]%)%}%,] ]], "%s+", ""),
+        offset = 0,
+        end_key = "$",
+        keys = "qwertyuiopzxcvbnmasdfghjkl",
+        check_comma = true,
+        highlight = "PmenuSel",
+        highlight_grey = "LineNr",
+      },
+    },
+    config = require "plugins.configs.nvim-autopairs",
+  },
+  {
+    "folke/which-key.nvim",
+    event = "VeryLazy",
+    opts = {
+      icons = { group = vim.g.icons_enabled and "" or "+", separator = "" },
+      disable = { filetypes = { "TelescopePrompt" } },
+    },
+    config = require "plugins.configs.which-key",
+  },
+  {
+    "kevinhwang91/nvim-ufo",
+    event = { "User AstroFile", "InsertEnter" },
+    dependencies = { "kevinhwang91/promise-async" },
+    opts = {
+      preview = {
+        mappings = {
+          scrollB = "<C-b>",
+          scrollF = "<C-f>",
+          scrollU = "<C-u>",
+          scrollD = "<C-d>",
+        },
+      },
+      provider_selector = function(_, filetype, buftype)
+        local function handleFallbackException(bufnr, err, providerName)
+          if type(err) == "string" and err:match "UfoFallbackException" then
+            return require("ufo").getFolds(bufnr, providerName)
+          else
+            return require("promise").reject(err)
+          end
+        end
+
+        return (filetype == "" or buftype == "nofile") and "indent" -- only use indent until a file is opened
+          or function(bufnr)
+            return require("ufo")
+              .getFolds(bufnr, "lsp")
+              :catch(function(err) return handleFallbackException(bufnr, err, "treesitter") end)
+              :catch(function(err) return handleFallbackException(bufnr, err, "indent") end)
+          end
+      end,
+    },
+  },
+  {
+    "numToStr/Comment.nvim",
+    keys = {
+      { "gc", mode = { "n", "v" }, desc = "Comment toggle linewise" },
+      { "gb", mode = { "n", "v" }, desc = "Comment toggle blockwise" },
+    },
+    opts = function()
+      local commentstring_avail, commentstring = pcall(require, "ts_context_commentstring.integrations.comment_nvim")
+      return commentstring_avail and commentstring and { pre_hook = commentstring.create_pre_hook() } or {}
+    end,
+  },
+  {
+    "akinsho/toggleterm.nvim",
+    cmd = { "ToggleTerm", "TermExec" },
+    opts = {
+      highlights = {
+        Normal = { link = "Normal" },
+        NormalNC = { link = "NormalNC" },
+        NormalFloat = { link = "NormalFloat" },
+        FloatBorder = { link = "FloatBorder" },
+        StatusLine = { link = "StatusLine" },
+        StatusLineNC = { link = "StatusLineNC" },
+        WinBar = { link = "WinBar" },
+        WinBarNC = { link = "WinBarNC" },
+      },
+      size = 10,
+      ---@param t Terminal
+      on_create = function(t)
+        vim.opt.foldcolumn = "0"
+        vim.opt.signcolumn = "no"
+        local toggle = function() t:toggle() end
+        vim.keymap.set({ "n", "t", "i" }, "<C-'>", toggle, { desc = "Toggle terminal", buffer = t.bufnr })
+        vim.keymap.set({ "n", "t", "i" }, "<F7>", toggle, { desc = "Toggle terminal", buffer = t.bufnr })
+      end,
+      shading_factor = 2,
+      direction = "float",
+      float_opts = { border = "rounded" },
+    },
+  },
+}
diff --git a/lua/plugins/dap.lua b/lua/plugins/dap.lua
new file mode 100644
index 0000000..c532096
--- /dev/null
+++ b/lua/plugins/dap.lua
@@ -0,0 +1,23 @@
+return {
+  "mfussenegger/nvim-dap",
+  enabled = vim.fn.has "win32" == 0,
+  dependencies = {
+    {
+      "jay-babu/mason-nvim-dap.nvim",
+      dependencies = { "nvim-dap" },
+      cmd = { "DapInstall", "DapUninstall" },
+      opts = { handlers = {} },
+    },
+    {
+      "rcarriga/nvim-dap-ui",
+      opts = { floating = { border = "rounded" } },
+      config = require "plugins.configs.nvim-dap-ui",
+    },
+    {
+      "rcarriga/cmp-dap",
+      dependencies = { "nvim-cmp" },
+      config = require "plugins.configs.cmp-dap",
+    },
+  },
+  event = "User AstroFile",
+}
diff --git a/lua/plugins/git.lua b/lua/plugins/git.lua
new file mode 100644
index 0000000..48e099c
--- /dev/null
+++ b/lua/plugins/git.lua
@@ -0,0 +1,17 @@
+local get_icon = require("astronvim.utils").get_icon
+return {
+  "lewis6991/gitsigns.nvim",
+  enabled = vim.fn.executable "git" == 1,
+  event = "User AstroGitFile",
+  opts = {
+    signs = {
+      add = { text = get_icon "GitSign" },
+      change = { text = get_icon "GitSign" },
+      delete = { text = get_icon "GitSign" },
+      topdelete = { text = get_icon "GitSign" },
+      changedelete = { text = get_icon "GitSign" },
+      untracked = { text = get_icon "GitSign" },
+    },
+    worktrees = vim.g.git_worktrees,
+  },
+}
diff --git a/lua/astronvim/plugins/heirline.lua b/lua/plugins/heirline.lua
similarity index 54%
rename from lua/astronvim/plugins/heirline.lua
rename to lua/plugins/heirline.lua
index 37a7995..62f426b 100644
--- a/lua/astronvim/plugins/heirline.lua
+++ b/lua/plugins/heirline.lua
@@ -1,68 +1,29 @@
 return {
   "rebelot/heirline.nvim",
   event = "BufEnter",
-  dependencies = {
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>bb"] = {
-          function()
-            require("astroui.status.heirline").buffer_picker(function(bufnr) vim.api.nvim_win_set_buf(0, bufnr) end)
-          end,
-          desc = "Select buffer from tabline",
-        }
-        maps.n["<Leader>bd"] = {
-          function()
-            require("astroui.status.heirline").buffer_picker(
-              function(bufnr) require("astrocore.buffer").close(bufnr) end
-            )
-          end,
-          desc = "Close buffer from tabline",
-        }
-        maps.n["<Leader>b\\"] = {
-          function()
-            require("astroui.status.heirline").buffer_picker(function(bufnr)
-              vim.cmd.split()
-              vim.api.nvim_win_set_buf(0, bufnr)
-            end)
-          end,
-          desc = "Horizontal split buffer from tabline",
-        }
-        maps.n["<Leader>b|"] = {
-          function()
-            require("astroui.status.heirline").buffer_picker(function(bufnr)
-              vim.cmd.vsplit()
-              vim.api.nvim_win_set_buf(0, bufnr)
-            end)
-          end,
-          desc = "Vertical split buffer from tabline",
-        }
-      end,
-    },
-  },
   opts = function()
-    local status = require "astroui.status"
+    local status = require "astronvim.utils.status"
     return {
       opts = {
-        colors = require("astroui").config.status.setup_colors(),
         disable_winbar_cb = function(args)
-          return not require("astrocore.buffer").is_valid(args.buf)
-            or status.condition.buffer_matches({ buftype = { "terminal", "nofile" } }, args.buf)
+          return not require("astronvim.utils.buffer").is_valid(args.buf)
+            or status.condition.buffer_matches({
+              buftype = { "terminal", "prompt", "nofile", "help", "quickfix" },
+              filetype = { "NvimTree", "neo%-tree", "dashboard", "Outline", "aerial" },
+            }, args.buf)
         end,
       },
       statusline = { -- statusline
         hl = { fg = "fg", bg = "bg" },
         status.component.mode(),
         status.component.git_branch(),
-        status.component.file_info(),
+        status.component.file_info { filetype = {}, filename = false, file_modified = false },
         status.component.git_diff(),
         status.component.diagnostics(),
         status.component.fill(),
         status.component.cmd_info(),
         status.component.fill(),
         status.component.lsp(),
-        status.component.virtual_env(),
         status.component.treesitter(),
         status.component.nav(),
         status.component.mode { surround = { separator = "right" } },
@@ -75,8 +36,7 @@ return {
           status.component.separated_path(),
           status.component.file_info {
             file_icon = { hl = status.hl.file_icon "winbar", padding = { left = 0 } },
-            filename = {},
-            filetype = false,
+            file_modified = false,
             file_read_only = false,
             hl = status.hl.get_attributes("winbarnc", true),
             surround = false,
@@ -86,14 +46,23 @@ return {
         status.component.breadcrumbs { hl = status.hl.get_attributes("winbar", true) },
       },
       tabline = { -- bufferline
-        { -- automatic sidebar padding
+        { -- file tree padding
           condition = function(self)
             self.winid = vim.api.nvim_tabpage_list_wins(0)[1]
-            self.winwidth = vim.api.nvim_win_get_width(self.winid)
-            return self.winwidth ~= vim.o.columns -- only apply to sidebars
-              and not require("astrocore.buffer").is_valid(vim.api.nvim_win_get_buf(self.winid)) -- if buffer is not in tabline
+            return status.condition.buffer_matches({
+              filetype = {
+                "NvimTree",
+                "OverseerList",
+                "aerial",
+                "dap%-repl",
+                "dapui_.",
+                "edgy",
+                "neo%-tree",
+                "undotree",
+              },
+            }, vim.api.nvim_win_get_buf(self.winid))
           end,
-          provider = function(self) return (" "):rep(self.winwidth + 1) end,
+          provider = function(self) return string.rep(" ", vim.api.nvim_win_get_width(self.winid) + 1) end,
           hl = { bg = "tabline_bg" },
         },
         status.heirline.make_buflist(status.component.tabline_file_info()), -- component for each buffer tab
@@ -108,19 +77,20 @@ return {
             provider = status.provider.close_button { kind = "TabClose", padding = { left = 1, right = 1 } },
             hl = status.hl.get_attributes("tab_close", true),
             on_click = {
-              callback = function() require("astrocore.buffer").close_tab() end,
+              callback = function() require("astronvim.utils.buffer").close_tab() end,
               name = "heirline_tabline_close_tab_callback",
             },
           },
         },
       },
-      statuscolumn = {
+      statuscolumn = vim.fn.has "nvim-0.9" == 1 and {
         init = function(self) self.bufnr = vim.api.nvim_get_current_buf() end,
         status.component.foldcolumn(),
+        status.component.fill(),
         status.component.numbercolumn(),
         status.component.signcolumn(),
-      },
+      } or nil,
     }
   end,
-  config = function(...) require "astronvim.plugins.configs.heirline"(...) end,
+  config = require "plugins.configs.heirline",
 }
diff --git a/lua/plugins/lsp.lua b/lua/plugins/lsp.lua
new file mode 100644
index 0000000..a8b567d
--- /dev/null
+++ b/lua/plugins/lsp.lua
@@ -0,0 +1,98 @@
+return {
+  { "b0o/SchemaStore.nvim", lazy = true },
+  {
+    "folke/neodev.nvim",
+    lazy = true,
+    opts = {
+      override = function(root_dir, library)
+        for _, astronvim_config in ipairs(astronvim.supported_configs) do
+          if root_dir:match(astronvim_config) then
+            library.plugins = true
+            break
+          end
+        end
+        vim.b.neodev_enabled = library.enabled
+      end,
+    },
+  },
+  {
+    "neovim/nvim-lspconfig",
+    dependencies = {
+      {
+        "folke/neoconf.nvim",
+        opts = function()
+          local global_settings, file_found
+          local _, depth = vim.fn.stdpath("config"):gsub("/", "")
+          for _, dir in ipairs(astronvim.supported_configs) do
+            dir = dir .. "/lua/user"
+            if vim.fn.isdirectory(dir) == 1 then
+              local path = dir .. "/neoconf.json"
+              if vim.fn.filereadable(path) == 1 then
+                file_found = true
+                global_settings = path
+              elseif not file_found then
+                global_settings = path
+              end
+            end
+          end
+          return { global_settings = global_settings and string.rep("../", depth):sub(1, -2) .. global_settings }
+        end,
+      },
+      {
+        "williamboman/mason-lspconfig.nvim",
+        cmd = { "LspInstall", "LspUninstall" },
+        opts = function(_, opts)
+          if not opts.handlers then opts.handlers = {} end
+          opts.handlers[1] = function(server) require("astronvim.utils.lsp").setup(server) end
+        end,
+        config = require "plugins.configs.mason-lspconfig",
+      },
+    },
+    cmd = function(_, cmds) -- HACK: lazy load lspconfig on `:Neoconf` if neoconf is available
+      if require("astronvim.utils").is_available "neoconf.nvim" then table.insert(cmds, "Neoconf") end
+    end,
+    event = "User AstroFile",
+    config = require "plugins.configs.lspconfig",
+  },
+  {
+    "jose-elias-alvarez/null-ls.nvim",
+    dependencies = {
+      {
+        "jay-babu/mason-null-ls.nvim",
+        cmd = { "NullLsInstall", "NullLsUninstall" },
+        opts = { handlers = {} },
+      },
+    },
+    event = "User AstroFile",
+    opts = function() return { on_attach = require("astronvim.utils.lsp").on_attach } end,
+  },
+  {
+    "stevearc/aerial.nvim",
+    event = "User AstroFile",
+    opts = {
+      attach_mode = "global",
+      backends = { "lsp", "treesitter", "markdown", "man" },
+      disable_max_lines = vim.g.max_file.lines,
+      disable_max_size = vim.g.max_file.size,
+      layout = { min_width = 28 },
+      show_guides = true,
+      filter_kind = false,
+      guides = {
+        mid_item = "├ ",
+        last_item = "└ ",
+        nested_top = "│ ",
+        whitespace = "  ",
+      },
+      keymaps = {
+        ["[y"] = "actions.prev",
+        ["]y"] = "actions.next",
+        ["[Y"] = "actions.prev_up",
+        ["]Y"] = "actions.next_up",
+        ["{"] = false,
+        ["}"] = false,
+        ["[["] = false,
+        ["]]"] = false,
+      },
+    },
+  },
+}
diff --git a/lua/plugins/mason.lua b/lua/plugins/mason.lua
new file mode 100644
index 0000000..ca9f595
--- /dev/null
+++ b/lua/plugins/mason.lua
@@ -0,0 +1,25 @@
+return {
+  {
+    "williamboman/mason.nvim",
+    cmd = {
+      "Mason",
+      "MasonInstall",
+      "MasonUninstall",
+      "MasonUninstallAll",
+      "MasonLog",
+      "MasonUpdate", -- AstroNvim extension here as well
+      "MasonUpdateAll", -- AstroNvim specific
+    },
+    opts = {
+      ui = {
+        icons = {
+          package_installed = "✓",
+          package_uninstalled = "✗",
+          package_pending = "⟳",
+        },
+      },
+    },
+    build = ":MasonUpdate",
+    config = require "plugins.configs.mason",
+  },
+}
diff --git a/lua/astronvim/plugins/neo-tree.lua b/lua/plugins/neo-tree.lua
similarity index 55%
rename from lua/astronvim/plugins/neo-tree.lua
rename to lua/plugins/neo-tree.lua
index 09dc569..7013856 100644
--- a/lua/astronvim/plugins/neo-tree.lua
+++ b/lua/plugins/neo-tree.lua
@@ -1,87 +1,28 @@
 return {
   "nvim-neo-tree/neo-tree.nvim",
-  dependencies = {
-    { "nvim-lua/plenary.nvim", lazy = true },
-    { "MunifTanjim/nui.nvim", lazy = true },
-    {
-      "AstroNvim/astrocore",
-      opts = function(_, opts)
-        local maps = opts.mappings
-        maps.n["<Leader>e"] = { "<Cmd>Neotree toggle<CR>", desc = "Toggle Explorer" }
-        maps.n["<Leader>o"] = {
-          function()
-            if vim.bo.filetype == "neo-tree" then
-              vim.cmd.wincmd "p"
-            else
-              vim.cmd.Neotree "focus"
-            end
-          end,
-          desc = "Toggle Explorer Focus",
-        }
-        opts.autocmds.neotree_start = {
-          {
-            event = "BufEnter",
-            desc = "Open Neo-Tree on startup with directory",
-            callback = function()
-              if package.loaded["neo-tree"] then
-                return true
-              else
-                local stats = (vim.uv or vim.loop).fs_stat(vim.api.nvim_buf_get_name(0)) -- TODO: REMOVE vim.loop WHEN DROPPING SUPPORT FOR Neovim v0.9
-                if stats and stats.type == "directory" then
-                  require("lazy").load { plugins = { "neo-tree.nvim" } }
-                  return true
-                end
-              end
-            end,
-          },
-        }
-        opts.autocmds.neotree_refresh = {
-          {
-            event = "TermClose",
-            pattern = "*lazygit*",
-            desc = "Refresh Neo-Tree sources when closing lazygit",
-            callback = function()
-              local manager_avail, manager = pcall(require, "neo-tree.sources.manager")
-              if manager_avail then
-                for _, source in ipairs { "filesystem", "git_status", "document_symbols" } do
-                  local module = "neo-tree.sources." .. source
-                  if package.loaded[module] then manager.refresh(require(module).name) end
-                end
-              end
-            end,
-          },
-        }
-      end,
-    },
-  },
+  branch = "main", -- HACK: force neo-tree to checkout `main` for initial v3 migration since default branch has changed
+  dependencies = { "MunifTanjim/nui.nvim" },
   cmd = "Neotree",
+  init = function() vim.g.neo_tree_remove_legacy_commands = true end,
   opts = function()
-    local astro, get_icon = require "astrocore", require("astroui").get_icon
-    local git_available = vim.fn.executable "git" == 1
-    local sources = {
-      { source = "filesystem", display_name = get_icon("FolderClosed", 1, true) .. "File" },
-      { source = "buffers", display_name = get_icon("DefaultFile", 1, true) .. "Bufs" },
-      { source = "diagnostics", display_name = get_icon("Diagnostic", 1, true) .. "Diagnostic" },
-    }
-    if git_available then
-      table.insert(sources, 3, { source = "git_status", display_name = get_icon("Git", 1, true) .. "Git" })
-    end
+    local utils = require "astronvim.utils"
+    local get_icon = utils.get_icon
     local opts = {
-      enable_git_status = git_available,
       auto_clean_after_session_restore = true,
       close_if_last_window = true,
-      sources = { "filesystem", "buffers", git_available and "git_status" or nil },
+      sources = { "filesystem", "buffers", "git_status" },
       source_selector = {
         winbar = true,
         content_layout = "center",
-        sources = sources,
+        sources = {
+          { source = "filesystem", display_name = get_icon("FolderClosed", 1, true) .. "File" },
+          { source = "buffers", display_name = get_icon("DefaultFile", 1, true) .. "Bufs" },
+          { source = "git_status", display_name = get_icon("Git", 1, true) .. "Git" },
+          { source = "diagnostics", display_name = get_icon("Diagnostic", 1, true) .. "Diagnostic" },
+        },
       },
       default_component_configs = {
-        indent = {
-          padding = 0,
-          expander_collapsed = get_icon "FoldClosed",
-          expander_expanded = get_icon "FoldOpened",
-        },
+        indent = { padding = 0 },
         icon = {
           folder_closed = get_icon "FolderClosed",
           folder_open = get_icon "FolderOpen",
@@ -106,12 +47,12 @@ return {
       },
       commands = {
         system_open = function(state)
-          -- TODO: remove deprecated method check after dropping support for neovim v0.9
-          (vim.ui.open or astro.system_open)(state.tree:get_node():get_id())
+          -- TODO: just use vim.ui.open when dropping support for Neovim <0.10
+          (vim.ui.open or require("astronvim.utils").system_open)(state.tree:get_node():get_id())
         end,
         parent_or_close = function(state)
           local node = state.tree:get_node()
-          if node:has_children() and node:is_expanded() then
+          if (node.type == "directory" or node:has_children()) and node:is_expanded() then
             state.commands.toggle_node(state)
           else
             require("neo-tree.ui.renderer").focus_node(state, node:get_parent_id())
@@ -119,17 +60,13 @@ return {
         end,
         child_or_open = function(state)
           local node = state.tree:get_node()
-          if node:has_children() then
+          if node.type == "directory" or node:has_children() then
             if not node:is_expanded() then -- if unexpanded, expand
               state.commands.toggle_node(state)
             else -- if expanded and has children, seleect the next child
-              if node.type == "file" then
-                state.commands.open(state)
-              else
-                require("neo-tree.ui.renderer").focus_node(state, node:get_child_ids()[1])
-              end
+              require("neo-tree.ui.renderer").focus_node(state, node:get_child_ids()[1])
             end
-          else -- if has no children
+          else -- if not a directory just open it
             state.commands.open(state)
           end
         end,
@@ -151,7 +88,7 @@ return {
 
           local options = vim.tbl_filter(function(val) return vals[val] ~= "" end, vim.tbl_keys(vals))
           if vim.tbl_isempty(options) then
-            astro.notify("No values to copy", vim.log.levels.WARN)
+            utils.notify("No values to copy", vim.log.levels.WARN)
             return
           end
           table.sort(options)
@@ -161,7 +98,7 @@ return {
           }, function(choice)
             local result = vals[choice]
             if result then
-              astro.notify(("Copied: `%s`"):format(result))
+              utils.notify(("Copied: `%s`"):format(result))
               vim.fn.setreg("+", result)
             end
           end)
@@ -170,38 +107,34 @@ return {
       window = {
         width = 30,
         mappings = {
-          ["<S-CR>"] = "system_open",
-          ["<Space>"] = false, -- disable space until we figure out which-key disabling
+          ["<space>"] = false, -- disable space until we figure out which-key disabling
           ["[b"] = "prev_source",
           ["]b"] = "next_source",
           O = "system_open",
           Y = "copy_selector",
           h = "parent_or_close",
           l = "child_or_open",
+          o = "open",
         },
         fuzzy_finder_mappings = { -- define keymaps for filter popup window in fuzzy_finder_mode
-          ["<C-J>"] = "move_cursor_down",
-          ["<C-K>"] = "move_cursor_up",
+          ["<C-j>"] = "move_cursor_down",
+          ["<C-k>"] = "move_cursor_up",
         },
       },
       filesystem = {
         follow_current_file = { enabled = true },
-        filtered_items = { hide_gitignored = git_available },
         hijack_netrw_behavior = "open_current",
         use_libuv_file_watcher = vim.fn.has "win32" ~= 1,
       },
       event_handlers = {
         {
           event = "neo_tree_buffer_enter",
-          handler = function(_)
-            vim.opt_local.signcolumn = "auto"
-            vim.opt_local.foldcolumn = "0"
-          end,
+          handler = function(_) vim.opt_local.signcolumn = "auto" end,
         },
       },
     }
 
-    if astro.is_available "telescope.nvim" then
+    if utils.is_available "telescope.nvim" then
       opts.commands.find_in_dir = function(state)
         local node = state.tree:get_node()
         local path = node.type == "file" and node:get_parent_id() or node:get_id()
@@ -210,7 +143,7 @@ return {
       opts.window.mappings.F = "find_in_dir"
     end
 
-    if astro.is_available "toggleterm.nvim" then
+    if utils.is_available "toggleterm.nvim" then
       local toggleterm_in_direction = function(state, direction)
         local node = state.tree:get_node()
         local path = node.type == "file" and node:get_parent_id() or node:get_id()
diff --git a/lua/plugins/telescope.lua b/lua/plugins/telescope.lua
new file mode 100644
index 0000000..280db06
--- /dev/null
+++ b/lua/plugins/telescope.lua
@@ -0,0 +1,37 @@
+return {
+  "nvim-telescope/telescope.nvim",
+  dependencies = {
+    { "nvim-telescope/telescope-fzf-native.nvim", enabled = vim.fn.executable "make" == 1, build = "make" },
+  },
+  cmd = "Telescope",
+  opts = function()
+    local actions = require "telescope.actions"
+    local get_icon = require("astronvim.utils").get_icon
+    return {
+      defaults = {
+        git_worktrees = vim.g.git_worktrees,
+        prompt_prefix = get_icon("Selected", 1),
+        selection_caret = get_icon("Selected", 1),
+        path_display = { "truncate" },
+        sorting_strategy = "ascending",
+        layout_config = {
+          horizontal = { prompt_position = "top", preview_width = 0.55 },
+          vertical = { mirror = false },
+          width = 0.87,
+          height = 0.80,
+          preview_cutoff = 120,
+        },
+        mappings = {
+          i = {
+            ["<C-n>"] = actions.cycle_history_next,
+            ["<C-p>"] = actions.cycle_history_prev,
+            ["<C-j>"] = actions.move_selection_next,
+            ["<C-k>"] = actions.move_selection_previous,
+          },
+          n = { q = actions.close },
+        },
+      },
+    }
+  end,
+  config = require "plugins.configs.telescope",
+}
diff --git a/lua/astronvim/plugins/treesitter.lua b/lua/plugins/treesitter.lua
similarity index 78%
rename from lua/astronvim/plugins/treesitter.lua
rename to lua/plugins/treesitter.lua
index 2cc9c75..f6419d1 100644
--- a/lua/astronvim/plugins/treesitter.lua
+++ b/lua/plugins/treesitter.lua
@@ -1,7 +1,11 @@
 return {
   "nvim-treesitter/nvim-treesitter",
-  main = "nvim-treesitter.configs",
-  dependencies = { { "nvim-treesitter/nvim-treesitter-textobjects", lazy = true } },
+  dependencies = {
+    { "JoosepAlviste/nvim-ts-context-commentstring", commit = "6c30f3c8915d7b31c3decdfe6c7672432da1809d" },
+    "nvim-treesitter/nvim-treesitter-textobjects",
+    -- HACK: remove when https://github.com/windwp/nvim-ts-autotag/issues/125 closed.
+    { "windwp/nvim-ts-autotag", opts = { enable_close_on_slash = false } },
+  },
   event = "User AstroFile",
   cmd = {
     "TSBufDisable",
@@ -30,11 +34,25 @@ return {
     require "nvim-treesitter.query_predicates"
   end,
   opts = function()
-    if require("astrocore").is_available "mason.nvim" then require("lazy").load { plugins = { "mason.nvim" } } end
     return {
-      auto_install = vim.fn.executable "git" == 1 and vim.fn.executable "tree-sitter" == 1, -- only enable auto install if `tree-sitter` cli is installed
-      ensure_installed = {},
-      highlight = { enable = true },
+      autotag = { enable = true },
+      context_commentstring = { enable = true, enable_autocmd = false },
+      -- HACK: force install of shipped neovim parsers since TSUpdate doesn't correctly update them
+      ensure_installed = {
+        "bash",
+        "c",
+        "lua",
+        "markdown",
+        "markdown_inline",
+        "python",
+        "query",
+        "vim",
+        "vimdoc",
+      },
+      highlight = {
+        enable = true,
+        disable = function(_, bufnr) return vim.b[bufnr].large_buf end,
+      },
       incremental_selection = { enable = true },
       indent = { enable = true },
       textobjects = {
@@ -50,8 +68,8 @@ return {
             ["i?"] = { query = "@conditional.inner", desc = "inside conditional" },
             ["af"] = { query = "@function.outer", desc = "around function " },
             ["if"] = { query = "@function.inner", desc = "inside function " },
-            ["ao"] = { query = "@loop.outer", desc = "around loop" },
-            ["io"] = { query = "@loop.inner", desc = "inside loop" },
+            ["al"] = { query = "@loop.outer", desc = "around loop" },
+            ["il"] = { query = "@loop.inner", desc = "inside loop" },
             ["aa"] = { query = "@parameter.outer", desc = "around argument" },
             ["ia"] = { query = "@parameter.inner", desc = "inside argument" },
           },
@@ -96,5 +114,5 @@ return {
       },
     }
   end,
-  config = function(...) require "astronvim.plugins.configs.nvim-treesitter"(...) end,
+  config = require "plugins.configs.nvim-treesitter",
 }
diff --git a/lua/plugins/ui.lua b/lua/plugins/ui.lua
new file mode 100644
index 0000000..01fd955
--- /dev/null
+++ b/lua/plugins/ui.lua
@@ -0,0 +1,111 @@
+return {
+  {
+    "nvim-tree/nvim-web-devicons",
+    enabled = vim.g.icons_enabled,
+    lazy = true,
+    opts = {
+      override = {
+        default_icon = { icon = require("astronvim.utils").get_icon "DefaultFile" },
+        deb = { icon = "", name = "Deb" },
+        lock = { icon = "󰌾", name = "Lock" },
+        mp3 = { icon = "󰎆", name = "Mp3" },
+        mp4 = { icon = "", name = "Mp4" },
+        out = { icon = "", name = "Out" },
+        ["robots.txt"] = { icon = "󰚩", name = "Robots" },
+        ttf = { icon = "", name = "TrueTypeFont" },
+        rpm = { icon = "", name = "Rpm" },
+        woff = { icon = "", name = "WebOpenFontFormat" },
+        woff2 = { icon = "", name = "WebOpenFontFormat2" },
+        xz = { icon = "", name = "Xz" },
+        zip = { icon = "", name = "Zip" },
+      },
+    },
+  },
+  {
+    "onsails/lspkind.nvim",
+    lazy = true,
+    opts = {
+      mode = "symbol",
+      symbol_map = {
+        Array = "󰅪",
+        Boolean = "⊨",
+        Class = "󰌗",
+        Constructor = "",
+        Key = "󰌆",
+        Namespace = "󰅪",
+        Null = "NULL",
+        Number = "#",
+        Object = "󰀚",
+        Package = "󰏗",
+        Property = "",
+        Reference = "",
+        Snippet = "",
+        String = "󰀬",
+        TypeParameter = "󰊄",
+        Unit = "",
+      },
+      menu = {},
+    },
+    enabled = vim.g.icons_enabled,
+    config = require "plugins.configs.lspkind",
+  },
+  {
+    "rcarriga/nvim-notify",
+    lazy = true,
+    init = function() require("astronvim.utils").load_plugin_with_func("nvim-notify", vim, "notify") end,
+    opts = {
+      on_open = function(win)
+        vim.api.nvim_win_set_config(win, { zindex = 175 })
+        if not vim.g.ui_notifications_enabled then vim.api.nvim_win_close(win, true) end
+        if not package.loaded["nvim-treesitter"] then pcall(require, "nvim-treesitter") end
+        vim.wo[win].conceallevel = 3
+        local buf = vim.api.nvim_win_get_buf(win)
+        if not pcall(vim.treesitter.start, buf, "markdown") then vim.bo[buf].syntax = "markdown" end
+        vim.wo[win].spell = false
+      end,
+    },
+    config = require "plugins.configs.notify",
+  },
+  {
+    "stevearc/dressing.nvim",
+    lazy = true,
+    init = function() require("astronvim.utils").load_plugin_with_func("dressing.nvim", vim.ui, { "input", "select" }) end,
+    opts = {
+      input = { default_prompt = "➤ " },
+      select = { backend = { "telescope", "builtin" } },
+    },
+  },
+  {
+    "NvChad/nvim-colorizer.lua",
+    event = "User AstroFile",
+    cmd = { "ColorizerToggle", "ColorizerAttachToBuffer", "ColorizerDetachFromBuffer", "ColorizerReloadAllBuffers" },
+    opts = { user_default_options = { names = false } },
+  },
+  {
+    "lukas-reineke/indent-blankline.nvim",
+    event = "User AstroFile",
+    main = "ibl",
+    opts = {
+      indent = { char = "▏" },
+      scope = { show_start = false, show_end = false },
+      exclude = {
+        buftypes = {
+          "nofile",
+          "terminal",
+        },
+        filetypes = {
+          "help",
+          "startify",
+          "aerial",
+          "alpha",
+          "dashboard",
+          "lazy",
+          "neogitstatus",
+          "NvimTree",
+          "neo-tree",
+          "Trouble",
+        },
+      },
+    },
+  },
+}
diff --git a/lua/resession/extensions/astronvim.lua b/lua/resession/extensions/astronvim.lua
new file mode 100644
index 0000000..6629f8e
--- /dev/null
+++ b/lua/resession/extensions/astronvim.lua
@@ -0,0 +1,46 @@
+local M = {}
+
+M.on_save = function()
+  -- initiate astronvim data
+  local data = { bufnrs = {}, tabs = {} }
+
+  local buf_utils = require "astronvim.utils.buffer"
+
+  data.current_buf = buf_utils.current_buf
+  data.last_buf = buf_utils.last_buf
+
+  -- save tab scoped buffers and buffer numbers from buffer name
+  for new_tabpage, tabpage in ipairs(vim.api.nvim_list_tabpages()) do
+    data.tabs[new_tabpage] = vim.t[tabpage].bufs
+    for _, bufnr in ipairs(data.tabs[new_tabpage]) do
+      data.bufnrs[vim.api.nvim_buf_get_name(bufnr)] = bufnr
+    end
+  end
+
+  return data
+end
+
+M.on_load = function(data)
+  -- create map from old buffer numbers to new buffer numbers
+  local new_bufnrs = {}
+  for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
+    local bufname = vim.api.nvim_buf_get_name(bufnr)
+    if bufname and data.bufnrs[bufname] then new_bufnrs[data.bufnrs[bufname]] = bufnr end
+  end
+  -- build new tab scoped buffer lists
+  for tabpage, tabs in pairs(data.tabs) do
+    vim.t[tabpage].bufs = vim.tbl_map(function(bufnr) return new_bufnrs[bufnr] end, tabs)
+  end
+
+  local buf_utils = require "astronvim.utils.buffer"
+  buf_utils.current_buf = new_bufnrs[data.current_buf]
+  buf_utils.last_buf = new_bufnrs[data.last_buf]
+
+  require("astronvim.utils").event "BufsUpdated"
+
+  if vim.opt.bufhidden:get() == "wipe" and vim.fn.bufnr() ~= buf_utils.current_buf then
+    vim.cmd.b(buf_utils.current_buf)
+  end
+end
+
+return M
diff --git a/neovim.yml b/neovim.yml
deleted file mode 100644
index b9235ab..0000000
--- a/neovim.yml
+++ /dev/null
@@ -1,6 +0,0 @@
----
-base: lua51
-
-globals:
-  vim:
-    any: true
diff --git a/selene.toml b/selene.toml
deleted file mode 100644
index e7005c3..0000000
--- a/selene.toml
+++ /dev/null
@@ -1,8 +0,0 @@
-std = "neovim"
-
-[rules]
-global_usage = "allow"
-if_same_then_else = "allow"
-incorrect_standard_library_use = "allow"
-mixed_table = "allow"
-multiple_statements = "allow"
